ÓàÏÒÇúÏß.txt			 
===========================			 
ÓàÏÒÖ±Ïß.txt			 
#include<stdio.h>
#include<math.h>
main()
{
double y;
int x,m,n,yy;
for(yy=0;yy<20;yy++)
{
y=0.1*yy;
m=acos(1-y)*10;
n=45*(y-1)+31;
for(x=0;x<=62;x++)
if(x==m&&x==n)
printf("+");
else if(x==n)
printf("+");
else if(x==m||x==62-m)
printf("*");
else
printf(" ");
printf("\n");
}
}===========================			 
Éµ¹Ïµİ¹é.txt			 
#include <stdio.h>
main() 
{ int m=1,n=1,s; 
 s=akm(m,n); 
printf("%d",s); 
} 

akm(int m,int n) 
{ if(m==0) 
    return n+1; 
else if(m!=0&&n==0) 
   akm(m-1,1); 
else if(m!=0&&n!=0) 
   akm(m-1,akm(m,n-1)); 
} ===========================			 
Ã°ÅİÅÅĞò.txt			 
   # include "stdio.h" 
 # include "stdlib.h" 
    struct node{ 
      int values; 
        struct node *next; 
       }; 
    struct node *create(int [],int); 
      void sort (struct node **); 
       int test_data[20000]={5,9,3,4,5,7,8}; 
   main() 
 { struct node *h,*p; 
h=create(test_data,20000); 
for(p=h;p;p=p->next) printf("%2d",p->values); 
printf("\n"); 
sort(&h); 
  for(p=h;p;p=p->next) printf("%2d" ,p->values); 
    printf("\n"); 
} 
struct node *create (int a[],int n) 
{struct node *h,*q; 
for(h=NULL;n;n--) 
{ q=(struct node *) malloc(sizeof(struct node)); 
q->values=a[n-1]; 
q->next=h; 
h=q; 
} 
return h; 
} 
void sort (struct node **h) 
{ struct node *q,*p,*r,*s,*h1; 
h1=p=(struct node *)malloc(sizeof(struct node)); 
p->next=*h; 
while(p->next!=NULL) 
{ q=p->next; 
 r=p;                   
while (q->next!=NULL) 
{ if(q->next->values<r->next->values) r=q; 
  q=q->next; 
  } 
  if(r!=p) 
   { s=r->next;       
     r->next=s->next; 
     s->next=p->next; 
     p->next=s; 
     }                           
     p=p->next; 
     } 
     *h=h1->next;/*ÎÊÌâ£ºh1ÔÚ³ÌĞòÖĞ×öÁËÉ¶ÓÃ£¿  */
     free(h1);                  
     } 
 
===========================			 
Ã°Åİ·¨¸Ä½ø.txt			 
/*   Ã°Åİ·¨ÊÇÊı¾İÅÅĞòµÄÒ»ÖÖ»ù±¾Ëã·¨,ËüµÄ»ù±¾·½·¨ÊÇ:ÏàÁÚÁ½ÔªËØ½øĞĞ±È½Ï,ÈçÓĞĞèÒªÔò½øĞĞ½»»»,
Ã¿Íê³ÉÒ»´ÎÑ­»·¾Í½«×îĞ¡ÔªËØÅÅÔÚ×îºó(Èç´Ó´óµ½Ğ¡ÅÅĞò),ÏÂÒ»´ÎÑ­»·ÊÇ½«ÆäËûµÄÊı½øĞĞÀàËÆ²Ù×÷?
Èç½«N ¸öÊı°´´Ó´óµ½Ğ¡ÅÅĞò,Turbo CÓïÑÔ³ÌĞòº¯Êı 
ÈçÏÂ: */

void sort(int a[],int n);ª¤ 
main()
{
    int a[100],i ,j ,n ;ª¤ 
 
    /*ÊäÈëÊı×éÔªËØµÄ¸öÊı¼°¸÷ÔªËØµÄÖµ*/ª¤ 
    scanf(£¢%d£¢,&n);ª¤ 
    for(i =0;i <n ;i ++ )scanf(£¢%d£¢,&a [i]);
    sort(a,n);ª¤ 
    for(i =0;i <n ;i ++ )printf(£¢%d£¢,a[i]);ª¤ 
    
}
  ª¤sort(int a[],int n)
    {ª¤
       int i ,j ,t ;ª¤ 
       for(i =n -2;i >=0; i--)ª¤ 
           for(j =0;j <i ; j++)
               if(a[j]<a[j +1]) 
               {
                   t =a[j];
                   a[j]=a[j +1];
                   a[j +1]=t ;
               }
    }ª¤ 
    
/*N ¸öÔªËØĞè±È½ÏN *(N -1)/2´Î,Ğ§ÂÊ½Ï²î?ÆäÊµ,¿É¸ù¾İÃ¿Ò»´ÎÑ­»·±È½ÏÖĞµÄÇé 
¿ö¸Ä½øÖ®?   [¸Ä½øÒ»]:ÈôÄ³´ÎÑ­»·ÖĞÃ»ÓĞÊı¾İ½»»»¹ı,Ôò¿ÉÈÏÎªÊı¾İÒÑ¾­ÓĞĞòÁË,
²»±ØÔÙ½øĞĞÑ­»·ÁË,¿ÉÔÚ³ÌĞòÖĞÉèÒ»±äÁ¿Flag ÓÃÀ´±êÊ¶ÓĞÎŞÊı¾İ½»»»? */

sort(int a[],int n)
{ª¤
	int i ,j ,t ,flag ;ª¤ 
	for (i =n -2;i >0; i--)ª¤ 
	{ª¤
		flag =0;ª¤ 
		for(j =0;j <i ; j++)
			if(a[j]<a[j +1])
			{
				t =a[j];
				a[j]=a[j +1];
				a[j +1]=t ;
				flag =1;
			}ª¤ 
		if (flag ==0)break;ª¤ 
	}
}

/*[¸Ä½ø¶ş]:Èç¹ûÔÚÒ»´ÎÑ­»·ÖĞ,×îºóµÄÄ³Ğ©ÔªËØÃ»ÓĞ½»»»¹ı,ÔòËµÃ÷ºóÃæÕâĞ©Ôª 
ËØµÄË³ĞòÒÑÅÅĞò,ÏÂ´ÎÑ­»·¿É²»¶ÔÆä½øĞĞ±È½Ï?±¾·½·¨Ö÷Òª¿¼ÂÇÒªÅÅĞòµÄÊı×éÔªËØµÄ·¶ 
Î§,¶ø²»ÊÇÃ¿Ò»ÂÖÅÅĞò¶¼½«Êı×éÔªËØµÄ·¶Î§¼õÉÙ1?*/

sort(int a[],int n)ª¤ 
{
	int i ,j ,t ,k,flag ;
	flag =n -1;ª¤ 
	while (flag >0)ª¤ 
	{
		k=0;ª¤ 
		for(j =0;j <i ;j ++)
		if(a[j]<a[j +1])
		{
			t =a[j];
			a[j]=a[j +1]; 
			a[j +1]=t ;
			k=j ;
		}ª¤ 
		flag =k; /*´Ë´¦²»Ìîflag = flag -1;*/
	}
}
===========================			 
¶¯Ì¬¼ÆËãÍøÂç×î³¤×î¶ÌÂ·Ïß.txt			 
/*
* File:        longest.c
* Desciption:  ¶¯Ì¬¹æ»®Ëã·¨¼ÆËãÍøÂçµÄ×î³¤Â·ÏßºÍ×î¶ÌÂ·Ïß
* Created:    2001/12/2
* Author:      Justin Hou [mailto:justin_hou@hotmail.com]
*
*/
#include <stdio.h>
#define  N  7                                              /* ¶¥µãÊıÄ¿    */
#define  I  999                                            /* ±íÊ¾ÎŞÇî´ó  */

int graph[N][N] = {                                        /* Í¼µÄÁÚ½Ó¾ØÕó */
        {I, 4, 5, 8, I, I, I},
        {I, I, I, 6, 6, I, I},
        {I, I, I, 5, I, 7, I},
        {I, I, I, I, 8, 9, 9},
        {I, I, I, I, I, I, 5},
        {I, I, I, I, I, I, 4},
        {I, I, I, I, I, I, I}
};
int List[N];                                                /* ´æ·ÅÍØÆËĞòÁĞ */

int TopologicalOrder();                                    /* ÍØÆËÅÅĞòº¯Êı */

void main()                                                /* Ö÷ º¯ Êı    */
{
        int i, j, k, l;
        int ee[N], el[N];                                  /* ×î³¤×î¶Ì¾àÀë */
        int path_e[N][N], path_l[N][N], n_e[N], n_l[N];    /* ¼ÇÂ¼Â·¾¶Êı¾İ */

        /* ³õÊ¼»¯Êı¾İ */
        for (i = 0; i < N; i++) {
                n_e[i] = 0;                      /* µ½ i µÄ×î¶ÌÂ·ÏßµÄ½áµãÊı */
                n_l[i] = 0;                      /* µ½ i µÄ×î³¤Â·ÏßµÄ½áµãÊı */
                ee[i] = I;
                el[i] = 0;
        }
        ee[0] = el[0] = 0;                                  /* ³õÊ¼»¯Í·½áµã */
        path_e[0][0] = 0;
        path_l[0][0] = 0;
        n_e[0] = 1;
        n_l[0] = 1;

        /* ÍØÆËÅÅĞò */
        if (!TopologicalOrder())
                return;

        /* ¶ÔÓÚÍØÆËĞòÁĞ,ÔËÓÃ¶¯Ì¬¹æ»®²½²½Ëã³ö×î³¤Â·ÏßÓë×î¶ÌÂ·Ïß */
        for (i = 0; i < N; i++) {

                /* ÌáÈ¡ÍØÆËĞòÁĞµÄÔªËØ */
                k = List[i];
                /* ¸üĞÂËüËùÖ¸Ïò¶¥µãµÄËùÓĞÊı¾İ */
                for (j = 0; j < N; j++) {

                        /* Ñ°ÕÒÖ¸ÏòµÄ¶¥µã */
                        if (graph[k][j] != I) {

                                /* Èç¹ûĞÂÂ·¾¶¸ü¶Ì */
                                if (graph[k][j] + ee[k] < ee[j]) {

                                        /* ¸üĞÂ×î¶ÌÂ·¾¶³¤¶È */
                                        ee[j] = graph[k][j] + ee[k];
                                        /* ¸üĞÂ×î¶ÌÂ·Ïß */
                                        for (l = 0; l < n_e[k]; l++) {
                                                path_e[j][l] = path_e[k][l];
                                        }
                                        path_e[j][l] = j;
                                        n_e[j] = l + 1;
                                }

                                /* Èç¹ûĞÂÂ·¾¶¸ü³¤ */
                                if (graph[k][j] + el[k] > el[j]) {

                                        /* ¸üĞÂ×î³¤Â·¾¶³¤¶È */
                                        el[j] = graph[k][j] + el[k];
                                        /* ¸üĞÂ×î³¤Â·Ïß */
                                        for (l = 0; l < n_l[k]; l++) {
                                                path_l[j][l] = path_l[k][l];
                                        }
                                        path_l[j][l] = j;
                                        n_l[j] = l + 1;
                                }
                        }
                }
        }

        /* Êä³ö½á¹ûµ½ÆÁÄ» */
        for (i = 0; i < N; i++) {
                printf("shortest(%d): %2d    Path: ", i + 1, ee[i]);
                for (j = 0; j < n_e[i]; j++) {
                        printf("%d ", path_e[i][j] + 1);
                }
                printf("\n");        
                printf("longest (%d): %2d    Path: ", i + 1, el[i]);
                for (j = 0; j < n_l[i]; j++) {
                        printf("%d ", path_l[i][j] + 1);
                }
                printf("\n");
        }
}

int TopologicalOrder()
{
        int i, j, top, count;
        int indegree[N], Stack[N];

        top = 0;                                            /* Õ»¶¥±êÖ¾    */
        for (i = 0; i < N; i++) {
                indegree[i] = 0;                            /* ³õÊ¼»¯Èë¶È  */
                for (j = 0; j < N; j++) {
                        if (graph[j][i] != I) {            /* ÈçÁ¬Í¨      */
                                indegree[i]++;              /* Èë¶È×ÔÔö1    */
                        }
                }
                if (!indegree[i]){                          /* ÈçÈë¶ÈÎªÁã  */
                        Stack[top++] = i;                  /* ÈëÕ»        */
                }
        }
        count = 0;                                          /* Êä³ö¶¥µãÊı  */
        while (top != 0) {
                i = Stack[--top];
                List[count++] = i;
                for (j = 0; j < N; j++) {
                        if (graph[i][j] != I) {            /* ÈçÁ¬Í¨      */
                                if (!(--indegree[j])) {    /* ¶øÇÒÈë¶ÈÎªÁã */
                                        Stack[top++] = j;  /* ÈëÕ»        */
                                }
                        }
                }/* for */
        }/* while */

        return (count < N) ? 0 : 1;
}
===========================			 
Ê®ÎåÈËÅÅĞò.txt			 
/*Ô­Ìâ£º Ò»ÇŞÊÒÓĞ15¸öÈË£¬Ã¿Ìì¶¼ÒªÈıÈËÒ»ĞĞÍâ³öÉ¢²½Ò»´Î£¬ÒªÔÚÒ»ÖÜ
£¨7Ìì£©ÄÚ Ã¿¸öÈË¶¼¸úÆäËû14ÈË¸÷É¢²½Ò»´Î£¬ÎÊÃ¿Ò»ÌìÓ¦¸ÃÔõÃ´°²ÅÅ£¿£¿ 
Òª¿ìµãÏëÓ´£¡£¡£¡£¡ ¶¼µÈÒ»»á15·ÖÖÓ*/

#include <stdio.h> 
int anpai[7][5][3]; 
int biaozhi[16][16]; 
int i=0,j=0,k=0,a,total=0; 
void huisu() 
{   
if(k==1) 
{   anpai[ i ][j][0]=0;  j--; 
if(j==-1) {  i--; j=4; } 
biaozhi[anpai[ i ][j][2]][anpai[ i ][j][1]]=0; 
biaozhi[anpai[ i ][j][2]][anpai[ i ][j][0]]=0; 
k=2;  a=anpai[ i ][j][k]; anpai[ i ][j][k]=0;  total-=2; 
} 
else if(k==2)  { biaozhi[anpai[ i ][j][1]][anpai[ i ][j][0]]=0; 
                 a=anpai[ i ][j][--k];  anpai[ i ][j][k]=0; total--; 
} 
} 
void main() 
{   
int b,c,t; 
   for(a=1; a<=15&&total<105; a++) 
{   t=0; 
for(b=0; b<=j; b++) 
for(c=0; c<3; c++) 
if(anpai[ i ][ b ][c]==a) {  b=9; break; } 
if(b==10) 
{ 
   while(a==15) huisu(); 
continue; 
} 
   for(b=0; b<k; b++) 
if(biaozhi[a][anpai[ i ][j][ b ]]==1) 
{ 
  while(a==15) { huisu(); t=1; } 
  break; 
} 
if(b<k||t==1) continue; 
if(a==15&&k<2) { while(a==15) huisu();   continue; } 
switch(k) 
{ 
case 0: anpai[ i ][j][k++]=a; total++; break; 
case 1: anpai[ i ][j][k++]=a; total++; 
   biaozhi[a][anpai[ i ][j][0]]=1;  break; 
case 2: anpai[ i ][j][k]=a;   total++; 
   biaozhi[a][anpai[ i ][j][0]]=1; 
biaozhi[a][anpai[ i ][j][1]]=1; 
j++; 
if(total%15==0) { i++; j=0; } 
k=0; a=0; break; 
} 
} 
 for(a=1;a<8; a++)   
 printf("µÚ%dÌì      ",a); 
     for(j=0; j<5; j++) 
 {   printf("\n"); 
 for(i=0; i<7; i++) 
 { 
if(i>0&&i<7) printf("  "); 
for(k=0; k<3; k++) 
    printf("%-2d ", anpai[ i ][j][k]); 
 } 
 } printf("\n"); 
} ===========================			 
µ¥Ñ­»·Á´±í.txt			 
# define null 0
typedef char ElemType;

typedef struct Circular
{
	ElemType data;
	struct LNode *next;
};

setnull(struct Circular **p)
{	
	*p=null;
}
int length (struct Circular **p)
{
	int n=0;
 	struct Circular *q=*p;
 	while (q!=null)
 	{
 		n++;
  		q=q->next;
 	}
 	return(n);
}

ElemType get(struct Circular **p,int i)
{
	int j=1;
	struct Circular *q=*p;
	while (j<i&&q!=null)
 	{
 		q=q->next;
  		j++;
 	}
 	if(q!=null)
   		return(q->data);
 	else
 		printf("position parameter is incorrect!\n");
}

int locate(struct Circular **p,ElemType x)
{
	int n=0;
 	struct Circular *q=*p;
 	while (q!=null&&q->data!=x)
 	{
 		q=q->next;
  		n++;
 	}
 	if(q=null)
 		return(-1);
 	else
 		return(n+1);
}

void insert(struct Circular **p,ElemType x,int i)
{
	int j=1;
 	struct Circular *s,*q;
  	s=(struct Circular *)malloc(sizeof(struct Circular));
  	s->data=x;
  	q=*p;
  	if(i==1)
  	{
  		s->next=q;
   		p=s;
  	}
  	else
  	{
  		while(j<i-1&&q->next!=null)
   		{
   			q=q->next;
    			j++;
   		}
   		if(j==i-1)
    		{
    			s->next=q->next;
     			q->next=s;
    		}
   		else printf("position parameter is incorrect!\n");
  	}
}

void delete(struct Circular **p,int i)
{
	int j=1;
 	struct Circular *q=*p,*t;
 	if(i==1)
  	{	
  		t=q;
  		*p=q->next;
  	}
 	else
  	{
  		while(j<i-1&&q->next!=null)
   		{
   			q=q->next;
    			j++;
   		}
    		if(q->next!=null&&j==i-1)
     		{
     			t=q->next;
      			q->next=t->next;
     		}
    		else printf("position parameter is incorrect!\n");
  	}
   	if(t=null)
     		free(t);
}

void display(struct Circular **p)
{
	struct Circular *q;
 	q=*p;
 	printf("LinkList display: ");
 	if(q==null)
  		printf("LinkList is Null!");
 	else if (q->next==null)
       		printf("%c\n",q->data);
      	else
      	{	
      		while(q->next!=null)
	    	{
	    		printf("%c->",q->data);
	     		q=q->next;
	    	}
	   	printf("%c",q->data);
	}
 	printf("\n");
}

main()
{
	struct Circular *head,*q; char e; int i,n; char y; int select,x1,x2,x3,x4,m;
 	head=setnull();
 	printf("ÇëÊäÈëÊı¾İ³¤¶È:")£»
 	scanf("%d",&n);
 	for(i=1;i<n;i++);
 	{
 		printf("½«Êı¾İ²åÈëµ½µ¥Ñ­»·Á´±íÖĞ£º");
 		scanf("%d",&y);
 		insert(&head,y,i);}
 		display(&head);
 		printf("select 1 Çó³¤¶È length()");
 		printf("select 2 È¡½áµã get()" );
 		printf("select 3 ÇóÖµ²éÕÒ locate()");
 		printf("select 4 É¾³ı½áµã delete()");
 		printf("input your selete: ");
 		scanf("%d",&select);
		switch(select)
		{
			case 1:
			{
				x1=length(&head);
         			printf("ÊäÈëµ¥Ñ­»·Á´±íµÄ³¤¶È:",x1);
         			display(&head);
         			break;
         		}
 			case 2:
 			{
 				printf("ÇëÊäÈëÒªÈ¡µÃ½áµã:");		
         			scanf("%d",&m);
         			x2=get(&head,m);
         			printf(x2);
         			display(&head);
         			break;
         		}
 			case 3:
 			{
 				printf("ÇëÊäÈëÒª²éÕÒµÄÊı¾İ:");
         			scanf("%d",&e);
         			x3=locate(&head,e);
         			printf(x3);
         			display(&head);
         			break;
         		}
 			case 4:
 			{
 				printf("ÇëÊäÈëÒªÉ¾³ıµÄ½áµã:");
         			scanf("%d",&m);
         			x4=delete(&head,m);
         			printf(x4);
         			display(&head);
         			break;
         		}		      			
		}
	}
}===========================			 
µ¥´Êµ¹×ª.txt			 
/*ÈçºÎÊµÏÖÕâ¸öËã·¨ 
This is a good day today -> sihT si a doog yad yadot */

#include "stdafx.h" 
#include "string.h" 
#include "malloc.h" 

char *fun(char *a);

int main(int argc, char* argv[]) 
{ 
   char *string = "This is a good day today"; 
   char *ll=fun(string); 
   printf("%s",ll); 
   return 0; 
} 
 
char *fun(char *a) 
{ 
   char *ptt = (char *)malloc(strlen(a)); 
   ptt = a; 
   char *ftt = (char *)malloc(strlen(a)); 
   *ftt = '\0'; 
   char step[] = " "; 
   char *token; 
   token = strtok( strdup(a),step); 
/*strtok()¼ìË÷×Ö·û´®s1,¸Ã×Ö·û´®s1ÊÇÓÉ×Ö·û´®s2ÖĞ¶¨ÒåµÄ¶¨½ç·ûËù·Ö¸ô*/
/*strdup()½«×Ö·û´®s¸´ÖÆµ½×î½ü½¨Á¢µÄµ¥Ôª*/
   while(token != NULL) 
   { 
      strcat(ftt,strrev(token)); /*strrev()½«×Ö·û´®s¸´ÖÆµ½×î½ü½¨Á¢µÄµ¥Ôª*/
      strcat(ftt," "); 
      token = strtok( NULL,step); 
   } 
   *(ftt + strlen(a)-1) = '\0'; 
   return  ftt; 
} ===========================			 
µ¥Á´±í.txt			 
/*µ¥Á´±íµÄ¸÷ÖÖ²Ù×÷*/

# define null 0

typedef char ElemType; /* ×Ö·ûĞÍÊı¾İ*/

typedef struct LNode
{
	ElemType data;
	struct LNode *next;
};
		
setnull(struct LNode **p);
int length (struct LNode **p);
ElemType get(struct LNode **p,int i);
void insert(struct LNode **p,ElemType x,int i);
int delete(struct LNode **p,int i);
void display(struct LNode **p);

main()
{
	struct LNode *head,*q;  /*¶¨Òå¾²Ì¬±äÁ¿*/
	int select,x1,x2,x3,x4;
	int i,n; 
	int m,g;
	char e,y; 
	
 	head=setnull(&head);  /*½¨ÒéÁ´±í²¢ÉèÖÃÎª¿Õ±í*/
 	printf("ÇëÊäÈëÊı¾İ³¤¶È: ");
 	scanf("%d",&n);
 	for(i=1;i<n;i++);
 	{
 		printf("½«Êı¾İ²åÈëµ½µ¥Á´±íÖĞ: ");
 		scanf("%d",&y);
 		insert(&head,y,i);}  /*²åÈëÊı¾İµ½Á´±í*/
 		display(&head);	 /*ÏÔÊ¾Á´±íËùÓĞÊı¾İ*/
 		
 		printf("select 1 Çó³¤¶È length()\n");
 		printf("select 2 È¡½áµã get()\n");
 		printf("select 3 ÇóÖµ²éÕÒ locate()\n");
 		printf("select 4 É¾³ı½áµã delete()\n");
 		printf("input your select: ");
 		scanf("%d",&select);	
		switch(select)
		{
			case 1:
			{
				x1=length(&head);
				printf("Êä³öµ¥Á´±íµÄ³¤¶È%d ",x1);
	 			display(&head);
	 		}break;
	 		
	 		case 2:
	 		{
	 			printf("ÇëÊäÈëÒªÈ¡µÃ½áµã: ");
         			scanf("%d",&m);
         			x2=get(&head,m);
         			printf(x2);
	 			display(&head);
	 		}break;
	 	
 			case 3:
 			{
 				printf("ÇëÊäÈëÒª²éÕÒµÄÊı¾İ: ");
         			scanf("%d",&e);
         			x3=locate(&head,e);
         			printf(x3);
	 			display(&head);
	 		}break;
 			
 			case 4:
 			{
 				printf("ÇëÊäÈëÒªÉ¾³ıµÄ½áµã: ");
         			scanf("%d",&g);
         			x4=delete(&head,g);
         			printf(x4);
	 			display(&head);
	 		}break;
		}
	}
}


setnull(struct LNode **p)
{
	*p=null;
}

int length (struct LNode **p)
{
	int n=0;
 	struct LNode *q=*p;
 	while (q!=null)
 	{
 		n++;
  		q=q->next;
 	}
 	return(n);
}

ElemType get(struct LNode **p,int i)
{
	int j=1;
	struct LNode *q=*p;
	while (j<i&&q!=null)
 	{
 		q=q->next;
  		j++;
 	}
 	if(q!=null)
   		return(q->data);
 	else
 		printf("Î»ÖÃ²ÎÊı²»ÕıÈ·!\n");
}

int locate(struct LNode **p,ElemType x)
{
	int n=0;
 	struct LNode *q=*p;
	while (q!=null&&q->data!=x)
 	{
 		q=q->next;
  		n++;
 	}
 	if(q==null)
 		return(-1);
 	else
 		return(n+1);
}

void insert(struct LNode **p,ElemType x,int i)
{
	int j=1;
 	struct LNode *s,*q;
  	s=(struct LNode *)malloc(sizeof(struct LNode));
  	s->data=x;
  	q=*p;
  	if(i==1)
  	{
  		s->next=q;
   		p=s;
  	}
  	else
  	{
  		while(j<i-1&&q->next!=null)
   		{
   			q=q->next;
    			j++;
   		}
   		if(j==i-1)
    		{
    			s->next=q->next;
     			q->next=s;
    		}
   		else 
   			printf("Î»ÖÃ²ÎÊı²»ÕıÈ·!\n");
  	}	
}

int delete(struct LNode **p,int i)
{
	int j=1;
 	struct LNode *q=*p,*t;
 	if(i==1)
  	{
  		t=q;
  		*p=q->next;
  	}
 	else
  	{
  		while(j<i-1&&q->next!=null)
   		{
   			q=q->next;
    			j++;
   		}
    		if(q->next!=null&&j==i-1)
     		{
     			t=q->next;
      			q->next=t->next;
     		}
    		else 
    			printf("Î»ÖÃ²ÎÊı²»ÕıÈ·!\n");
  	}
   	if(t=null)	
   		free(t);
}

void display(struct LNode **p)
{	
	struct LNode *q;
 	q=*p;
 	printf("µ¥Á´±íÏÔÊ¾: ");
 	if(q==null)
  		printf("Á´±íÎª¿Õ!");
 	else if (q->next==null)
       		printf("%c\n",q->data);
      	else
      	{
      		while(q->next!=null)
	    	{
	    		printf("%c->",q->data);
	     		q=q->next;
	    	}
	   	printf("%c",q->data);
	}
 	printf("\n");
}

===========================			 
µ¥Á´±í1.txt			 
#include<stdlib.h>
#include<stdio.h>
struct roommate
{
char name;
long num;
int age;
char birthplace;
struct roommate *next;
};
struct roommate *head,*cthis,*cnew;

void ins_record(void)
{
int i,j=0;
char numstr,b;
cthis=head;
printf("\nInput a num :");
scanf("%d",&i);
while(j<i-2)
  {
  cthis=(struct roommate*)malloc(sizeof (struct roommate));
  cthis=cthis->next;
  ++j;

  }
  if(j>i-1)
  return;
  cnew=(struct roommate*)malloc(sizeof (struct roommate));
 
  printf("\nplease input the information:");
  printf("\nenter name:");
  scanf("%s", &cnew->name);
 
  printf("\nenter number:");
  scanf("%ld",&cnew->num);
  printf("\nenter age:");
  scanf("%d",&cnew->age);
  printf("\nenter birthplace:");
  scanf("%s",&cnew->birthplace);
  cnew->next=cthis;

}
main()
{
ins_record();
}===========================			 
µ¥Á´±í2.txt			 
#include<stdio.h> 
#include<malloc.h> 
struct node{ 
        int key; 
        struct node *next; 
        }; 
void creat_link(struct node *); 
main() 
{ 
 struct node *head=NULL; 
 creat_link(head);/*ÕâÀï¿ÉÒÔÕâÃ´µ÷ÓÃÂğ£¿*/   
} 
void creat_link(struct node *head_node) 
{ 
struct node *p,*q,*Temp; 
int number; 
printf("Please input data:[-1 is End]\n"); 
scanf("%d",&number); 
while(number!=-1){ 
 q=(struct node *)malloc(sizeof(struct node)); 
 q->key=number; 
 if(head_node==NULL ){ 
           head_node=q; 
           p=q; 
          } 
  else{ 
        p->next=q; 
        p=q; 
        } 
   scanf("%d",&number); 
  } 
p->next=NULL; 
 Temp=head_node; 
 while(Temp!=NULL){ 
  printf("%d\n",Temp->key); 
  Temp=Temp->next;
 }
} 
 ===========================			 
µ¥Á´±íµ¹Ğò.txt			 
#include<stdio.h>


struct fsb
{
	int  data;
	int  flag;
    	struct fsb * next;
};
main()
{
	struct fsb  *p,*head,*sta,*end;
	int i,cishu,j;
	end=(struct fsb *)malloc(sizeof(struct fsb));
	end->data=0;
	end->flag=0;
	end->next=NULL;
	head=p=end;
	
	for (i=2;i<=10;i++)
	{
  		end=(struct fsb *)malloc(sizeof(struct fsb));
  		end->data=i-1;
  		end->flag=0;
  		end->next=NULL;
  		p->next=end;
  		p=end;
	}
	p->next=NULL;
	printf("\nµ¹ĞòÇ°£º");
	p=head;	
	for(i=1;i<=10;i++)
	{
		printf("%d ",p->data);
		p=p->next;
	}
/*************************/
	p=NULL;
	while(head->next != NULL)
	{
  		sta=head; 
  		head=head->next;
  		sta->next=p;
  		p=sta;
  	}
	head->next=sta;
	printf("\nµ¹Ğòºó£º");
	p=head;
	for(i=1;i<=10;i++)
	{
		printf("%d ",p->data);
		p=p->next;
}
/*************************/
}===========================			 
µ¥Á´±íµÄ´¦ÀíÈ«¼¯.txt			 
/*Ë­ÓĞĞËÈ¤Ò»ÆğÀ´·á¸»Õâ¸ö³ÌĞòµÄµÄ¹¦ÄÜ£¿£¿*/
#include<stdio.h>
#include<stdlib.h>
#define MAX 20
#define ELEMTP int

#define v (*p)

struct node
{
	ELEMTP data;
	struct node *next;
};

struct node *p,*q,*s,*head;
int j=0,i,k;
main()
{
	int x,y,cord;
	void outlin(struct node *h);
	void create();
	void insert(struct node *h,int x,int y);
	void deletes(struct node *h,int x);
	struct node *MaxCompare(struct node *h);
	struct node *MinCompare(struct node *h);
	int delIterance(struct node *h);
	void batchInsert(struct node *h,int x);
	void batchDelete(struct node *h,int x,int y);
	void Cz(struct node*  h);
	void Xg(struct node * h);
	printf("½¨Á¢Á´±í£¬ÊäÈë-999Íê³ÉÁ´±í: \n");
	create();
	i=j;
	outlin(head);
	do{
		printf("\n        Ö÷²Ëµ¥        \n");
		printf("     1   ²åÈëÒ»¸öÔªËØ   \n");
		printf("     2   É¾³ıÒ»¸öÔªËØ   \n");
		printf("     3   ÉıĞòÅÅĞò       \n");
		printf("     4   ½µĞòÅÅĞò       \n");
		printf("     5   ²éÕÒÔªËØ       \n");
		printf("     6   ĞŞ¸ÄÔªËØ       \n");
		printf("     7   É¾³ıÖØ¸´ÔªËØ   \n");
		printf("     8   ÅúÁ¿¼ÓÈëÔªËØ   \n");
		printf("     9   ÅúÁ¿É¾³ıÔªËØ   \n");
		printf("     0   ½áÊø³ÌĞòÔËĞĞ   \n");
		printf("-----------------------------------------\n");
		printf(" ÇëÊäÈëÄúµÄÑ¡Ôñ(1, 2, 3, 4, 5, 6, 7, 8, 9, 0) ");
		scanf("%d",&cord);
		switch(cord)
		{
			case 1:
			{
				printf("ÇëÊäÈë²åÈëµÄÎ»ÖÃ i: ");
				scanf("%d",&x);
				printf("ÇëÊäÈë²åÈëµÄÊı¾İ y: ");
				scanf("%d",&y);
				insert(head,x,y);
				i=j;
				outlin(head);
			}break;
			case 2:
			{
				printf("x=?");
				scanf("%d",&x);
				deletes(head,x);
				i=j;
				outlin(head);
			}break;
			case 3:
			{
				printf("Á´±íÓÉ´óµ½Ğ¡ÊÇ");
				s=MaxCompare(head);
				j=i;
				outlin(s);
				//outlin(head);
			}break;
			case 4:
			{
				printf("Á´±íÓÉ´óµ½Ğ¡ÊÇ");
				s=MinCompare(head);
				j=i;
				outlin(s);
			}break;
			case 5:
			{
				Cz(head);
				outlin(head);
			}break;
			case 6:
			{
				Xg(head);
				outlin(head);
			}break;
			case 7:
			{
				k=delIterance(head);
				i=i-k;
				j=i;
				outlin(head);
			}break;
			case 8:
			{
				printf("ÇëÊäÈë²åÈëµÄÎ»ÖÃ i: ");
				scanf("%d",&x);
				batchInsert(head,x);
				i=j;
				outlin(head);
			}break;
			case 9:
			{
				printf("ÇëÊäÈëÉ¾³ıµÄÆğÊ¼Î»ÖÃ i: ");
				scanf("%d",&x);
				printf("ÇëÊäÈëÉ¾³ıµÄ½áÊøÎ»ÖÃ y: ");
				scanf("%d",&y);
				batchDelete(head,x,y);
				i=j;
				outlin(head);
			}break;
			case 0:
			{
				exit(0);
			}break;
		}
	}while(cord<=9&&cord>=0);
}

void outlin(struct node *h)
{
	p=h->next;
	while(p!=NULL)
	{
		printf(" data=%4d ",p->data);
		p=p->next;
	}
	printf("\nÊä³ö½áÊø\n\n");
}

void deletes(struct node *h,int x)//É¾³ı½Úµã
{
	p=h;
	while(p->next!=NULL&&p->next->data!=x)		p=p->next;
	if(p->next==NULL)
		printf("x ²»´æÔÚ !");
	else
	{
		q=p->next;
		p->next=q->next;
		free(q);
		--j;
	}

}

void insert(struct node *h,int x,int y)
{
	s=(struct node*)malloc(sizeof(struct node));
	s->data=y;
	q=h;p=h->next;
	while(p!=NULL&&p->data!=x)
	{
		q=p;
		p=p->next;
	}
	q->next=s;
	s->next=p;
	++j;
}

void create()//½¨Á¢Á´±í
{
	int x;
	head=(struct node*)malloc(sizeof(struct node));
	head->next=NULL;
	p=head;
	printf("x=?");
	scanf("%d",&x);
	while(x!=-999)
	{
		s=(struct node*)malloc(sizeof(struct node));
		s->data=x;
		s->next=NULL;
		p->next=s;
		p=s;
		printf("x=?");++j;
		scanf("%d",&x);
	}
}

/////////////ÒÔÏÂº¯ÊıÓÉÆß¾øÍæ¼Ò±àĞ´/////////////

struct node *MaxCompare(struct node *h)//ÓÉ´óµ½Ğ¡ÅÅĞò
{        
	struct node *t;
	int x;
	t=h;s=NULL;
	while(j!=0)
	{
	x=t->next->data;
	q=t->next;
	while(q!=NULL)
	{
		if(q->data<=x)
			x=q->data;
		else
			x=x;
		q=q->next;	
	}
	p=t;
	while(p->next!=NULL&&p->next->data!=x)
		p=p->next;
	q=p->next;
	p->next=q->next;
	t=p;t=h;
	p=q;p->next=s;
	s=p;
	j--;
	}
	t->next=s;
	head=t;
	return (t);
}

struct node *MinCompare(struct node *h)//ÓÉĞ¡µ½´óÅÅĞò
{
	struct node *t;
	int x;
	t=h;s=NULL;
	while(j!=0)
	{
	x=t->next->data;
	q=t->next;
	while(q!=NULL)
	{
		if(q->data>=x)
			x=q->data;
		else
			x=x;
		q=q->next;	
	}
	p=t;
	while(p->next!=NULL&&p->next->data!=x)
		p=p->next;
	q=p->next;
	p->next=q->next;
	t=p;t=h;
	p=q;p->next=s;
	s=p;
	j--;
	}
	t->next=s;
	head=t;
	return (t);
}

int delIterance(struct node *h)//É¾³ıÖØ¸´ÔªËØ
{
	int x,y=0;
	--j;
	s=h->next;
	while(j>0)
	{	
		x=s->data;
		p=s;
		while(p->next!=NULL)
		{
			if(p->next==NULL)
			{
				x=x;
			}
			else if(p->next->data==x)
			{
				q=p->next;
				p->next=q->next;
				free(q);
				--j;
				++y;
			}
			else
			{
				p=p->next;
			}
		}
		s=s->next;
		--j;
	}
	return y;
}

void batchInsert(struct node *h,int x)//ÅúÁ¿¼ÓÈë
{
	int y=0;
	q=h;p=h->next;
	while(p!=NULL&&p->data!=x)
	{
		q=p;
		p=p->next;
	}
	printf("y=?");
	scanf("%d",&y);
	while(y!=-999)
	{
	s=(struct node*)malloc(sizeof(struct node));
	s->data=y;
	q->next=s;
	s->next=p;
	q=s;
	printf("y=?");
	scanf("%d",&y);
	++j;
	}
}

void batchDelete(struct node *h,int x,int y)//ÅúÁ¿É¾³ı
{
	int k=0,w=0;
	struct node *t;
	p=h;q=h;
	while(p->next!=NULL&&p->next->data!=x)
	{
		++k;
		p=p->next;
	}
	while(q->next!=NULL&&q->next->data!=y)
	{
		++w;
		q=q->next;
	}
	if(p->next==NULL||q->next==NULL)
		printf("ÊäÈëµÄÎ»ÖÃ²»ÕıÈ·£¬ÇëÖØĞÂ¿ªÊ¼£¡");
	else if(k<w)
	{
		s=q->next;
		while(p->next!=s)
		{
			t=p->next;
			p->next=t->next;
			free(t);
			--j;
		}

	}
	else if(w=k)
	{
		printf("Ã»ÓĞÉ¾³ıÔªËØ");
	}
	else
	{
		s=p->next;
		while(q->next!=s)
		{
			t=q->next;
			q->next=t->next;
			free(t);
			--j;
		}
	}
}

//////////////Æß¾øÍæ¼Ò±àĞ´½áÊø//////////////

//////////////ÒÔÏÂº¯ÊıÓÉlihk±àĞ´////////////
void Cz(struct node*  h)            //²éÕÒ// 
{
	struct node * num;int i; 
	num=head ; 
	printf("ÊäÈëÄúÒª²éÕÒµÄºÅÂë:"); 
	scanf("%d",&i); 
	while(i!=num->data && num->next!=NULL) 
	{   
		num=num->next; 
	} 
	if (i==num->data) 
 		printf("ºÅÂë:%d",num->data); 
	else 
 		printf("¸ÃºÅÂë²»ÔÚÁ´±íÀï."); 
} 

void Xg(struct node * h) //ĞŞ¸Ä// 
{ 
	struct node * num; int i; 
	num=head; 
	printf("²éÕÒÄúÒªĞŞ¸ÄµÄºÅÂë:"); 
	scanf("%d",&i); 
	while(i!=num->data&&num->next!=NULL){ 
		num=num->next;} 
	if (i==num->data)
	{ 
   		printf(":%d\n",num->data); 
   		printf("ÊäÈëÄúÒªĞŞ¸ÄµÄĞÂĞÅÏ¢:"); 
		printf("ºÅÂë:"); 
   		scanf("%d",&num->data); 
   		printf("\nĞŞ¸Ä³É¹¦!");
   	} 
	else 	
   		printf("¸ÃºÅÂë²»ÔÚÁ´±íÀï!");  
} 

//////////////lihk±àĞ´½áÊø/////////////////===========================			 
Ë«Á´±íÕıÅÅĞò.txt			 
#include<stdio.h> 
#include<stdlib.h> 
#include<malloc.h> 
struct list{ 
  int data; 
  struct list *next; 
  struct list *pre; 
  }; 
typedef struct list node; 
typedef node *link; 
link front=NULL,rear,ptr,head=NULL; 

link push(int item){ 
link newnode=malloc(sizeof(node)); 
 newnode->data=item; 
 if(head==NULL)
 {
 head=newnode; 
 head->next=NULL; 
 head->pre=NULL;
 rear=head;
 }
 else
 {
 rear->next=newnode;
 newnode->pre=rear;
 newnode->next=NULL;
 rear=newnode;
 }
 return head; 
 } 

void makenull(){         \³Q˜`¶™2±öÃ7óà¨Ôà&ÜÏÙ>™»ĞÕ(òw¹î8ÍóÎ@Íy(]«Ô+œgNÑ¥Ó!9<yyò>Ş©R0£²ìcLçŸ½]¾Ñ”’íÈıL´£,ñ’™ñT·m)Z¡¹Õ•dĞ;¨¥; Ä3s]r´ß´›å§òaÇ‰â|ğÑ“¶àÎæ1Ö­Z!h¹í,—+tHnï¬OwUZëp
UHRæWpœŠ9®bg\`œZ÷&7¤àG»Ğ&­f…Å¯Ã2¾°ãâpó®<æY 1<^*NâˆIL®öZ´	%k~Åİ§'gíÌ¬iø¼›ã
Œbg kó9EÕ>êˆğÏÄçãzûR5uHŠÂ-¥-íq8÷³=¦<„úzg2‘m+mi+Z¶‰0=•òÚÂ›€ış±y¼À#~(İïÅ›„‡iÅ–‰"Ò"‹qºU{à}w bıàršáÖÿl“î
ëGGüÍpVYØğÜj3:Ür}ìÓÎÅ¼ÍMjN:”øXÁºG‘a”’y|¦æ?gñ¨À…A2ÎU¿Ô>í‰‰QYå’¥øë5¨øCE¦vô†.£%ÅLã'³v|Ş¾yL	Şv­úâç)€ ˆLj‹yæ	!ÿê+O§+¾!‰Zä­4ú }{Ë×xÖ±Ù»¬LWñ\ô"=ÊäuİïÇöÆ°øÜÜa’ª=ú™ÅµMÃ¢æê†·ftEWL•ú»^°”\ÚwM#lâŸï'Ì¡¶­ıÓbfm¤ Š¢yv°„Y5uEıB”ÍÑ¬İ»lÛü.Âµv{2×@¹F†(8ÚZ‰§$My—)”›”õ‰¹ÙñzHù·Mya|#Ëó»,¼›@	RÓ¥­y³r²¡>¾Ì«
œ…Óñm<Òfƒ1è[³çŠf˜"f_è<wÍe_eœsËQeL»“´EÇÇg-³wË³SöDåUMôµ•Hµ[JÕ_>–Èº°nçÖĞIªxÆ¨/xå[>¹Ö +h³ˆ^Çƒ7½Ú1áãhÉ¢è»6È¬sH£ÀÒÅ…Ô3!bŞÔ‡â4Û9xºåĞæ#Í3{i²U«' º\iÑ|u/dMD*{\LvÍVqrS…¿‚]oï!å Å_°AiCQÉê`xÕšU¸ë)—ª$ºræDO–>aãõ9#,ˆ˜hÇóXrKá&²lòÁéIfbR’ğ}m4É{¼Nµ†ûPşv 8 ¾©Ù¨†(€{wVô4aVÆq›øKQk .­ŸwÓúCòyñ“Q`^æı?õ1‡àÆÈæˆ]HĞîkÉ‹z™èãb2rK7Ô!]ªxîÛc™Š"ÔÖ.P¦J>H;]®rÂ±|Li¬oÔ©1lÛ¨Ş|,Î—:‡æš*õÑâŒõ¢ø#k¢„ÌÀ¯À(·4ıö}[ö›(HÙ£+šoj@.ÄÍLŠI|Ë`ØBw‹.ïÔGzÛ¯håòVâ‹³WœbC8*Cª&‘ŒÕ0µvè’Ö’á´q&bV+]>ñ!ba”QªyÜ•7ìjJÔ{K£æÒí§ëù °İÊ)–­ñæhms&›CÕp;ı¨š¨_jˆi¥a¬rQîb°áF*-¬¼¦üVÖ€ƒâVoW"ÕŸuõ½b{OŸœ5¿­!ıŒçÕ¥T€:İÚUĞNK‹œ‰[¹-„€¶YM‡ce@CbqšÕåGk©—îBî:Hûİ´I³j3‰i¿4ş¯††wJ—Åv§qÌ†Ğ¥”G¬pb«½Iø…Rùs3Pº'k¥|sÔëdJéÀÀåŸ•ÎP½õÓÏğJ|¦yx"Öb„BÉZYbâüP¦ººI$ [ÍÍÁ)²l¯â>wÄÑñ0‘\°&\‘µ °¿w½«Íùyfù¨üí·-ÚXşé£!jx8ôgJ»é3#­kaÉŒ‘11‡]L@Axùãc¼ ÖÂöËùOMQ¶Â—n¥“áF\Ğa¥ª5… ‹am(PÇˆ‡>øq·ã0XİéZŠ2ïdxöWİÃ“Õò-(çb
Èoµê¥xIıì5MG'”Ív.rò§;gä¿sRíCoCÒ¦š ëíæ#¼ñªíz9Ó»w=‡iV‰IòÎ-ÕĞ“úän[0ÊŠ†'Üj•>ñW8-ÅXãÒSH‡ßz¸ ÏR,ÚS’K¹Ä¥—Ææö,,{¥ùş …B@Å’M'¡\3^–İ|qàøse±Ç"¶ Y4»:$.ì7Q;Ï£7Ï¥‚ 2„%ù/cÒîö<H¢Â9q ½øÙ9~Òn×éé¶Ü$ç?R'£…Ú#N\¾Ê wQPø€¨…no¿¸”(\¢ã/(HqÕï îC:-t:­xK9ä-ÿÌa#4)©¼gÆ/xyËöV& DAÃâ;R˜sÚ°,Ëq$eıºeü&ÊÊÿA;Ñ\AÖyco`JjjàtŞä;
¬5;†Ê³fhQ‰…4=dŒƒ.¤zË^%h@?Î3İ½4­À¢&ÂHÍNc}äJ‚¹cİdßtı	›k„m¸±ÂÕÔ=P?–¢˜4}{6WÚtn¿! ïÁy ¿=QêÆ~ëØC¥A€K¸Ã¥/³Ê¦u§ëÀ™7ø,·T;ø¾	Û@R›,‹yİ-“äty·¼¥×Uo--ùØF”7¦3ƒ”&¯É%Ş}õÌ–Byµ`4˜’ä·Èoe~ÍêòûE>6eêÊ—±Ñ¡i\Œz>™JïíŞXYö¦tí@÷Št_–,yÕÂ,{qRub9ïŠÜïã#«2¬1… ú•N¨"ÜsŸJKp½²Qvšè’ğ M&²ÊgôÌîô¡òB÷l9RgÙõïF ËÖì]ÊËZ&OmØz¦–ô³ÁØ¿Œ‹¡ãW^¬îû}`ë5û:ş…ølåH£Ùæïéh,z½e˜n{[Xİ†¶¨ç~I–%¨kYâĞék¸Ş¸ÙFÚüüõç9º˜7è¼6ÑÙgˆšñFw›a#‘¨íËòüW?=(W|øº&ıX¬´¬äIJ”œÙ
]obìÓ7Ê”<nÒöˆÄ;ïsdX…¨˜JâwÛçNÏVsÖï·ãoçœ'Û?T^ê£V6á?ÛåñOøû¹r†ûğóü†Î¯§ÜG¥·Ç:2áİ7Lëoí-]Ø÷FVyïVywî·½6<Œ7™ö&ûB¯PÓ{eC“¼˜§#U^­ÅÊğšÄ+%!4.­Ö O!­İ…ØİëÍyÿ’•²*˜ÕÂÑüÍóŠŞ:‡„wDõ“1ÃïÔ¾Ïn|Ü—f¸g´¯yoQ÷Oƒ—ô¬ã"Ïú´Zbdñ¦Jª
~jY&Óé]Œ3<,Nwx&~å×çY‹]ÑOÅÄ×ÂÖ¢¤ÀÆÀÖöó¹I·ú·Ú»í÷•ŞJ>»Ë¦JijªÅ/[%ç´’ÍÎĞ%Nêí
¸}+î÷rDÛqİŠJXR"İ>|ïÉ£Äg\_›ÇÕêè7gŞöEMÍÜ@™†^¶üú,Íf…ä	³äÂ<.|˜x1WT–°jR.„´Úvör%¢A¾ ñªº–À–Ë"p¬Z¯UZwõÎÒBJçDä?V8Kdro¢÷	ïªBZÌ] ã»F«±q#"ıöıŞÓ;º}|—ŞäÓªÄ¶)jºeÂSıÙOEà+ç–‡×7Â[‰îõ£•À>7Î·F¤«m}¥óí©"±a»u7ÒZşBCü£¬W|pÌR«Wwd±»Ì~¿À’Ü„n‹_¿4¬V‘h¯µ$?§±Ò+İ_ŸÁ—Õ•¼°ØîìTzä4‰7a;ô;v/B¼ÅibŠ4gkqÄÁÖÖYß`¹É±÷ [8;—ü®e©OçAGt&ßkğÍÁ­«àX±Œ1>ñÚÛèYÛ†UØDŠµé¿ËifóHV¼Ò›Ü	æq–¤üôÊ˜B]Ù8?(V¢¦£–×÷–™	¢y³óA¼.‰éB^‹\ü_âšÂ¬—Î(u÷7®yPÇ—iĞÄ¬ŸÚ$U­J°Q?ó²Çßmõá–Õ=6N¾N¼ÿD-w$3º¯x‘Pù‚x =ÄĞ¿ÖîÉ°¾¬ ¼ ­	Ã‹`lk/£4üÿø?‡BXCÎl,bÔ$‘ä%s±0*ùiH:ò´f^Eª´VcDŒà£³wKÎšÖ%ö©ºÀPãy.ç¼éA‰Ü…bçJÆ„‰Åf•{ïD-Ú7@hb’hRø~Jäã~D„ÖIÍUı+ÑA(Wo¾KkUF˜!Ğˆx6[KhMãæ×r¿‡U}«–ÇcA›`ÓmòòÕ¾J>(~¸yWÀûîõ$ãoa—œd¶Œ}jå¯›ÖN?
j?‰<µHÔxêºRÕ½Ï›]ö	æ¥ğÎZ“É(ÆØŠÖ#m»µÀ H©I1Œ"_í%0}GÅışmc Â—Êr(ªş¦¹äIBŞ¶¢på{Ë›Ç+fãÓ¸	«DõmA¾ë3e—öt¸=Ïñ)
µP \hÃÒvTüæ¥ÒmI‘ÏûÅ!úŠû¦7I5òRdøè5¯Î©P(Ï Û;(
¢“ÊŠñ…8ŸiÁŞ;àJzËçÉÈpD+ÿ#Xş…eüÎjÒ‹&e¼SB©ˆ•C5
wÜ.b×á¨»
®j/Ë'B1®º€WÎNŞ´@j°SU¢‹3r¬è¾Œƒ$¥ /:x~IÁÆ<Î«À#’Æuië×üo{×¶ôà°Jşqó·¥àFóíşïyIÊXÃ£tO ’&vÊÆ¨ºìµÖË§œœÌ	éÊ;†×@_™z+>ººvˆ±GiùK¾!ë/¦£ìcV3.ªçÆ˜Á‘–œ­‘øÆœ§öç^&åVç’•‚FnRåÖCIº©”ùÉÙS®ùD¼‹×™°Û¥ÎmÛáÎ%ó@‹RyÄ´0(Ğç¦Åc2"H“ë#x¹x‰?uœÌe8ßÈC‚A‹Mœ'ÌK1À”pOQmŒ.mDÚ'®ÔŞ³9 âmÅrÌWs—ñ5,“ËCLUñÖ*ÃötgXü¾¶¤İB_|Ílı­[ÏÏM8ì‚3LQÒ„>Å¶å@3)6ÃôjpÄû‚Şîöê©JÛ–Fã/î7GÆd	Ì‹Ö—‰ â³d™áŒ4è»ns¹w#6˜¨ÒÒ$‘ÎD¹_Ù•ø€P`+Åˆ•«õ#wªP¸‡Y#öÆg¡+‚›X©ç)Øß^›¾%$ŸÃjœ‰Ğò)q]Ÿç„	c‡úK™å,$–‘Vl¦mÕ°ii].key;
			j=i-k;
			while((a[j].key>a[0].key)&&(j>=0))
			{
				a[j+k].key=a[j].key;
				j=j-k;
			}
			a[j+k]=a[0];
		}
		k=k/2;
	}
	for(i=0;i<n;i++)
		a[i].key=a[i+1].key;
	printf("Êä³öÏ£¶ûÅÅĞòµÄ½á¹û:\n");
}//shell end

////////////////////¿ìËÙÅÅĞò///////////////////////////

int hoare(struct node a[20],int l,int h)//·ÖÇø´¦Àíº¯Êı
{
	int i,j;
	struct node x;
	i=l;
	j=h;
	x.key=a[i].key;
	do
	{
		while((i<j)&&(a[j].key>=x.key))
			j--;
		if(i<j)
		{
			a[i].key=a[j].key;
			i++;
		}
		while((i<j)&&(a[i].key<=x.key))
			i++;
		if(i<j)
		{
			a[j].key=a[i].key;
			j--;
		}
	}while(i<j);
	a[i].key=x.key;
	return(i);
}//hoare end

void quick1(struct node a[20],int n)
{
	int i,l,h,tag,top;
	int s[20][2];
	l=0;h=n-1;tag=1;top=0;
	do
	{
		while(l<h)
		{
			i=hoare(a,l,h);
			top++;
			s[top][0]=i+1;
			s[top][1]=h;
			h=h-1;
		}
		if(top==0)
			tag=0;
		else
		{
			l=s[top][0];
			h=s[top][1];
			top--;
		}
	}while(tag==1);
	printf("Êä³ö·Çµİ¹é¿ìËÙÅÅĞò½á¹û:\n");
}//quick end

void quick2(struct node a[20],int l,int h)//µİ¹éµÄ¿ìËÙÅÅĞò
{
	int i;
	if(l<h)
	{
		i=hoare(a,l,h);
		quick2(a,l,i-1);
		quick2(a,i+1,h);
	}
}//quick2 end

////////////////////¿ìËÙÅÅĞò½áÊø////////////////////////

////////////////////¶ÑÅÅĞòº¯Êı//////////////////////////

void heap(struct node a[20],int i,int m)//µ÷Õû¶ÑµÄº¯Êı
{
	struct node x;
	int j;
	x.key=a[i].key;
	j=2*i;
	while(j<=m)
	{
		if(j<m)
			if(a[j].key>a[j+1].key)
				j++;
		if(a[j].key<x.key)
		{
			a[i].key=a[j].key;
			i=j;
			j=2*i;
		}
		else
			j=m+1;
	}
	a[i].key=x.key;
}//heap end

void heapsort(struct node a[20],int n)//¶ÑÅÅĞòµÄÖ÷Ìåº¯Êı
{
	int i,v;
	struct node x;
	for(i=n;i>0;i--)
		a[i].key=a[i-1].key;
	for(i=n/2;i>=1;i--)
		heap(a,i,n);
	printf("Êä³ö¶ÑÅÅĞò½á¹û:\n");
	for(v=n;v>=2;v--)
	{
		printf("%5d",a[1].key);
		x.key=a[1].key;
		a[1].key=a[v].key;
		a[v].key=x.key;
		heap(a,1,v-1);
	}
	printf("%5d",a[1].key);
	for(i=0;i<n;i++)
		a[i].key=a[i+1].key;
}//heapsort end

/////////////////¶ÑÅÅĞòº¯Êı½áÊø///////////////////

//////////////////¹é²¢º¯Êı////////////////////////

void merges(struct node a[20],struct node a2[20],int h1,int mid,int h2)
//¹é²¢ÅÅĞòµÄºËĞÄËã·¨
{
	int i,j,k;
	i=h1;j=mid+1;k=h1-1;
	while((i<=mid)&&(j<=h2))
	{
		k=k+1;
		if(a[i].key<=a[j].key)
		{
			a2[k].key=a[i].key;
			i++;
		}
		else
		{
			a2[k].key=a[j].key;
			j++;
		}
	}
	while(i<=mid)
	{
		k++;
		a2[k].key=a[i].key;
		i++;
	}
	while(j<=h2)
	{
		k++;
		a2[k].key=a[j].key;
		i++;
	}
}//merges end

void mergepass(struct node a[20],struct node a2[20],int l,int n)
//Ò»ÌË¹é²¢
{
	int j,i,h1,mid,h2;
	i=0;
	while((n-i)>=2*l)
	{
		h1=i;
		mid=h1+l-1;
		h2=i+2*l-1;
		merges(a,a2,h1,mid,h2);
		i=i+2*l;
	}
	if((n-i)<=l)
		for(j=i;j<=n;j++)
			a2[j].key=a[j].key;
	else
	{
		h1=i;
		mid=h1+l-1;
		h2=n-1;
		merges(a,a2,h1,mid,h2);
	}
}//mergepass end

void mergesort(struct node a[20],int n)
{
	int l;
	struct node a2[20];
	l=1;
	while(l<n)
	{
		mergepass(a,a2,l,n);
		l=2*l;
		mergepass(a2,a,l,n);
		l=2*l;
	}
	printf("Êä³ö¹é²¢ÅÅĞòµÄ½á¹û:\n");
}//mergesort end

///////////////¹é²¢º¯Êı½áÊø///////////////

///////////////»ùÊıÅÅĞò///////////////////

int yx(int m,int i)//·ÖÀë¹Ø¼ü×Öµ¹ÊıµÚiÎ»ÓĞĞ§Êı×ÖµÄËã·¨
{
	int x;
	switch(i)
	{
	case 1:x=m%10;break;
	case 2:x=(m%100)/10;break;
	case 3:x=(m%1000)/100;break;
	case 4:x=(m%10000)/1000;break;
	}
	return(x);
}//yx end

int radixsort(struct rnode a[20],int n)
{
	int f[11],e[11],i,j,k,l,p,d,t;
	for(i=1;i<=n;i++)
	{
		a[i].key=r[i-1].key;
		a[i].point=i+1;
	}
	a[n].point=0;
	p=1;
	printf("Êä³ö¹Ø¼ü×ÖÓĞĞ§Î»Êı d\n");
	scanf("%d",&d);
	printf("Êä³ö»ùÊıÅÅĞòµÄ½á¹û:\n");
	for(i=1;i<=d;i++)
	{
		for(j=0;j<=10;j++)
		{
			f[j]=0;
			e[j]=0;
		}
		while(p!=0)
		{
			k=yx(a[p].key,i);
			if(f[k]==0)
			{
				f[k]=p;
				e[k]=p;
			}
			else
			{
				l=e[k];
				a[l].point=p;
				e[k]=p;
			}
			p=a[p].point;
		}
		j=0;
		while(f[j]==0)
			j++;
		p=f[j];t=e[j];
		while(j<10)
		{
			j++;
			while((j<10)&&(f[j]==0))
				j++;
			if(f[j]!=0)
			{
				a[t].point=f[j];
				t=e[j];
			}
		}
		a[t].point=0;
		t=p;
		while(t!=0)
		{
			printf("%5d",a[t].key);
			t=a[t].point;
		}
		printf("\n");
	}
	return(p);
}

===========================			 
¹ş·òÂüËã·¨.txt			 
#include<stdio.h> 
#include<malloc.h> 
#include<conio.h> 
#include<stdlib.h> 
#include<string.h> 

/*ÉùÃ÷Á½ÖÖÁ´±í½á¹¹----start*/ 
struct node_a{  /*Á´±í1-----×÷ÓÃ£ºÓÃÀ´Í³¼ÆÎÄ¼şÖĞ×Ö·ûµÄ¸öÊıºÍÖÖÀà£¨Í¨¹ıcount£©*/ 
 char data; 
 int count; 
 struct node_a *next; 
 }; 
typedef struct node_a node,*list; 
list head=NULL; 

struct nodeb{  /*Á´±í2-----×÷ÓÃ£ºÓÃÀ´½¨Á¢ÓÃÏàÓ¦µÄ±àÂë´úÌæ×Ö·ûµÄĞÂÎÄ¼ş*/ 
 char data; 
 struct nodeb *next; 
}; 
typedef struct nodeb node_b,*list_b;  /*jiang bianma xieru wenjian*/ 
list_b head_b=NULL; 
/*ÉùÃ÷Á½ÖÖÁ´±í½á¹¹----end*/ 

/*¹ş·òÂüËã·¨ÖÖÏà¹ØµÄ3ÖÖ½á¹¹µÄÉùÃ÷-----start*/ 
struct forest{   
 float weight; 
 int root; 
 }; 
struct alphabet{ 
 char symbol; 
 float probability; 
 int leaf; 
 char *bianma;       
 }; 
struct tree{ 
 int lchild; 
 int rchild; 
 int parent; 
 }; 
typedef struct tree *tree_ptr,tree_node; 
typedef struct forest *forest_ptr,forest_node; 
typedef struct alphabet *alphabet_ptr,alphabet_node; 
tree_ptr tree1; 
forest_ptr forest1; 
alphabet_ptr alphabet1; 
int lasttree,lastnode; 
int least,second; 
/*¹ş·òÂüËã·¨ÖÖÏà¹ØµÄ3ÖÖ½á¹¹µÄÉùÃ÷-----end*/ 

/**************stack difination start****************/ 
struct stacknode{ 
  char *bian_ma; 
  struct stacknode *next; 
  }; 
typedef struct stacknode stack_node; 
typedef stack_node *link; 
link top=NULL; 

void push(char *item){ 
 link p; 
 if(top!=NULL){ 
   p=(link)malloc(sizeof(stack_node)); 
   if(p==NULL){ 
    printf("Memory allocation error!"); 
    return; 
    } 
   p->bian_ma=item; 
   p->next=top; 
   top=p; 
  } 
  else{ 
    top=(link)malloc(sizeof(stack_node)); 
    if(!top){ 
     printf("Memory allocation error!"); 
     return; 
     } 
    top->bian_ma=item; 
    top->next=NULL; 
  } 
 } 

void pop(void){ 
  link p; 
  p=top; 
  top=top->next; 
  free(p); 
 } 

void makenull(void){ 
  while(top!=NULL) 
   pop(); 
} 

int empty(){ 
  if(top==NULL) 
  return 1; 
  else 
  return 0; 
  } 

char* tops(void){ 
   return (top->bian_ma); 
} 

void display_stack(link s){ /*ÏÔÊ¾Õ»ÖØµÄÄÚÈİ*/ 
 link ptr; 
 ptr=s; 
 while(ptr!=NULL){ 
  printf("%s",ptr->bian_ma); 
  ptr=ptr->next; 
  } 
 } 

  /***************************stack__difination is end************************/ 
void display(list h){ /*ÏÔÊ¾Á´±í1*/ 
list ptr; 
int i=1; 
ptr=h->next; 
while(ptr!=NULL){ 
 printf("%d,%c,%d\n",i,ptr->data,ptr->count); 
 i++; 
 ptr=ptr->next; 
 } 
} 
void display_b(list_b h){  /*ÏÔÊ¾Á´±í2*/ 
list_b ptr; 
int i=1; 
ptr=h->next; 
while(ptr!=NULL){ 
 printf("%d,%c\n",i,ptr->data); 
 i++; 
 ptr=ptr->next; 
 } 
} 

void insert(char item){  /*ÓÃÓÚ²åÈëÔªËØÒÔ½¨Á¢Á´±í1*/ 
 list temp,ptr; 
 int flag; 
 ptr=head->next; 
 if(ptr==NULL){ 
head->next=(list)malloc(sizeof(node)); 
   head->next->data=item; 
   head->next->count=1; 
   head->next->next=NULL; 
   } 
 else{ 
    while(ptr!=NULL){ 
     if(ptr->data==item){ 
     ptr->count=ptr->count+1; 
     flag=1; 
     } 
    ptr=ptr->next; 
        } 
   ptr=head; 
   if(flag==1) 
     return; 
   else{ 
     temp=ptr->next; 
     ptr->next=(list)malloc(sizeof(node)); 
     ptr->next->data=item; 
     ptr->next->count=1; 
     ptr->next->next=temp; 
   } 
 } 
} 

void insert_b(char item){  /*²åÈëÔªËØÒÔ½¨Á¢Á´±í2*/ 
  list_b ptr_b, temp_b; 
  ptr_b=head_b; 
  if(ptr_b->next==NULL){ 
    head_b->next=(list_b)malloc(sizeof(node_b)); 
    head_b->next->data=item; 
    head_b->next->next=NULL; 
    } 
  else{ 
    while(ptr_b->next!=NULL){ 
  ptr_b=ptr_b->next; 
  } 
    ptr_b->next=(list_b)malloc(sizeof(node_b)); 
    ptr_b->next->data=item; 
    ptr_b->next->next=NULL; 
    } 
} 

void search(¤ê—x¹¨8XÁá½G•[ñ$üå‹EüS½O8M«Qá¯ì£‚ò„ã€mˆµâ‘åÅˆŒhê<B~!ÚoÄ?Àœ@¤w¨0¦lm…ä`#zpBI°ƒÇÁ¤J4±Ä±@ˆ@HõCl2¾ØW‘€¯˜Í+‚•Mj1"ù£(,RLkÄëÇ¾•E‘rKÁ¸°¦¼Bğ¡‡q2¸c ^)Z¡±§ˆV!Bñ¬aÓŒà˜f4ëÆ°ê¹ª"XXTÙxH–J ‡2~r¥2ÿºõ –p×ü}0¾¯~}v‘‘²cªB±´WèjÔÔXÎ ¼MX3hÄ×Zš±^NT §¬
Œ	ßÀ)¯­€’ XıpÁˆPÀEˆ1J„,,ëÆ dEb@<g`!©xX°¶ĞfÆŸòd ê3°É‡ºâW ¼,XLd!ìFœ_òÉ‡Ôoh6i“£Ê¢íÆQn#úä×ì¬™‹iÆB x&(A
FÂ›
Y_d
;Eçr3ğRĞJÿaãN0}ÀÈûq«?ÜbFOlXt]ÅŒR~ìkxuéğ})ãèĞl¾ƒŸ•áş“L6p xFxcÇÉ¯å3y¯†x«ªäF0Å¸‘á>-Åƒ*q^(§#M0ƒË‹,ŒyH†éaZÌxšx-FnC -µ§FÃˆÅœ—‚	
ã²aîPáJrÂô…ü(yaxâô_ĞJäKî§yOA²— ÿq6K&}PvqÉïaù³	ÌÄH„;ÖlõH¿ï16z Ôy³G!š
‘õA*<nÀ‰ *Ï(b¢šÄHa2ó£X° Q1€X/62…âhq¯ˆ•làÃ“/Éµâ(8Ñ ˜m(Á
 °‹ùü™ºÚCÄ^|?öÿ íãëü}ÚŞW™5Z¨¿@lÂ@:ôFqŸNX<jr¤}NÂ
jKï?Ä/VB:j[Õ¢BI£­À3i©¬şÌkJƒ)1I8–¶Õ2­%Ôocëš	ØÑµÌâ|´*¯ˆn_qÏÓÎáãá‡—!ı<pE¸GÇ„Ã£1 Ùéò°ºq<@¥>7;‘ãèå.·ì‰Fè‹IôëÔŒÊòpks£ÃµQ61áJ}BÔf¬
µ Yë®0$	dP’Í \`ÈbÇŒ¡ƒ„"#D'õÆ(CˆÈ!FøÃË’É0*WÎo Û€EÁ‡82˜á«àƒ"<oB…ëí¥kd†áÂAe[UZE~XÛÏ?‘	7!?£”1Ñk,LEe‘…‘ ˆ%@¨
Â£ÒÜuÀOì…“ıJG‚‰P–Ì×–â¼Q©DA|8áE–&º#Ü5.&bL¤Êk¹ÜœFClvZ—õY¸Vò++IgØåì|¾~?²*¯óÄ›üàlåeôùTO…ÊåÑÉC(»¾ø¤Şº|â“j       ÁåñI­tùÅ&”           ıçOœRgAûßû|RaWß•Ò>)(­/§–AIGåÆúyfex¨ô÷/Ÿ,‡É0Àˆ‘HŒrb4ş£<­bAdia;…ö#aM[<³¸ƒĞ®^ŸÄoKŒP|crõ°Øú¥ÂXÏzRÃ`ü{xT¯¹ìˆpŒF3ÊÇşóØ`w¬0S`ğí€…£Ô†H„$ë³Û[5íåÈ/¹·kÜDTànH³£f‹Ö¹ˆğÓw,÷ËbAdz.'Œg¸pıÈ|"År1jEBÔf£*}wÖ„‚–w{ ÆL/ÛaÃAwÅh^1ÂjBÚÇ¶í°¼¨bêZÁ_¬ÉtHa…î…(kPucP6”´m‚şÈc$Ü3yÀÅ`Bõh€ôWv(&õØ’âÔ½5†ˆF QxeúPÅJÔzøé×Ö°ìq§0FRbÙI_à0’@#Î¨ÇŒ‚kP6Ç­Õ´¡Š}PvÔ¼_¯ ån§1`‚F†0A¨MS'×8Ğ€Å„j5:¢÷€¾1Âx Çp…Ûh“Æ†*tiNz¦OëzĞ`M«ğº°wg+l{é²h1<”jÄÍ˜€ÂV„hŠéÃ`Ak^±íòÅÆDâ>Øå<
PV‚Ôâ¨%b›XÉ²õŞC¿MzÆN
–€§T{Æ5‘bC^zúÔkDKAƒb€ÀŸü†:†2G68è0íT¥¿²¾%õjqOS­7`×j8CºHbMºÖM<$0z@!¨1„9±äëY:MQa­P^(1@ÚvÈI'åÉEöšƒ…)\à»Ü³(Ä›;×cŞ£+=~ tRPÖ†µ¡İvµ–hão†Ş¨w…õAÜ]ğ‚6<!’“¨Œ@{ã²¾
T†¢½T§¾i‹Œ@%@qÅTÑb°Ud•/Ş²m~-a¦Òë-wâÁ@jÖ:FcÆfx=fF˜{á- ˜ÀãÜº â¨/„kj	šÃŠp¼qqèE‹@‚Ô:rÆ,5©ª1¡¨ğºlPp‘I t\EŠ¥ïJõÂÑÅ8_p\BêƒŒ _	‹av°ã‚2!x°â¨/J×¥CŠp½qq§Æ@»Àq‹©1¡}€q‘È‡AzPâW°LØ…ÛC‹ˆ^8Â‰›H±‹-jK}ÀqG 0Ò‹î›ÛC‰^ÈZ8§êC‹ˆ^@8ÂæŒX\¯ 8F†ˆüÚ…ŒˆAjILüU/x°âW´)Âò¡ÅÄ/daDvSø!Â,@µ©^êã"½âƒŠ ¼hq+^’)Âë‹ˆ_
Ú!î!Æ,4dïbÆ4 µX-muè&û¾euæÍg6€\¨qXsFÈNW„{aŞÛA£Ø±k@&8¨Å‡!xğã•2¬	z2¡ÔÚ–¦àà°·PSljã-a	–ß°^ÑáÅAo*T…ìƒŒ€];}ğì‰ŞŠoq–`T‹°‚Óo¸º{hûá†5£0bÃZ°kÅX ‰œ„€kğÿÜ7SÅEğÆ°5eî »àZotO|	kÊ‡{ â¤.ŸÃw€ã ReBû â°!zMïú„c)?¡àz÷Š¥à½_¯A"NA!Şxâ.¤$˜cï ĞGÏ sOpÔ`*;±;ƒ@‰6Ä;ş…Œgh
k8AaE@^`1R*ŠØš{‹;¯bË2V­(ĞÔz›n<0‘Ã4*êC½ğ¶Ğ1N•\BëC@„Çå{è</n!„YÂµawPÆ5iK@DˆBeğKe|U #‘JÙÃdl+ìöL¥AFĞ`kÙ · ÁAÅ>>É‘ÅÁ )J8pÆ1 `c scğ9Âß…ä
„ôkâWÀ-ÿ€ÒÓàaÃµõá"¿Nà‹¥1A„#Ù….¼£±ÄƒÍ¦[àÊ ù*dÈSüW’ıùŸe±„cH}.fímu¹‡r©'y,®˜uGöK0šÄk}°DŞaÏ¶tèjü4ÖÓhÕ™9nNÇ¼@ò_İÇàjZ
úµáöbş¢’ÑÒû.'1‡ğÁªüQã=ñÑ–wøámÜgQo•Ğ;NêÎò”¤hÅ´Áìä º‡PïRÆ†ñá¯°=Cà¨/¸,eCy€Õ nøî‡`²qå‹PNÁ_m„øQ•ë^Cá$;ÔŠ·º…Ä‹³C@”:Ü€¢'kbÂïáŒhAkèøM‘Ÿİğ…¢š¡©¿„¶Ú4,.Ì)¾&G<¸aá|AÛX¨„mBŒ ü1‹@"(1ìC¼ˆb¨ãÕ1Øë~$=´|bw€Á¬b¯	xA.b¬ˆC$ä ‘‘•yÏˆêˆìœĞ$´ÜÀ×¹ñ í *AâL1•@!`b°/Ø¼†	£N8×cÉô6´CO1Ìœ(†€¨Há6Á ",/ø†1¡uAŒˆ_â‡¹av¥ş%êUpTwËsmŸ';U‘—ŠŒJ¡¯Ç`6/E¬£è¬°&Ğ°$†Ç+•jø„–XH®˜$ˆü­]BGtá7 ÂÛZ©¶
‡ß‚<CøŒ#ğm|öïéuç:jß9şèyx]€ğîÀà `†ig,²h ~@È¨4 R (_(t(h5}E½–dŒıË‘ÕqØ«Yğà
‹êNB÷u;RÉÁ½a´ßKAJ5kKnHFĞu9 ®Ì#P ğy ÕJ#<°Àæ 	À˜ ,©á Şƒíh5Àô£“Ñ®ônFØ³â¸`ãœèÀ9cXƒF3Î¤Gº˜©Â‹I-,÷ËÑèl(Ä64“trÁË’rüb
Å[±HëqTã.E%n"}ğë¶jœ`ÑG Õ0"­Ä”NŠÅ„%g×…äQHØ`5¶(l\@’·ÑÊ#ÍGÖâäQL«q„”R$6`c
J†Ñø¦6ˆ6
D†ÑƒÛköbE¡½3ëÃHcÄù°…Â}Íçƒ¤(l«)Õb£NG!·\‡óıŸ‰^+x^”f³^R¹ÉhslşóÙZMİ!GÒÃúB²zf™Æ$Ì*ñ[£0¯3Ä|R$6>ŠC[…È%Cd®¤} €ñe#­Ï`+xÎhÄ7BF†nì¬îg8HÆY¯=æ†·6’’Vç$R*ÜãF«2»q|QHks‘…§xlæ@”À‰(¤¶‡ÊJB†Ñ[ÉImñ†*÷hƒh‘	46Ñ!´´òcVjÛù•¸Í†–"ßsF<øÊğS²±gõ•e ¢‘Z V1†6ˆ>Øœ‰¶(m„”ÆÑ"™Z òÅ’u¡ÿÑÖˆr9ÆfëD&ôÍk@Å×£"W™6ã¹äËDdMŠ27LmÈ€)¢&xÂ9”¹Ä£Cjè¤ˆmm”Š·3Ù@bÿd>¿õ99—şkzüÇò^$ÃM!‚)Ö<w%ö	F¿…·±*‘‰Á@–İ„9iGÚ%¶@G& ¦wî~÷§ßÈì ?iÑtÇò…*¦j\Ñ¡ÈÑhs!´Yù´Z6ÑâµVÓ´Zeš‡/6jÂº>·€¶V‹2Ñ¡Ëñ{C–å’Õ‘M‘„lÔ9ÖC•ìô92QÚ-øÌİÿ¢"Æ13.@3míß½Óv„hs„#¸ümÇé¦jªQÜ€6•x“Ğè[½ôŒÊÎ¤€ï|V|Ñ¡ËíÚĞÓ+å’hé•LúeGL«£i•1{¦UY)”±{¯(ÂÿÖğ"z<5¼"C…S–œYA&¡ÄÈİÓu)wNpƒqMln6şYW5ÜŞ’‡®( ´LXë†ÃŠB°eyE[0&Ïé†–Ñ˜ìú¨DK8Âİ8¡åàsš!Ç¼³({ƒzHc©˜ ô8µP`2ú3·L~iĞ+‡<ì.…£ºp‹£~LLúò²ºKh¥ßğÀ•—$ŸÈ”k?¼ÿáÚ*Yñ:Œ~]Û÷vŠi¹^hòV¸d·qÄqûâ{.öóÎº_h¦ãƒÇæ®£¡Ít‘óc¯¸é-¢¯ñí#m!V}O—Ò8nàğL‚F…3ŠÎc©ÇçsC¸ß~òÑUéæ'ÿ"ÑeÑ¼XĞ_#û÷êêWëA˜=pÏ±ÚXĞ»’B?½.Ï´& §®‘,œœÒ/šWiƒÇ“ŠAóÒlßn£.à‡	2=æfºE	¢©Ù’ô3®D—p÷Ã4cuÑÄğ¼!Yò5ôYh^½†„µ}N‹‹0Ç£‹¯›ªÇètP¿¿´^Ç¹2|Œ/Hí-:’Ñ‚ôZé}£
¾Ï¥e¡×öédªL,ÿ.–IÈù“oì1¡û÷Ñ<<¼YëúXušğğxÿ#9ûâ‡7cÙ‡Ó¥pìŞMG« éYÜëú¬yˆ'ºKç'VµúTøç’méE£+–Á¾ÎK¤e†´vŒÂz¡äÒëœ…&"°'©2·ıÏVz³¶íñ6;G3À]Ä4r±× k!ã­›C^‚Ú[‘ö™W ä†½K/“m×¾Oy¨¢W¡]Ş¾M¹_YDA˜0ÇÁ‚ÌCâ¦ÉB‡ÆÊ’C~æ.Á!îŸ9ô.wÊ¢şlíÇ8‡şÂ[Pğmİ°Kd#ô 
F€p/è4ó˜cë|¥tùM”×Oİ€  ?Œs…ƒ…kääáaƒÏ—•…½Ó
WO”ÉfŞôıÃûÖH[ıD"ıòôÑıòÛéúC=?DÎS9Ru9ï?D;‡AîvI¯û3Ë×{Üq<SÓvw/™}Íyt;±xû^¯¿‘ÁÁøîG'çû_¾‘’_0¹ÅŒñ:./„üö^w0Nµ0ÕÈÄšğÌŞ4İ:4÷?G‚HĞxŸ¼3€\v;Ì<6¸®ê(Ñ0ÚG;¤¾æ"O+ÌfGä#Ì·ŒØ\ç¼ƒ­	+ˆ4¡ÕåùCÓ”N„ğÖI…åƒŞ`j7ÈÅe»1äyoÎìæàY›Æ³3İÂDù.[Pú¶£#Óöl@ô}Y’fÜïqÄ´@=“Øüòõº'Aå§&ÎòÈV ‘CĞXè¹fşû ìŞnceüt¬œXWÃ$?]ƒåiı1¾şä„Ä*ß‚şRy·ØüjÌF~ñ¼AîgöÄ$Aöp;>WìÇË©&}C±»84{ÎnO—Öù¨ã\ÅÔç¯t"ŒökHÒôY4ŠşÉ€ëÔá5Î.”w–r?*¼<Óû’4.£$=œîb#ŸŸ÷¦m÷’o/y\¤j¿Î™0ëºÄbÉåËIÿû  Æ` BıØs	  ˆV"ü°33<ß~‰Ï©25“Ç ]bÄ(gÆ*I(# 1
fyÑ 1²xÑøÓ™ĞİW+BÅ/Ÿ!.‡sIrNÅw„æ!VD
T7z}ƒ+‹æM<wZCB&’:øıåä×]Ö4Š’05b/C¯~ÛÏf"4D±Á]&ÃBJÃ´¯ÛcÇOÚ<‡÷¨ë‰u#®&İhrƒšs”ñ|^øu«{£ğ¹ì–èî+?ÎÏJ:2/·LÂ’‰òxh&S@Rw¼ÿ|wõ-#§è»ïQØåZMßıÍL¿ø–è%ûNŠ_iÒ!Í’uqU¤ÌÚSdXt“G ]’b˜Û‘ø¾)ÅúLã2 CL
s*JFñ'­›ŒıY´^œ­Ú)áNû«¹
rÉ@g¡Lóóâø"×¢ù'FOèÄD®7z™rpøˆC«©õò1{âÃù½ñfTÃhG«=†4Î2âÌŠ2šcF)}v~€zË™ÑÈ£Õ¼½À¹=qÇ§Ç×Weï1[&¯eÑáÉíİÛ/ryzbÚ	ÑêùæğÂèÎ,DƒB@ë—% YÂAHD>dXî…;¹d²£îñ®Ï |c¨îI¼åû7Ïƒ7‹%ï5¤7Õ†"ÛäD0{ºDgçI§Èj|o¦È(¤Œ,–Ó¢âÀˆŸj3£¶Ä+IˆÏ’3}D“¡ş¨#oá×É~rI3£"÷h‡Ï&zvæj+dğèÏ†€†&Ñ<„g@Æ.S¢âÏrQ:QŠ¹Ñ¡9{¬^ÌNÓrt‘áŒ½ÇµÚúÚîÚæÚ;‘z‰¡É˜_!¦¯.ø÷Ùä'q‚OOF†)Ì°ŒgÁ7u|-$.‡èLİ‹:É[ôI6/cŞ:t4E4Ï[zy{vr}'’i#ï	rQ)©şábâ‘•æÎÈg
Å”S8>01l›ÖsCˆk”Ïf±^ÅÔîWùW€çIˆQŸˆòñ©-coĞ’Ğ)3áIîôw¤¦??œ÷Œ%*FôbaóGe3Ú9­JŞzÊÈãAÜ¢#“³|;À<º“¤ê–Œƒ»>“D¬ßEÜ(yÆS—¥ê4Bk<=šıœÌ/Z8qÊ±s„Ç
fA#5@ŞåçÙÔ8MG:Áªá±x‹é5Š
rl}lwlsló¥íÉŸ™ëCzÌäz$_ÌÕ»g´YÓ›Ö@Ò|7¹Hµ"C6L7~ÚPÌİ.Ùx=gô‡%7$wÈnÎÍ%Z2W&Ú6†Srºi<ÇÖŠy9	TÈÈÓ³tŸ‘E/G)Ö“úŸ½N}Ùì’lO—"ê1åz
:ÀM<Å¶w£Ú´ö7¬uñÊxâsx³’G_¶œg}†I¸0…lÂY 9¢Ïg	²:øq:}v{uv}z´Î]ĞrHÉ>\lJq¬F]íñíÚö$ë“‡7¡€0xfI4ê~}trzPğåz5„£æ£˜#$Í™I¼XeƒØs3<ÙÎv–+Ô«ì×{¿.ùĞÜf¿·Æ‘¡ø¼ÌOQp8´	KüÙ„²H0üükâ|PaŞçä¯ZLn8>”å„êLŞpC¸ƒ•ß#4R¶G²e£I9[IlËA	ö„õÎè“˜¿;>¾qyçœ¿¼£)zêp5¯/NĞ.ÏOcâÉş”x§Ç÷|ä n[ñ,C½ŞEq®œúz³§>Lù»–ÍgF=í…×fpñˆw8†CŸ½>?? äêJnwÇ+`8ç6`ĞÆ"‡¼È{¬C~f¹ÃôÜW^.uÿu¬ƒîë1|s±?ÜœŒ#—îEñ‡/pcuŒ“ËøÜËñW¥·ÅÓ‘>oÒÙíòä^ÜİÇhy°ÁÇ1›¼‰ëg<áÁEqº¶Á"”Ÿ2[çÙ©İùsÎè3.³—Îx
Fìş`å¦!¤ôLåÉõİ‹LØ9#° sû$İbœ·ã>¾2,	%û$²k>`ùèœXZY«ïŠ.ÚÉ1†Eø–ìêlaêEÂÍPÛLÓ…ÓJğ™¬o×8öèÃkÛÍ¾auwŒÕßÜRC³\ô÷¼1Š‡HĞÉ¨—oİÖƒ–Ïv‹ÆÕ°©şö¶<ëƒÎSµÆtv@Pzëó#Ó S±2ÍPRE²Jû9öQ24Yff
õi
om3"«.IŸ†àÜ“æIÛ%wd9}úoó’8p]î\Ø«doWö~ñœ”1]H¶GŠKe¶\è‡Âğh°"2‹îäê;»?“]òÅy*ù4 }|ƒÒæaÊÜ~m–!Î×Öd†ş†ûÄìş†/›Ó`Ù3£^H¾îvôç"¸¬ÉoŸ@öôİ¥_avavhH­éåİáüÇ¹xy~=ëkîğäÉer£ËÙv»)Øö)…Bl¾ìtZ1.ìt‡½ÈÜF¿—>DÚöaW‚h‡'qè™wC¦@âÆí²Ñ—0³Å!åâ ÀÆgûç‡¦|ók´|‹»¿İÍ¤ğcú¸ÏàĞãrìHn­Ú	CËé§$uÕñÙúóAìËÇqkŠ=}‚f5ñ²&ïaÍ
q¡Ó*ˆùÔğè4É?¡‚H™£|Ä$
@¬ı!‡“	iFIÉA ²‚Óñ-åGAäç!ŒMš·’P=?/,,bwÆ‡‚òHá“4æÌ>NVäüıv{ÓĞí*{w)Œh0>ëoNOy˜QugwÒtil^Ş ²,ĞçÍä|ÖËÙ"u3iE3dª‡ƒøºe%ù–ÑIÎœÜDåùOÃ·gTaÜà ÒŠ:ƒÚ¡3T¾h/ŞÛcÌ`qèòı’6xìàèx¶eÏ;A]¦şüÈA‘/‘˜ÌâÙ’7Jéo#ÕŒ9óÇ˜¡àì~iHÄ9×G§•1vşA—£)nÇ8ú¢íb7¶@Ü)½fŠæÎq5ì®èn¨X®Ê€z>k|_N£ÏâDŒ$y‚çã›©ù 7FYduã&ÚHØ¼!ı©Œúğà>É#¡ñùåˆàìÁ›(f­‘Å?@9Ğ«´1@çCQ³oeÓ»ì™¹D85}“ZgÈÌø}1œ<9®ååøeùíİë$CD…ù”™u€$„‰¨´ÈÍå‹èİ]]ùıŸW*¡ù\]Œf¥åĞ‘ßY3¢{C'µ¢Núñ‡G`0íÕ’ùÚBÑ0?¶¹¼¿˜ó´ ÛĞå0½3²H†D>’Eòñ	Íôo&¥å4v‚[|ùğ½¯öwuyc–L×hHDah'B_W©>v3_4H‡Y-›„-Á”Pn=bˆÌ¾çOÏèDŸ*Ë¶AıØçîÏO®£İol1f©Ò<c4l‹ñÄOÅ%ÍQu(50L5;Añ*ÛãŸˆFB hØ©œ#HÜ¯gGÌ’¾Xäät´˜­›¡ìı'Æ9àvÎ#vr³¦©z&s£vÖ9¢„I#ŒÌİ1Ñ*ÛCb	ŞÈçÏÌ£¥ §cs”|½–;Í½²= ÓA ‘ğâ?4İÙì—ncLÄ6JZÍ¡‘÷w÷xVd{EÆzBO!+0¤—,6?Öˆ›¯9±÷ÀËXñ÷wH'IéQMëÁhZ8=Òeight1<=40;weight1++)
		for(weight2=weight1+1;weight2<=40-weight1;weight2++)
			for(weight3=weight2+1;weight3<=40-weight1-weight2;weight3++)
				if((weight4=40-weight1-weight2-weight3)>=weight3)
				{
					for(flag=1,x=1;x<41&&flag;x++)
						/*ÖØÎïÔÚÌìÆ½×óÃæ£¬dµÄ¸÷ÖÖ×´Ì¬-1£ºíÀÂëÔÚÌìÆ½×óÃæ£¬1£ºíÀÂëÔÚÓÒÃæ£¬0£º²»ÓÃ¸ÃíÀÂë*/
						for(flag=0,d1=1;d1>-2;d1--)
							for(d2=1;d2>-2&&!flag;d2--)
								for(d3=1;d3>-2&&!flag;d3--)
									for(d4=1;d4>-2&&!flag;d4--)
										if(x==weight1*d1+weight2*d2+weight3*d3+weight4*d4)
											flag=1;
					if(flag)printf("%d %d %d %d\n",weight1,weight2,weight3,weight4);
				}
}===========================			 
ËÄËş1.txt			 
#include <stdio.h>

//--------------------------------------------------------
// ´òÓ¡°áÔË¶¯×÷
//--------------------------------------------------------
int MoveIt(int x,int Source,int Target)
{
    printf("Move %d From %d to %d\n",x,Source,Target);
    return 0;
}

//--------------------------------------------------------
// ÓÃ 4 ¸ùÖù×ÓÒÆ¶¯ÅÌ×Ó
// n ÊÇÅÌ×Ó¸öÊı£¬±àºÅ´Ó1 µ½ n
// First ÊÇÔ´Öù×ÓºÅ
// Second Third ÊÇÁ½¸ù¹ı¶ÉÖù
// Fourth ÊÇÄ¿±êÖù
//--------------------------------------------------------
int MoveHanoi(int n,int First,int Second,int Third,int Fourth)
{
    if (n<1) return 0;                  // Èç¹ûÃ»ÓĞÅÌ×Ó¾Í·µ»Ø
    if (n==1)                            // Èç¹ûÖ»ÓĞÒ»¸öÅÌ×Ó
    {
        MoveIt(n,First,Fourth);          // ¾ÍÖ±½Ó´ÓÔ´Öù×ÓÒÆµ½Ä¿±êÖù×ÓÉÏ
        return 0;
    }
    if (n==2)                            // Èç¹ûÓĞÁ½¸öÅÌ×Ó
    {
        MoveIt(n-1,First,Second);        // °ÑÉÏÃæµÄÄÇÆ¬ÒÆµ½Ò»¸ö¹ı¶ÉÖùÉÏ
        MoveIt(n,First,Fourth);          // °ÑÏÂÃæµÄÄÇÆ¬ÒÆµ½Ä¿±êÖùÉÏ
        MoveIt(n-1,Second,Fourth);      // ÔÙ°ÑµÚ 1 Æ¬´Ó¹ı¶ÉÖùÒÆµ½Ä¿±êÖùÉÏ
return 0;
    }
    if (n==3)                            // Èç¹ûÓĞ 3 Æ¬ÅÌ×Ó
    {
        MoveIt(n-2,First,Second);        // °Ñ×îĞ¡µÄÅÌ×ÓÒÆµ½Ò»¸ö¹ı¶ÉÖùÉÏ
        MoveIt(n-1,First,Third);        // °ÑÖĞ¼äÅÌ×ÓÒÆµ½ÁíÒ»¹ı¶ÉÖùÉÏ
        MoveIt(n,First,Fourth);          // °Ñ×î´óµÄÅÌ×ÓÒÆµ½Ä¿±êÖùÉÏ
        MoveIt(n-1,Third,Fourth);        // °ÑÖĞ¼äÅÌ×ÓÒÆµ½Ä¿±êÖùÉÏ
        MoveIt(n-2,Second,Fourth);      // °Ñ×îĞ¡µÄÅÌ×ÓÒÆµ½Ä¿±êÖùÉÏ
        return 0;
    }
                                        // µİ¹éµØ°ÑÉÏÃæ n-2 ÅÌ×ÓÒÆµ½Ò»¸ö¹ı¶ÉÖùÉÏ
                                        // ÁôÏÂ×î´óµÄÁ½¸öÅÌ×Ó
    MoveHanoi(n-2,First,Third,Fourth,Second);
    MoveIt(n-1,First,Third);            // °Ñµ¹ÊıµÚ 2 ¸öÅÌ×ÓÒÆµ½ÁíÒ»¸ö¹ı¶ÉÖùÉÏ
    MoveIt(n,First,Fourth);              // °Ñ×îµ×ÏÂµÄÅÌ×ÓÒÆµ½Ä¿±êÖùÉÏ
    MoveIt(n-1,Third,Fourth);            // °Ñµ¹ÊıµÚ 2 ¸öÅÌ×ÓÒÆµ½Ä¿±êÖùÉÏ
                                        // µİ¹éµØ°Ñ n-2 ¸öÅÌ×Ó´Ó¹ı¶ÉÖùÉÏÒÆµ½Ä¿±êÖùÉÏ
    MoveHanoi(n-2,Second,First,Third,Fourth);
    return 0;
}

int main()
{
    MoveHanoi(4,1,2,3,4);
    return 0;
}
===========================			 
ËÄËş2.txt			 
#include <stdio.h>
#include <math.h>
#define MAX_N 1000

int main()
{
double f[MAX_N];
int n,i,j;
double maxvalue,curvalue;
printf("Please input count:");
scanf("%d",&n);
if(n>=MAX_N){
printf("Out of range\n");
return -1;
}
f[1]=1.0,f[2]=3.0;
for(j=3;j<=n;j++){
maxvalue=pow(2,j);
for(i=1;i<j;i++){
curvalue=2*f[i]+pow(2,j-i)-1;
if(curvalue<maxvalue)
maxvalue=curvalue;
else
break;
}
f[j]=maxvalue;
}
for(i=1;i<=n;i++)
printf("m[%d]=%f\n",i,f[i]);
return 0;
} ===========================			 
»ØÎÄ.txt			 
/*»ØÎÄ£º»ØÎÄ¾ÍÊÇÕı¶Á·´¶Á¶¼Ò»ÑùµÄ×Ö·û´®£¬
ÀıÈç£º"radar","able was i ere i saw elba"ºÍ"a man a plan a canal panama"(Èç¹ûºöÂÔ¿Õ¸ñ£©¡£
Çë±àĞ´µİ¹éº¯ÊıtestPalindrome,ÔÚÊı×éÖĞµÄ×Ö·û´®Îª»ØÎÄÊ±·µ»Øtrue£¬·ñÔò·µ»Øfalse¡£
º¯ÊıºöÂÔ×Ö·û´®ÖĞµÄ¿Õ¸ñºÍ±êµã·ûºÅ¡£ */

#include <stdio.h>
/*	  ×Ö·û´®   Ò»°ëÊı  ×Ü¸öÊı*/
int charf(char d[],int k,  int i)
{
  if(d[k]==d[i-k]&&k==0)
    return(1);
  else if(d[k]==d[i-k])
    charf(d,k-1,i);    /*µİ¹éµ÷ÓÃ*/
  else
    return(0);
}

main()
{
  int i=0,n=0;
  char a,b[20];
  while ((a=getchar())!='\n')
    {
      b[i]=a;
      i++;
    }
  if(i%2==0)
    n=charf(b,(i/2),i-1);
  else
    n=charf(b,(i/2-1),i-1);
  if(n==0) 
    printf("²»ÊÇ»ØÎÄ"); 
  else
    printf("ÊÇ»ØÎÄ");
  getch();
}===========================			 
Í¼.txt			 
# define true 1
# define false 0
# define ok 1
# define error 0
# define overflow -2
# define null 0
typedef int status;

# include <stdio.h>
# include <stdlib.h>
# include <conio.h>
# define maxlen 10
# define large 999

typedef struct
{
 int a[maxlen],b[maxlen],h[maxlen];/*µÚK±ßµÄÆğµã,ÖÕµã,È¨Öµ*/
 char vexs[maxlen];/*¶¥µãĞÅÏ¢¼¯ºÏ*/
 int vexnum,arcnum;/*¶¥µãÊıºÍ±ßÊı*/
 int kind;/*Í¼µÄÀàĞÍ*/
 int arcs[maxlen][maxlen];/*ÁÚ½Ó¾ØÕó*/
}graph;

typedef struct node/*±í½áµã½á¹¹*/
{
 int adjvex;/*´æ·ÅÓëÍ·½áµãÏàÁÚ½ÓµÄ¶¥µãÔÚÊı×éÖĞµÄĞòºÅ*/
 int info;/*È¨Öµ*/
 struct node *next;/*Ö¸ÏòÓëÍ·½áµãÏàÁÚ½ÓÏÂÒ»¸ö¶¥µãµÄ±í½áµã*/
}edgenode;

typedef struct/*Í·½áµã½á¹¹*/
{
 int id;/*¶¥µãÈë¶È*/
 char data;/*¶¥µãĞÅÏ¢*/
 edgenode *link;/*Ö¸ÏòÍ·½áµã¶ÔÓ¦µÄµ¥Á´±íÖĞµÄ±í½áµã*/
}vexnode;

typedef struct/*ÁÚ½Ó±í½á¹¹*/
{
 vexnode adjs[maxlen];/*ÁÚ½Ó±íµÄÍ·½áµã¼¯ºÏ*/
 int vexnum,arcnum;/*¶¥µãÊı,±ßÊı*/
 int kind;
}adjlist;

typedef struct qnode/*¶ÓÁĞ´æ´¢½á¹¹*/
{int data;
 struct qnode *next;
}linkqlist;

typedef struct
{linkqlist *front;/*¶ÓÍ·Ö¸Õë*/
 linkqlist *rear;/*¶ÓÎ²Ö¸Õë*/
} linkqueue;



typedef struct/*Õ»½á¹¹*/
{int stack[maxlen];
 int top;
}stackstru;

int cnull=-1;
graph g;
adjlist adjl;
stackstru *t;/*ÍØÆËĞòÁĞ¶¥µãÕ»*/
stackstru *s;/*ÁãÈë¶È¶¥µãÕ»*/
linkqueue *q;



graph printf_adjmatrix(graph g)/*Êä³öÁÚ½Ó¾ØÕó*/
 {
 int i,j;
 printf("ÁÚ½Ó¾ØÕó:\n");
 printf("vertex\t");
 for (i=0;i<g.vexnum;i++) printf("%4c",g.vexs[i]);
 printf("\n");
 for(i=0;i<g.vexnum;i++)
  { printf("% 4c \t",g.vexs[i]);
    for(j=0;j<g.vexnum;j++) printf("%4d",g.arcs[i][j]);
    printf("\n");
   }
 return g;
}

void create_1(graph g)
{
  int i,j,k,c=0;
  for (i=0;i<g.vexnum;i++)
     for(j=0;j<g.vexnum;j++)
      g.arcs[i][j]=c;
  for(k=0;k<g.arcnum;k++)
    g.arcs[g.a[k]-1][g.b[k]-1]=1;
  printf_adjmatrix(g);

 }
void create_2(graph g)
{
   int i,j,k,c=0;
   for (i=0;i<g.vexnum;i++)
     for(j=0;j<g.vexnum;j++)
      g.arcs[i][j]=c;
   for(k=0;k<g.arcnum;k++)
    { g.arcs[g.a[k]-1][g.b[k]-1]=1;
      g.arcs[g.b[k]-1][g.a[k]-1]=1;
     }
   printf_adjmatrix(g);

}
graph create_3(graph g)
{
  int i,j,k,c=999;
  for (i=0;i<g.vexnum;i++)
     for(j=0;j<g.vexnum;j++)
      g.arcs[i][j]=c;
  for(k=0;k<g.arcnum;k++)
	g.arcs[g.a[k]-1][g.b[k]-1]=g.h[k];
  printf_adjmatrix(g);
  return g;

}
graph create_4(graph g)
{
  int i,j,k,c=999;
  for (i=0;i<g.vexnum;i++)
     for(j=0;j<g.vexnum;j++)
      g.arcs[i][j]=c;
  for (k=0;k<g.arcnum;k++)
   { g.arcs[g.a[k]-1][g.b[k]-1]=g.h[k];
      g.arcs[g.b[k]-1][g.a[k]-1]=g.h[k];
     }
 printf_adjmatrix(g);
 return g;
}

void creategraph(graph g)/*ÁÚ½Ó¾ØÕó*/
{
 switch(g.kind)
    {
     case 1:create_1(g);break;
     case 2:create_2(g);break;
     case 3:create_3(g);break;
     case 4:create_4(g);break;
     default:printf("Error\n");
     }
}

adjlist  createlist (graph g ,adjlist adjl)/*ÁÚ½Ó±í*/
{
  int i;
  edgenode *p;
  if(g.kind==1||g.kind==3)
    { for(i=0;i<adjl.arcnum;i++)
      { p=(edgenode*)malloc(sizeof(edgenode));
	p->adjvex=g.b[i];
	p->info=g.h[i];
	p->next=adjl.adjs[g.a[i]-1].link;
	adjl.adjs[g.a[i]-1].link=p;
	}
     }
 if(g.kind==2||g.kind==4) 
   { for(i=0;i<adjl.arcnum;i++)
      { p=(edgenode*)malloc(sizeof(edgenode));
	p->info=g.h[i];
        p->adjvex=g.b[i];
       	p->next=adjl.adjs[g.a[i]-1].link;
        adjl.adjs[g.a[i]-1].link=p;
       
        p=(edgenode*)malloc(sizeof(edgenode));
        p->info=g.h[i];
        p->adjvex=g.a[i];
       	p->next=adjl.adjs[g.b[i]-1].link;
	adjl.adjs[g.b[i]-1].link=p;
	}
     }
printf("ÁÚ½Ó±íÎª:\n");
for(i=0;i<g.vexnum;i++)
 { printf("[%d,%c]=>",i+1,adjl.adjs[i].data);
   p=adjl.adjs[i].link;
   while(p!=cnull)
    {printf("[%c,%d]-->",adjl.adjs[(p->adjvex)-1].data,p->info);
   p=p->next;
 }
printf("^\n");
}
return adjl;
}
 void initqueue(linkqueue *p)
{    p->front=(linkqlist *)malloc(sizeof(linkqlist));
     p->rear=p->front;
     (p->front)->next=null;
     }

status empty(linkqueue *q)
{int v;
 if(q->front==q->rear) v=true;
 else   v=false;
 return v;
}
status addqueue(linkqueue *q,int e)/*Èë¶ÓÁĞ*/
{
 q->rear->next=(linkqlist *)malloc(sizeof(linkqlist));
 q->rear=q->rear->next;
 if(!q->rear) return -1;
 q->rear->data=e;
 q->rear->next=null;
}

status delqueue(linkqueue *q)/*³ö¶ÓÁĞ*/
{
  linkqlist *p;
  int e;
  if (q->front==q->rear)
      printf("the linklist is overflow");
  else p=(q->front)->next;
       (q->front)->next=p->next;
  e=p->data;
  if(q->rear==p)
       q->rear=q->front;
  free(p);/*ÊÍ·ÅPËùÖ¸µÄÄÚ´æÇø*/
 return(e);
}


void DFS(int i, adjlist adjl)/*Éî¶ÈÓÅÏÈËÑË÷*/
{edgenode *p;
 int j;
 int visited[maxlen];/*·ÃÎÊ±êÖ¾Êı×é,·ÃÎÊ¹ıÎª1,Î´·ÃÎÊ¹ıÎª0*/
 for(j=0;j<adjl.vexnum;j++) visited[j]=0;/*³õÊ¼»¯,ËùÓĞµã¶¼Î´·ÃÎÊ*/
  printf("%4c->",adjl.adjs[i-1].data);
  visited[i-1]=1;
  p=adjl.adjs[i-1].link;
  while(p!=cnull)
  {if (visited[(p->adjvex)-1]!=1) DFS((p->adjvex),adjl);
     p=p->next;
   }
}

void BFS(int i,adjlist adjl)/*¹ã¶ÈÓÅÏÈËÑË÷*/
{ edgenode *p;
  int j;
  int visited[maxlen];
  for (j=0;j<adjl.vexnum;j++) visited[j]=0;/*³õÊ¼»¯ËùÓĞµã*/

  initqueue(q);
  printf("%4c->",adjl.adjs[i-1].data);
  visited[i-1]=1;
  addqueue(q,i);
  while(!empty(q))
    {i=delqueue(q);
     p=adjl.adjs[i-1].link;
     while(p!=cnull)
       {if (visited[(p->adjvex)-1]==0)
          {printf("%4c->",adjl.adjs[p->adjvex-1].data);
           visited[(p->adjvex)-1]=1;
           addqueue(q,p->adjvex);
           p=p->next;
           }
        }
     }
}

status initstack(stackstru *s)/*¹¹Ôì¿ÕÕ»*/
{s->top=0;
 return ok;
}

status push(stackstru *s,int x)/*ÈëÕ»*/
{if (s->top==maxlen)
 printf("the stack is overflow!\n");
 else{ s->top=s->top+1;
       s->stack[s->top]=x;
      }
}
status pop(stackstru *s)
{ int y;
  if(s->top==0)printf("the stack is empty!\n");
  else {y=s->stack[s->top];
	s->top=s->top-1;
	}
  return y;
}

status stackempty(stackstru *s)
{ if (s->top==maxlen) return (true);
  else return (false);
}


 

status topsort(adjlist adjl)/*ÍØÆËÅÅĞò*/
{
  int i,k,count;
  edgenode *p;
  
  printf("ÍØÆËÅÅĞòĞòÁĞÎª:\n");
  initstack(s);
  
  for(i=0;i<adjl.vexnum;i++)
    if(adjl.adjs[i].id==0) push(s,adjl.adjs[i].data);
  count=0;
  while(!stackempty(s))
    { i=pop(s);
      printf("%4c->",adjl.adjs[i].data);
      ++count;
      for(p=adjl.adjs[i].link;p;p=p->next)
         { k=p->adjvex;
	   if(!(--adjl.adjs[k-1].id)) push(s,k-1);
          }
     }
  if(count<adjl.vexnum)
    { printf("\nÍøÖĞÓĞ»·!\n"); /*ÍØÆËÅÅĞòÊä³öµÄ¶¥µãÊı<Í¼ÖĞµÄ¶¥µãÊı*/
      return error;
     }
  else return ok;
}






 

void prim(graph g)/*×îĞ¡Éú³ÉÊ÷*/
{
  int i,j,k,min;
  int lowcost[maxlen];/*È¨Öµ*/
  int closet[maxlen];/*×îĞ¡Éú³ÉÊ÷½áµã*/
  printf("×îĞ¡Éú³ÉÊ÷µÄ±ßÎª:\n");
  for(i=1;i<g.vexnum;i++)
   {
     lowcost[i]=g.arcs[0][i];
     closet[i]=1;
    }
  closet[1]=0;
  j=1;
  for(i=1;i<g.vexnum;i++)
   {
     min=lowcost[j];
     k=i;
     for(j=1;j<g.vexnum;j++)
       if(lowcost[j]<min&&closet[j]!=0)
         {
	  min=lowcost[j];
	  k=j;
	 }
      printf("(%c,%c),",g.vexs[k-1],g.vexs[closet[k-1]]);
      closet[k]=0;
      for(j=1;j<g.vexnum;j++)
        if(g.arcs[k][j]<lowcost[j]&&closet[j]!=0)
           {
              lowcost[j]=g.arcs[k][j];
              closet[j]=k;
	    }
     }
}

int ve[maxlen];/*×îÔç·¢ÉúÊ±¼ä*/
int vl[maxlen];/*×î³Ù·¢ÉúÊ±¼ä*/
 
status toporder(adjlist adjl,stackstru *t)/*Çó¸÷¶¥µãÊÂ¼şµÄ×îÔç·¢ÉúÊ±¼äve*/
{ int i,j,count,k;
  edgenode *p;
  initstack(s);
  initstack(t);
  for(i=0;i<adjl.vexnum;i++)
    if(adjl.adjs[i].id==0) push(s,i);

  count=0;
  for(i=0;i<adjl.vexnum;i++) ve[i]=0;
  while(!stackempty(s))
    { j=pop(s);push(t,j);++count;
      for(p=adjl.adjs[j].link;p;p=p->next)
        { k=p->adjvex;
          if(--adjl.adjs[k-1].id==0) push(s,k-1);
	  if(ve[j]+(p->info)>ve[k-1]) ve[k-1]=ve[j]+(p->info);
         }
     }
  if(count<adjl.vexnum) return error;
   else return ok;
}

status criticalpath(adjlist adjl)/*¹Ø¼üÂ·¾¶*/
{  int i,j,k,dut,ee,el;
   edgenode *p;
   
   if(!toporder(adjl,t)) return error;
   for(i=0;i<adjl.vexnum;i++) vl[i]=ve[i-1];/*³õÊ¼»¯¶¥µãÊÂ¼şµÄ×î³Ù·¢ÉúÊ±¼ä*/
   printf("¹Ø¼üÂ·¾¶Îª:\n");
  while(!stackempty(t))/*°´ÍØÆËÅÅĞòµÄÄæĞòÇó¸÷¶¥µãµÄ×î³Ù·¢ÉúÊ±¼äveÖµ*/
    for(j=pop(t), p=adjl.adjs[j].link;p;p=p->next)
       { k=p->adjvex; dut=(p->info);
         if(vl[k]-dut<vl[j]) vl[j]=vl[k]-dut;
        }
  for(j=0;j<adjl.vexnum;++j)/*Çóee,elºÍ¹Ø¼ü»î¶¯*/
    for(p=adjl.adjs[j].link;p;p=p->next)
      { k=p->adjvex;dut=p->info;
        ee=ve[j];el=vl[k-1]-dut;
        if(ee==el) printf("(%c,%c)->",adjl.adjs[j].data,adjl.adjs[k-1].data);
       }
}

void shortpath_dijkstra(graph g)
{ int cost[maxlen][maxlen];
  int dist[maxlen];/*Ä³Ô´µãµ½¸÷¶¥µãµÄ×î¶ÌÂ·¾¶³¤¶È*/
  int path[maxlen];/*Ä³Ô´µãµ½ÖÕµã¾­¹ıµÄ¶¥µã¼¯ºÏµÄÊı×é*/
  int s[maxlen];/*×î¶ÌÂ·¾¶µÄÖÕµã¼¯ºÏ*/
  int i,j,n,v0,min,u;/*U´æ·Å×î¶ÌÂ·¾¶µÄÖÕµã*/
  printf("\nÇëÊäÈëÆğµãµÄ±àºÅ:");
  scanf("%d",&v0);
  v0--;
  for(i=0;i<g.vexnum;i++)
    {for(j=0;j<g.vexnum;j++)
      cost[i][j]=g.arcs[i][j];
     }
  for(i=0;i<g.vexnum;i++)
    { dist[i]=cost[v0][i];
      if(dist[i]<large&&dist[i]>0) path[i]=v0;
      s[i]=0;
     }
  s[v0]=1;
  for(i=0;i<g.vexnum;i++)
    { min=large;
      u=v0;
      for(j=0;j<g.vexnum;j++)
        if(s[j]==0&&dist[j]<min)
          {min=dist[j];u=j;}
      s[u]=1;   /*U¶¥µãÊÇÇóµÃ×î¶ÌÂ·¾¶µÄ¶¥µã±àºÅ*/
      for(j=0;j<g.vexnum;j++)
         if(s[j]==0&&dist[u]+cost[u][j]<dist[j])
           { dist[j]=dist[u]+cost[u][j];
             path[j]=u;
            }
      }
  printf("\n¶¥µã%dµ½¸÷¶¥µãµÄ×î¶ÌÂ·¾¶³¤¶ÈÎª:\n",v0);
  for(i=0;i<g.vexnum;i++)/*ÊäÈë½á¹û*/
     if(s[i]==1)
       { u=i;
         while(u!=v0)
            { printf("%4c<-",g.vexs[u]);
              u=path[u];
             }
          printf("%4c",g.vexs[u]);
          printf(":%d\n",path[i]);
         }
      else printf("%4c<-%4c:ÎŞÂ·¾¶\n",g.vexs[i],g.vexs[v0]);
}

void shortpath_floyd(graph g)
{ int path[maxlen][maxlen];
  int short3[maxlen][maxlen];/*È¨Öµ*/
  int i,j,k;
  for(i=0;i<g.vexnum;i++)
     for(j=0;j<g.vexnum;j++)
       { short3[i][j]=g.arcs[i][j];
         path[i][j]=0;
        }
  printf("\n¸÷¶¥µã¼äµÄ×î¶ÌÂ·¾¶Îª:\n");
  for(k=0;k<g.vexnum;k++)
    for(i=0;i<g.vexnum;i++)
      { if(short3[i][j]>(short3[i][k]+short3[k][j]))
	  { short3[i][j]=short3[i][k]+short3[k][j];
            path[i][j]=k;
           }
	 printf("(%4c->%4c):%d",g.vexs[i-1],g.vexs[j-1],short3[i][j]);
       }
}




main()
{

int a,i,j,k,h;
printf("\nÇëÊäÈëÍ¼µÄÀàĞÍ(1:ÓĞÏòÍ¼ 2:ÎŞÏòÍ¼ 3:ÓĞÏòÍø 4:ÎŞÏòÍø):");
scanf("%d",&i);
{g.kind=i;adjl.kind=i;}
printf("ÇëÊäÈë¶¥µãÊı,±ßÊı:");
scanf("%d,%d",&i,&j);
g.vexnum=i;adjl.vexnum=i;
g.arcnum=j;adjl.arcnum=j;
for (i=0;i<g.vexnum;i++)
 { printf("µÚ%d¸ö¶¥µãµÄĞÅÏ¢:",i+1);
   scanf("%s",&g.vexs[i]);
   adjl.adjs[i].data=g.vexs[i];
   adjl.adjs[i].link=cnull;
   adjl.adjs[i].id=0;
   }
for (k=1;k<=g.arcnum;k++)
{label:if (g.kind==1||g.kind==3)
	 printf("µÚ%dÌõ±ßµÄÆğµã±àºÅ,ÖÕµã±àºÅ:",k);
       else printf("µÚ%dÌõ±ßµÄÁ½¸ö¶¥µãµÄ±àºÅ:",k);
       scanf("%d,%d",&i,&j);
       g.a[k-1]=i;g.b[k-1]=j;
       while (i<1||i>g.vexnum||j<1||j>g.vexnum)
       {printf("     ±àºÅ³¬³ö·¶Î§,ÖØĞÂÊäÈë");goto label;

	}
       if (g.kind==3||g.kind==4)
       {printf("\t¸Ã±ßµÄÈ¨Öµ:");
	scanf("%d",&h);
	g.h[k-1]=h;
	}
	else  g.h[k-1]=null;
	adjl.adjs[i].id++;
}
loop1:printf("\n1__ÁÚ½Ó¾ØÕó\n");
printf("2__ÁÚ½Ó±í\n");
printf("3__Éî¶ÈÓÅÏÈËÑË÷\n");
printf("4__¹ã¶ÈÓÅÏÈËÑË÷\n");
printf("5__×îĞ¡Éú³ÉÊ÷\n");
printf("6__ÍØÆËÅÅĞò\n");
printf("7__¹Ø¼üÂ·¾¶\n");
printf("8__´ÓÄ³¸öÔ´µãµ½ÆäÓà¸÷¶¥µãµÄ×î¶ÌÂ·¾¶\n");
printf("9__Ã¿Ò»¶Ô¶¥µãÖ®¼äµÄ×î¶ÌÂ·¾¶\n");
loop:printf("ÇëÑ¡ÔñÍ¼µÄÊµÏÖ:\t");
scanf("%d",&a);
 switch(a)
 {
  case 1:creategraph(g);break;
  case 2:createlist(g,adjl);break;
  case 3:printf("ÇëÊäÈë³ö·¢µã±àºÅ:");
           scanf("%d",&k);
          createlist(g,adjl);
           printf("\n´ÓµÚ%dµã³ö·¢Éî¶ÈÓÅÏÈËÑË÷±éÀúĞòÁĞ:",k);
	   DFS(k,adjl);break;
  case 4:printf("ÇëÊäÈë³ö·¢µã±àºÅ:");
           scanf("%d",&k);
           createlist( g,adjl);
           printf("\n´ÓµÚ%dµã³ö·¢¹ã¶ÈÓÅÏÈËÑË÷±éÀúĞòÁĞ:",k);	
	   BFS( k,adjl);
	   break;
  case 5:if (g.kind==4)
	       {create_4(g); prim(g);}
	   else{printf("\t²»ÄÜ¹¹Ôì×îĞ¡Éú³ÉÊ÷,ÇëÖØĞÂÑ¡Ôñ:\n");goto loop;}
           break;
  case 6:if (g.kind==1||g.kind==3)
	       {createlist(g,adjl); topsort(adjl);}
	   else{printf("\t²»ÄÜÍØÆËÅÅĞò,ÇëÖØĞÂÑ¡Ôñ:\n");goto loop;}
           break;
  case 7:if (g.kind==3)
	       {createlist(g,adjl);
	       criticalpath( adjl);
	       }
	   else{printf("\tÃ»ÓĞ¹Ø¼üÂ·¾¶,ÇëÖØĞÂÑ¡Ôñ:\n");goto loop;}
           break;
  case 8:if (g.kind==3)
	       {create_3(g); shortpath_dijkstra(g);}
	   else{printf("\tÃ»ÓĞ×î¶ÌÂ·¾¶,ÇëÖØĞÂÑ¡Ôñ:\n");goto loop;}
           break;
  case 9:if (g.kind==3)
	       {create_3(g); shortpath_floyd(g);}
	   else{printf("\tÃ»ÓĞ×î¶ÌÂ·¾¶,ÇëÖØĞÂÑ¡Ôñ:\n");goto loop;}
           break;
  default:printf(" \n\t*** wrong ***\n");
  }/*switch*/
goto loop1;
 }/*main()*/



===========================			 
Ô²ÖÜÂÊ.txt			 
#include<stdio.h>
long a=10000,b,c=2800,d,e,f[ 2801 ],g; 
main()
{
	for(;b-c;)
		f[ b++ ]=a/5; 
	for(;d=0,g=c*2;c-=14,printf("%.4d",e+d/a),e=d%a) 
		for(b=c;d+=f[ b ]*a,f[ b ]=d%--g,d/=g--,--b;d*=b);
} 
===========================			 
¶àÎ»½×³Ë.txt			 
/*¼ÆËã 30000 µÄ½×³Ë £¡*/

/* This file "jiech2.c" 
  created at 2001-08-24 20:15:22
  by LeiPeng .
*/

#include <conio.h>
#include <ctype.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXN 0X7000

int a[MAXN];

int main(int argc,char *argv[])
{
    int n,m,i,j,c,t;
    printf("Enter n(n>=2) :");
    while(1)
    {
        scanf("%d",&n);
        if(n>=2&&n<=3276) break;
        printf("must be 2<=n<=3276");
    }
    a[0]=1; m=1;
    for(i=2;i<=n;i++)
    {
        for(c=0,j=0;j<m;j++)
        {
            t=a[j]*i+c;
            a[j]=t%10;
            c=t/10;
        }
        while(c)
        {
            a[m++]=c%10;
            c/=10;
        }
    }
    printf("%d!=\n",n);
    for(i=m-1;i>=0;i--) putchar(a[i]+0x30);    
    printf("\npress any key to continue .\n");
    getch();
    return 0;
} 
/*3000!µÃ½á¹û³¬³öÁËµçÄÔÄÜÏÔÊ¾µÃ·¶Î§£¬ËùÒÔ×îºÃ²ÉÓÃÊı×éÀ´¼ÇÂ¼Ã¿Î»*/===========================			 
#include <stdio.h>

main()
{
  int data[40];
  int digit;
  int i,j,r,k;
  int n;

  for(i=1;i<=40;i++)  /* ½«Êı×é³õÊ¼ÖµÉèÎª0 */
    data[i]=0;

  data[0]=1;
  data[1]=1;
  digit=1;

  printf("Enter a number what you want to calculus : ");
  scanf("%d",&n);

  for(i=1;i<=n;i++)
  {
      for(j=1;j<=digit;j++) /* Ã¿Î»ÉÏµÈ³ËÉÏ½×Êı digit ¾ö¶¨ÓĞ¼¸Î»*/
	data[j]*=i;
      for(j=1;j<=digit;j++)
      {
	  if(data[j]>10)
	  {
	      for(r=1;r<=digit;r++)
	      {
		  if(data[digit]>10)
		    digit++;
		  data[r+1]+=data[r]/10;
		  data[r]=data[r]%10;
	      }
	  }
      }
      printf("%d!=",i);
      for(k=digit;k>0;k--)
	printf("%d",data[k]);
      printf("\n");
  }
  getch();
}




¶àÎ»½×³Ë2.txt			 
===========================			 
´ó¼ÓÊı.txt			 
/*ÕâÊÇÒ»¸ö´óÕıÊı¼Ó·¨ÎÊÌâTCÖĞÓ¦¸ÃÍêÈ«¿ÉÒÔÔËĞĞ¡£ */

#include<stdio.h> 
#include<malloc.h> 

#define HUN 10000

typedef struct node 
{ 
	int data; 
	struct node *next; 
}NODE;

NODE *insert(NODE *u,int num) /*ÉùÃ÷·µ»ØÖ¸Õëº¯Êı*/
{ 
	NODE *v; /*ÉùÃ÷½á¹¹Ö¸Õë*/
	v=(NODE*)malloc(sizeof(NODE)); 
	v->data=num; 
	u->next=v; 
	return(v); 
} 

NODE *addint(NODE *p,NODE *q) 
{ 
	NODE *pp,*qq,*r,*s,*t; 
	int total,number,carry; 
	pp=p->next;
	qq=q->next; 
	s=(NODE*)malloc(sizeof(NODE)); 
	s->data=-1; 
	t=s; 
	carry=0; 
	while(pp->data!=-1&&qq->data!=-1) 
	{ 
		total=pp->data+qq->data+carry; 
		number=total%HUN; 
		carry=total/HUN; 
		t=insert(t,number); 
		pp=pp->next;     
		qq=qq->next; 
	} 
	r=(pp->data!=-1)?pp:qq; 
	while(r->data!=-1) 
	{ 
		total=r->data+carry; 
		number=total%HUN; 
		carry=total/HUN; 
		t=insert(t,number); 
		r=r->next; 
	} 
	if(carry) 
		t=insert(t,1); 
	t->next=s; 
return(s); 
} 

NODE *inputint(void) 
{ 
	NODE *s,*ps,*qs; 
	struct number 
	{ 
		int num; 
		struct number *np; 
	}*p,*q; 

	int i,j,k; 
	long sum; 
	char c; 
	p=NULL; 
	while((c=getchar())!='\n') 
		if(c>='0'&& c<='9') 
		{ 
			q=(struct number *)malloc(sizeof(struct number)); 
			q->num=c-'0'; 
			q->np=p; 
			p=q; 
		}
		 
	s=(NODE*)malloc(sizeof(NODE)); 
	s->data=-1; 
	ps=s; 
	while(p!=NULL) 
	{ 
		sum=0;i=0;k=1; 
		while(i<4&&p!=NULL) 
		{ 
			sum=sum+k*(p->num); 
			i++;p=p->np;k=k*10; 
		} 
		qs=(NODE*)malloc(sizeof(NODE)); 
		qs->data=sum; 
		ps->next=qs; 
		ps=qs; 
	} 
	ps->next=s; 
	return(s); 
} 

printint(NODE *s) 
{ 
	if(s->next->data!=-1) 
	{ 
		printint(s->next); 
		if(s->next->next->data==-1) 
			printf("%d",s->next->data); 
		else
		{ 
			int i,k=HUN; 
			for(i=1;i<=4;i++,k/=10) 
				putchar('0'+s->next->data%(k)/(k/10)); 
		} 
	} 
} 

main() 
{ 
	NODE *s1,*s2,*s; 
	NODE *inputint(),*addint(),*insert_after(); 
	s1=inputint(); 
	s2=inputint(); 
	printf("S1="); 
	printint(s1); 
	printf("\n"); 
	printf("S2="); 
	printint(s2); 
	printf("\n"); 
	s=addint(s1,s2); 
	printf("S1+S2=");printint(s);printf("\n"); 
} ===========================			 
/*×î´ó¹«Ô¼Êı£¬×îĞ¡¹«±¶Êı*/

#include <stdio.h>

int hcf(int a,int b)
{
  int r=0;
  while(b!=0)
  {
      r=a%b;
      a=b;
      b=r;
  }
  return(a);
} 

lcd(int u,int v,int h)
{
    return(u*v/h);
}

main()
{
    int u,v,h,l;
    scanf("%d%d",&u,&v);
    h=hcf(u,v);
    printf("H.C.F=%d\n",h);
    l=lcd(u,v,h);
    printf("L.C.D=%d\n",l);
}´óĞ¡±¶Ô¼.txt			 
===========================			 
´óÕûÊı.txt			 
/*ÕâÖ»ÊÇÁ½¸ö´óÕûÊıµÄ³Ë·¨£¬¼Ó·¨£¬¼õ·¨Ó¦²»³ÉÎÊÌâ£¬Äã¿É²ÎÕÕÏÂÃæµÄ³ÌĞò
ÒªÊÇ³ı·¨µÄ»°£¬¿ÉÒÔÓÃÊıÖµ·ÖÎöÀïµÄÅ£¶Ù±Æ½ü·¨*/

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * Question:                             *
 *    How to calculate two integers each one has forty bit.         * 
 * Algorithm:                             *    
 *    Declare two arrays suppose to be array A and B to storage   * 
 *   the two integers just as a intacter singly.             *    
 *    Get the first number from array B,then use it to multiply   *
 *   the number of array A singly. Declare another array C to        *
 *   storage the value when multiplying.                           *
 * Thinking about the carrying bits.                     *
 * Thinking:                             *
 *   Can you use the Linear_List to do this?                 * 
 *   If they are two floating numbers,so how to do it?             * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <conio.h>

//To calculate two 40 bits integers multiply,change 10 to 40
#define THE_ARR_A_SIZE 10                 #define ARR_B_SIZE THE_ARR_A_SIZE
#define ARR_C_SIZE (THE_ARR_A_SIZE + ARR_B_SIZE)

void main(void);
void Multiply( short *, short *, short *, short, short);
void Carrying( short *c, short);

void main(void)
{
    short A[THE_ARR_A_SIZE] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9}; // 10 
    short B[ARR_B_SIZE] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9}; 
    short C[ARR_C_SIZE];
    short i = 0;

    for ( NULL; i < ARR_C_SIZE; i++)
    {
        *(C+i) = 0;
    }
    
    Multiply(A, B, C, THE_ARR_A_SIZE, ARR_B_SIZE);
    Carrying(C, ARR_C_SIZE);
    
    printf("\nThe Result is: ");
    
    i = 0;
    if (C[0] == 0)        ++i;    //To delete the primacy zero
    for ( NULL; i < ARR_C_SIZE; i++)
    {
        printf("%d", C[i]);
    }
    getch();
    printf("\n");
}

/* 
 * NOTICE:
 *   The Array C is not initialed,you should do that. Here 
 *   the array is supposed to be filled zero.
 * Algorithm:
 *   
 */

void Multiply( short A[], short B[], short C[], short A_size, short B_size)
{
    short i = 0, j = 0, k = 1;    // Assigned k to 1 to leave C[0] 
                                     //be null to storage the carrying.
        
    for (j = 0; j<B_size; j++)
    {
        for (i = 0; i<A_size; i++)
        {
            C[k] += B[j] * A[i];
            k++;
        }
        k = 2;
        k = k + j;
    }
}

// To solve the carrying .

void Carrying(short C[],short C_size)
{
    short i, tens_place = 0, units_order = 0;
    short temp = 0, end_arr;
    
    end_arr = C_size-1;
    for (i = end_arr; i >= 0; i--)
    {    
        temp = C[i];
        if (C[i] > 9)
        {
            tens_place = temp / 10;
            units_order = temp % 10;
            C[i-1] += tens_place;
            C[i] = units_order;
        }
    }
}===========================			 
#include <iostream.h>
#define MS 20

char a[MS]="whatisit";
char b[MS]="*is*";
int searchStr(char s1[MS],char s2[MS],int p1,int p2);
bool chazhao(char a[MS],char b[MS]);

void main()
{
	int i;
	cout<<chazhao(a,b);
	cin>>i;
}

bool chazhao(char a[MS],char b[MS])
{

    int i;
    i=searchStr(a,b,1,1);
if(i!=0){i=i-strlen(b)+1;cout<<i<<endl;}
}

//´Ós1ÖĞµÚn¸ö¿ªÊ¼²éÕÒs2µÚm¸ö¿ªÊ¼ ·µ»Øs2µÄÄ©Î²ÔÚs1ÖĞµÄÎ»ÖÃ
/*int searchStr(char s1[MS],char s2[MS],int p1)
{
    int i;
for(i=p1
} */
bool cmpStr(char s1[MS],char s2[MS],int p1)
{
int jc=0;
    for(i=1;i<=strlen(s2);i++)
{
    if(s1[i+p1]!=s2[i])jc=1
    if(jc==1)return true;
    else return false;
}
}
/*    int k;
cout<<p1<<" "<<p2<<endl;
if(s2[p2]==NULL)
    return p1;
while(s1[p1]!=NULL)
{
if(s1[p1]==s2[p2])
{
    p1++;p2++;
k=searchStr(s1,s2,p1,p2);
if(k==0)
    return 0;
else
    return k;
}
p1++;
}
return 0;
}*/
×Ö·û´®²éÕÒ.txt			 
===========================			 
×Ö·û±à¼­.txt			 
Õâ¶ùÓĞÁ½¸öº¯Êı,ÄÜ½øĞĞÔÚÒ»¸ö×Ö·û´®ÖĞµÄ²åÈëºÍÉ¾³ıÒ»¸ö×Ö·û,ÓĞĞËÈ¤µÄ¿ÉÒÔ²Î¿¼Ò»ÏÂ.

  

#include<string.h>
#include<ctype.h>

void cinsert(char ccode,char *anystring,int spos)
{
    int p;
    p=strlen(anystring);
    spos=spos<0?0:spos;
    spos=spos>=p?p:spos;
    for(;p>=spos;p--)
        anystring[p+1]=anystring[p];
    anystring[spos]=ccode;
}

void cdelete(char *anystring,int spos)
{
    int p;
    p=strlen(anystring);
    if(p>0&&spos>=0&&spos<=p){
        while(spos<p){
            anystring[spos]=anystring[spos+1];
            spos++;
        }
    }
}

===========================			 
===========================			 
ÍêÊı.txt			 
/*±à³ÌÕÒ³ö1000Ö®ÄÚµÄ"ÍêÊı".ÍêÊıÖ¸:Ò»¸öÊıÈç¹ûÇ¡ºÃµÈÓÚËüµÄÒò×ÓÖ®ºÍ. 
ÀıÈç6=1+2+3  28=1+2+4+7+14 */

main() 
{
  static int k[10];   
  int i,j,n,s;       
  for(j=2;j<=1000;j++) 
  {
    n=-1; s=j; 
    for(i=1;i<j;i++) 
    {
      if(j%i==0) 
      {
 	n++;
 	s=s-i;
	k[n]=i;
      } 
    } 
    if(s==0) 
    {
      printf("%dÊÇÒ»¸öÍêÊı,ËüµÄÒò×ÓÊÇ",j); 
      for(i=0;i<n;i++) 
        printf("%d ,",j); 
      printf("%d\n",k[n]); 
    } 
      
  }  
}


/*
 
ÉèXÎªÍêÊı£¬ËüÓĞm¸öÒò×Ó£¨²»°üÀ¨×ÔÉí£©1,t1,t2,...tn£¨(ti+1)>(ti)) 
µ±n=2kÊ±£¬ÒòÎªÒ»¸öÕûÊıµÄÒò×Ó×ÜÊÇ³É¶Ô³öÏÖµÄ£¬ËùÒÔÓĞÈçÏÂ¹ØÏµ 
t1*t2k=X£¬t2*t2k-2=X£¬¡£¡£¡£(1) 
ÓÖÓĞt1+t2+...+t2k=X         (2) 
t1*t2*...*t2k=X            (3) 
ÓÉ(1)ºÍ(3)t2*...*t2k-2=1 
ÓÖÒòÎª(ti+1)>(ti),Öªk=1,¼´1*t1*t2=1+t1+t2=X£¬½âÕâ¸ö²»¶¨·½³Ì£¬Öªt1=2,t2=3ÎªÎ¨Ò»½â 
µ±n=2k-1Ê±£¬ÎŞ½â  
 
*/ 
===========================			 
¶¨³¤´®.txt			 
#define MAXSTRLEN 255  
typedef unsigned char sstring[MAXSTRLEN+1] 

struct sstring
{
	char *ch;
  	int length;
}

strassign(struct sstring *T,char *chars) 
{
	int nlenth;
  	nlenth=strlen(chars);
  	T->length=nlenth;
  	T->ch=(char *)malloc(nlenth*sizeof(char)+1);
  	if(!T->ch)
  	{
      		T->length=0;
      		exit(overflow);
      	}
    	else
    	{
		strcpy(T->ch,chars);
	 	return 0;	
	}
}//strassign


  int strlength(struct sstring *S)   
  {  
     S->length=strlen(S);
     return S->ch;
     }//strlength






int strcompare(struct sstring *S,struct sstring *T)   
 {
   if S>MAXSTRLEN && T>MAXSTRLEN  exit(overflow);
   if (strcmp(S->ch,T->ch)==0) return 0;
   else if(strcmp(S->ch,T->ch)>0) return 1;
   else return -1;
 }//strcompare




 int clearstring(struct sstring *S)   
 {
   if (S->ch){
	  free (S->ch);
	  S->ch=NULL;
	  S->length=0;
	  }
	  return 0;
   }//clearstring




   int concat(struct sstring *T,struct sstring *s1,struct sstring *s2) 
  {   
        if(s1[0]+s2[0]<=MAXSTRLEN)
      {                         
        strcpy(T->ch,s1->ch);
        strcpy(T->ch,s2->ch);
        T[0]=S1[0]+S2[0];
        uncat=TRUE;
       }
        else if (s1[0]<MAXSTRLEN)
       {                      
         strcpy(T->ch,s1->ch);
         strcpy(T->ch,s2->ch);
         T[0]=MAXSTRLEN;
         uncat=FALSE;
       }
        else{
         T->ch=s1->length     
         uncat=FALSE;
             }
         return uncat;
     }//concat




 int substring(struct sstring *sub,struct sstring *S,int pos,int len)
   {                              
    char *p;int i;
    if(pos<1 || pos>S[0] || len<0 || len>S[0]-pos+1)
       return -1;
    else{
	sub->ch=(char*) malloc(len *sizeof(char)+1);
	p=S->ch;
	for(i=0;i<=pos-1;i++)
	p++;
	}
     strcpy(sub->ch,p);

     return 0;
  }//substring




  main( )
  {
    char inp;
    char *T[255];
    char *S[255];
    struct sstring *s1,*s2,*res;
    int pos,len;
    printf("1-------strassing\n");
    printf("2-------strlength\n");
    printf("3-------strcompare\n");
    printf("4-------clearstring\n");
    printf("5-------concat\n");
    printf("6-------substring\n");
    printf("*-------exit!");
    printf("please in put1--6 or *\n\n")
 while(1){
      scanf("%c",&inp);
      switch(inp){
	      case 1:{
		    scanf("%s",&S);
		    res->ch=strassign(s1,S);
		    if(res->ch==0)
			printf("the string is:%s",s1->ch);
		    else
		       printf("error"); }
	      case 2: {
		    scanf("%s",&S);
		    s1->length=strlen(S);
		    strcpy(s1->ch,S);
		    res->ch=strlength(S);
		    printf("the string is:%d\n",s1->length);}
	      case 3:{
		    scanf("%s",&S);
		    scanf("%s",&T);
		    s1->length=strlen(S);
		    strcpy(s1->ch,S);
		    s2->length=strlen(T);
		    strcpy(s2->ch,T);
		    res->ch=strcompare(S,T);
		    switch(res){
		       case 0:
			    printf("two strings are equle");
		       case 1:
			    printf("the first string > the second string");
		       case -1:
			    printf("the first string < the second string");}
                       }
	     case 4:{
		    res->ch=clearstring(s1);
		    res->ch=clearstring(s2);
		    printf("the string is NULL");}
	     case 5:{
		    scanf("%s",&S);
		    scanf("%s",&T);
		    strcat(&s1,S,T);
		    if(res==0)
		      printf("the string is:%s",s1->ch);
		    }
	     case 6: {
		    scanf("%s_%d_%d",S,&pos,&len);
		    s2->length=strlen(S);
		    strcpy(s2->ch,S);
		    res->ch=substring(s1,s2,pos,len);
		    if(res==0)
			printf("the string is:%s",s1->ch);
		    else printf("error");}
	     case *:
		    exit;
       }
      }
    }










===========================			 
#include <stdio.h>
#include <stdlib.h>

main()
{
    FILE *fp;
    char ch,filename[10];
    scanf("%s",filename);
    if( (fp=fopen(filename,"w") )==NULL)
    {
    	printf("cannot open file\n");
    	exit(0);
    }
    ch=getchar();  /*´ËÓï¾äÓÃÀ´½ÓÊÕÔÚÖ´ĞĞscanfÓï¾äÊ±×îºóÊäÈëµÄ»Ø³µ·û*/
    ch=getchar();  /*½ÓÊÕÊäÈëµÄµÚÒ»¸ö×Ö·û*/
    while(ch != '#')
    {
    	fputc(ch,fp);putchar(ch);
    	ch=getchar();
    }
    fclose(fp);
}
ÊµÀı1.txt			 
===========================			 
#include <stdio.h>
#include <stdlib.h>

main()
{
    FILE *in,*out;
    char ch,infile[10],outfile[10];
    printf("Enter the infile nmae:\n");
    scanf("%s",infile);
    printf("Enter the outfile name:\n");
    scanf("%s",outfile);
    
    if( (in=fopen(infile,"r") )==NULL)
    {
    	printf("cannot open infile\n");
    	exit(0);
    }
    if( (out=fopen(outfile,"w") )==NULL)
    {
    	printf("cannot open outfile\n");
    	exit(0);
    }
    
    while( ! feof(in) )  fputc(fgetc(in),out);
    
    fclose(in);
    fclose(out);
}

    
}
ÊµÀı2.txt			 
===========================			 
ÊµÀı3.txt			 
#include <stdio.h>
#include <stdlib.h>

main(int argc, char *argv[])
{
    FILE *in,*out;
    char ch;
    if(argc!=3);
    {
    	printf("You forgot to enter a filename\n");
    	exit(0);
    }
    if( (in=fopen(infile,"r") )==NULL)
    {
    	printf("cannot open infile\n");
    	exit(0);
    }
    if( (out=fopen(outfile,"w") )==NULL)
    {
    	printf("cannot open outfile\n");
    	exit(0);
    }
    
    while( ! feof(in) )  fputc(fgetc(in),out);
    fclose(in);
    fclose(out);
}

===========================			 
Ğ¡Ğ´Êı×Ö×ª»»³É´óĞ´Êı×Ö1.txt			 
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char * floattoch(float m);

static char chinese[]="ÁãÒ¼·¡ÈşËÁÎéÂ½Æâ°Æ¾Áµã";
static char ch[80];

void main()
{
  float m;
  char *s;

  printf("Input Number: ");
  scanf("%f",&m);
  s=floattoch(m);
  printf("\n%s\n",s);
}

char *floattoch(float m)
{
  char tmp[30];
  int i,j,k=0,flag=0,d=0,temp;
  float n;

  i=m;
  do
  {
    j=i%10;
    tmp[k]=chinese[j*2];
    tmp[k+1]=chinese[j*2+1];
    k+=2;
    i/=10;
  }while(i);
  tmp[k]=0;
  //tmp[k]=0;
  printf("%d\n",strlen(tmp));
  for(i=strlen(tmp)-1;i>=0;i-=2,d+=2)
  {
    ch[d]=tmp[i-1];
    ch[d+1]=tmp[i];
  }

i=(m-(int)m)*1000; k=0; 
temp=i;       //´ı»áÅĞ¶ÏÓÃ 
do 
{ 
  j=i%10; 
  if(j) flag=1; 
  if(flag) 
  { 
    tmp[k]=chinese[j*2]; 
    tmp[k+1]=chinese[j*2+1]; 
    k+=2; 
  } 
  i/=10; 
}while(i); 
 while(temp<100) 
{//¼ÓÈëÁã 
    tmp[k]=chinese[0]; 
    tmp[k+1]=chinese[1]; 
    k+=2; 
    temp*=10; 
} 
tmp[k]=0; 
  if(strlen(tmp))
  {
    ch[d]=chinese[20];
    ch[d+1]=chinese[21];
    d+=2;
  }
  for(i=strlen(tmp)-1;i>=0;i-=2,d+=2)
  {
    ch[d]=tmp[i-1];
    ch[d+1]=tmp[i];
  }

  return(ch);
}  ===========================			 
Ğ¡Ğ´Êı×Ö×ª»»³É´óĞ´Êı×Ö2.txt			 
/***  ³ÌĞò: 123.45    ÔòÊä³ö¡°Ò¼°Û·¡Ê°ÈşµãËÁÎé¡± ***/


#include <stdio.h>  /*±ê×¼ÊäÈëÊä³öº¯Êı*/
#include <string.h>  /*×Ö·û´®º¯Êı*/
#include <stdlib.h>  

void ConvertN(int n,char* &p,bool IsSequece=true);  /*ÉùÃ÷º¯ÊıConvertN*/
bool ConvertSegment(int number,int n,char* &p,bool IsLastZiero); /*ÉùÃ÷º¯ÊıConvertSegment*/
bool ChangeNumber(double dbNumber,char* lpszvalues);  /*ÉùÃ÷º¯ÊıChangeNumber*/

void main() 
{ 
 double db=-1200008.9876; 
 printf("%lf\n",db); 
 char buf[100]; 
 if(ChangeNumber(db,buf)) 
   printf("%s\n",buf); 

 db=1000000.98; 
 printf("%lf\n",db); 
 if(ChangeNumber(db,buf)) 
   printf("%s\n",buf); 

 db=10000008.0987; 
 printf("%lf\n",db); 
 if(ChangeNumber(db,buf)) 
   printf("%s\n",buf); 

 db=10200408.09007; 
 printf("%lf\n",db); 
 if(ChangeNumber(db,buf)) 
   printf("%s\n",buf); 

 db=10020400.007; 
 printf("%lf\n",db); 
 if(ChangeNumber(db,buf)) 
   printf("%s\n",buf); 
} 

void ConvertN(int n,char* &p,bool IsSequece/*=true*/) 
/*¶¨Òåº¯ÊıConvertN
 "Ğ¡ÊıÎ»×ª»»" ½«Êı×Ön(0<=n<=9)×ª»»³ÉÖĞÎÄºó´æÈëp,IsSequece¿ØÖÆ´æ·ÅË³Ğò */
{ 
 if(n<0 || n>9)   
 { 
   printf("Error:Êı×é³¬½ç!\n");   /*Èç¹û³¬¹ı½çÏŞ¾ÍÊä³ö´íÎó*/
   exit(0);    /*Ìø³öº¯Êı*/
 } 

 char num[]="ÁãÒ¼·¡ÈşËÁÎéÂ½Æâ°Æ¾Á"; 
 if(IsSequece)                         /*Èç¹ûIsSequeceÎªÕæ¾ÍË³Ğò´æ·Å*/
 { 
   *p++=num[2*n]; 			/*ÒòÎªºº×ÖÊÇË«×Ö½ÚµÄËùÒÔ£¬ÔÚ°Ñ°¢À­²®Êı×Ö×ª»¯Ê±±ÈÈç0¶ÔÓ¦µÄÁãÊÇË«×Ö½Ú£¬Õ¼Êı×éµÄ0ºÍ1µÄÎ»ÖÃ£¬ÆäËûµÄÒÔ´ËÀàÍÆ*/
   *p++=num[2*n+1]; 
 } 
 else                                  /*Èç¹ûIsSequeceÎª·Ç¼´·´Ğò´æ·Å*/
 { 
   *p++=num[2*n+1]; 
   *p++=num[2*n]; 
 } 
} 

bool ConvertSegment(int number,int n,char* &p,bool IsLastZiero) 
/*¶¨Òåº¯Êı ConvertSegment
 "ÕûÊıÎ»×ª»»" ½«number×ª»»³ÉÖĞÎÄºó·´Ğò´æÈë×Ö·ûÖ¸Õëp 
numberÎªÄ³ÊıÕûÊı²¿·ÖµÄµÚn½Ú(ÓÉµÍÎ»µ½¸ßÎ»´Ó¸öÎ»¿ªÊ¼Ã¿4Î»ÎªÒ»½Ú,n´Ó0¿ªÊ¼) */
{ 
 char num1[]="  Ê°°ÛÇª"; 
 char num2[]="µãÍòÒÚÕ×"; 

 if(number==0) 
 { 
   if(n==0) 
   { 
     *p++=num2[2*n+1]; 
     *p++=num2[2*n]; 
   } 
   return IsLastZiero; 
 } 

 if(IsLastZiero) 
 { 
   ConvertN(0,p,false); 
 } 

 *p++=num2[2*n+1]; 
 *p++=num2[2*n]; 

 bool flag=true;                      /* Ç°ÃæÊÇ·ñÓĞÁã */
 for(int i=0;number!=0 && i<4;i++) 
 { 
   int m; 
   m=number%10; 
   if(m==0 && !flag) 
   { 
     flag=true; 
     ConvertN(0,p,false); 
   } 
   else if(m!=0) 
   { 
     flag=false; 
     if(i==0) 
     { 
       ConvertN(m,p,false); 
     } 
     else 
     { 
       *p++=num1[2*i+1]; 
       *p++=num1[2*i]; 
       ConvertN(m,p,false); 
     } 
   } 
   number/=10; 
 } 

 if(i>=4) 
   return false; 
 else 
   return true; 

} 

bool ChangeNumber(double dbNumber,char* lpszvalues)  
{ 
 /*¶¨Òåº¯Êı ChangeNumber	
   ÕûÊı²¿·Ö×î¶à8Î»£¬Ğ¡Êı²¿·Ö×î¶à6Î» */
 if(dbNumber<0.0000001 && -dbNumber<0.0000001)                    //ÊıÎ»Ì«Ğ¡ 
 { 
   strcmp(lpszvalues,"Áã"); 
   return true; 
 } 
 if(dbNumber>100000000L || -dbNumber>100000000L)                  //ÊıÎ»Ì«´ó 
   return false; 

 /* ¿ªÊ¼´¦Àí */
 char buf1[50],buf2[50],*p1=buf1,*p2=buf2; /* ½á¹ûµÄÕûÊı²¿·ÖºÍĞ¡Êı²¿·Ö»º³åÇø */
 /* p1ÊÇÕûÊıÖ¸Õë p2ÊÇĞ¡ÊıÖ¸Õë */
 double c=dbNumber; 
 c=c>0?c:-c; 
 /*È¡µÃ´óÊµÊıµÄÕûÊı²¿·ÖºÍĞ¡Êı²¿·Ö²¢·ÇÒ×ÊÂ,longµÄ³¤¶ÈÖ±½ÓÏŞÖÆÁËÕûÊı²¿·ÖµÄ³¤¶È, 
   ³ı·Ç¹¹Ôì³ö¸ü´óµÄÕûÊı»òÖ±½ÓÀûÓÃÊµÊı¼ÆËã,·ñÔòÄÑÒÔ°ìµ½! 
   ´ËÍâÊÜÊµÊı¾«¶ÈµÄÓ°Ïì,ÓĞÊ±»áµ¼ÖÂĞ¡Êı²¿·ÖµÄ»ûĞÎ! 
   ¾«Çë¸ßÊÖÖ¸µã!!! 
 */ 
 unsigned long a=(unsigned long)c;         /*ÕûÊı²¿·Ö*/
 double b=c-a;                             /*Ğ¡Êı²¿·Ö*/
 /*printf("%lu\n",a); 
   printf("%lf\n",b); 
   printf("%lf\n",c);*/
  
 /* ´¦ÀíĞ¡Êı²¿·Ö */
 for(int i=0;i<6;i++) 
 { 
   b*=10;  		/*½«Ğ¡Êı×î¸ßÎ»ÏòÇ°½øÒ»Î»È¡µÃÕûÊı*/
   int n=int(b); 	
   ConvertN(n,p2);    /*×ª»»³É×Ö·ûÊıÖµ*/
   b-=n;      /*¼õÈ¥ÕûÊı²¿·ÖµÄÊıÈ¡µÃÏÂÒ»Î»Ğ¡Êı,½«Æä³ÉÎªÕûÊı*/
 } 
 *p2='\0';

 /* ´¦ÀíÕûÊı²¿·Ö */
 int count=0; 
 bool flag=false; 
 while(a!=0) 
 { 
   int buf=a%10000; 
   flag=ConvertSegment(buf,count++,p1,flag); 
   a/=10000; 
 } 

 /*ÊÇ·ñÓĞ¸ººÅ */
 char *p=lpszvalues; 
 if(dbNumber<0) 
 { 
   strcpy(p,"¸º"); 
   p+=2; 
 } 

 /* Á¬½ÓÕûÊı²¿·ÖºÍĞ¡Êı²¿·Ö */
 p1--; 
 while(p1>=buf1) 
   *p++=*p1--; 
 *p='\0'; 
 strcat(lpszvalues,buf2); 

 return true; 
} 
===========================			 
Ğ¡Ğ´Êı×Ö×ª»»³É´óĞ´Êı×Ö3.txt			 
#include<stdio.h>
void main()
{
double x,y;
char *ch[]={"Áã","Ò¼","·¡","Èş","ËÁ","Îé","Â½","Æâ","°Æ","¾Á"};
char *ch1[]={"Ê°","°Û","Çª","Íò","Ê°","°Û","Çª","ÒÚ"};
char num[256];
long i,n,j,m,y1;
printf("input:");
scanf("%lf",&x);
n=(long)x;/*µÃÕûÊı²¿·Ö*/
y=x-n;/*µÃĞ¡Êı²¿·Ö*/
for(i=0;n!=0;i++)
  {
  num[i]=(char)(n%10);
  n/=10;
  }
m=i;
num[i]='.';
for(y=y*10;(long)((y-(long)y)*10);) /*Èç¹ûĞ¡ÊıÎ»»¹ÊÇÓĞÊı(·Ç0)Ñ­»·¼ÌĞø*/
    y*=10;/*Ğ¡Êı×ª»¯ÎªÕûÊıÈç0.11111×ªÎª11111.00...*/
y1=(long)y;
for(i=m+1;y1!=0;i++)
    {num[i]=(char)(y1%10);
      y1=y1/10;}/*È¡¸÷Î»ÉÏµÄÊı×Ö*/
for(n=0;;n++)
  {
    if(num[n]=='.')
      {
      for(j=n-1;j>=0;j--)/*ÅĞ¶ÏÊÇ·ñÊÇÍòÎ»,ÒÚÎ»..ÈçÊÇÔÙÅĞ¶ÏÊÇ·ñÊÇ0ÈçÊÇ¾Í²»Êä³öÁã.*/
          {
          if(m<=5)
            if(m==5&&(int)num[j]==0)
              ;
            else
                printf("%s",ch[(int)num[j]]);/*Êä³ö´óĞ´Ò¼..*/
          else
            if(m%4==0&&(int)num[j]==0)
                  ;
            else
              printf("%s",ch[(int)num[j]]);
          if(m>=2)
            {printf("%s",ch1[m-2]);/*Êä³öÊ°°ÛÇª..ÈçÓĞ2Î»¾ÍÊä³öÊ°*/
              m=m--;}
          }
      printf("µã");
      break;
      }
  }
  for(i=i-1;num[i]!='.';i--)
    printf("%s",ch[(int)num[i]]);/*Êä³öĞ¡Êı²¿·Ö*/
}  ===========================			 
Ğ¡×Ö¿âDIY-.txt			 
Ğ¡×Ö¿âDIY

ÕâÀïµÄ·½·¨ÊÇ°ÑÅÓ´óµÄÊ®ÁùµãÕó×Ö¿â£¨Ô¼160kB°É£¿£©ÖĞËùÒªÓÃµ½µÄ¼¸Ê®¸öºº×ÖµÄ×ÖÄ£ÌáÈ¡³öÀ´£¬´æ³ÉĞÂµÄÒ»¸öĞ¡×Ö¿â¡£ÕâÑù×öµÄºÃ´¦ÊÇ£º

1,¿Õ¼äÒªÇóĞ¡¡£ÎÒÏÂÃæÕâ¸ö³ÌĞòµÃµ½µÄxzku.datÖ»ÓĞ1kB×Ö½Ú£¬¼¸ºõËõĞ¡ÁË160kB¡£ ÔÚ¹¤Òµ¿ØÖÆÉÏÓĞÊ±Õâµã¿Õ¼äÊÇÖÂÃüµÄ¡£ 

2,³ÌĞò±£ÃÜ£¬ÈÃÈË²»ÖªËùÔÆ¡£

3,ÊµÏÖËÙ¶È¿ì¡£Ö÷ÒªÊÇfseekÓï¾ä½ÚÊ¡Ê±¼ä£¬µ«±íÏÖ³öÀ´µÄËÙ¶È¿ìÁËÒ»°ë¶à¡£ 



/*MAKE ×ÔÔì×Ö¿â MAKE*/

main()
{FILE *zkfp, *zk1fp;
 unsigned char *s[S_NUMBER];
 int len[S_NUMBER], i, j, m;
 int qu, wei, l;
 long offset;
 int a[ZISHU], number = 0, xn;
  s[0] = "×ÔÔìĞ¡×Ö¿âÏÔÊ¾Èí¼ş";
  s[1] = "°ÑËùÓÃµ½µÄºº×Ö×ÖÄ£ÌáÈ¡³öÀ´ÖØĞÂ×é³ÉĞ¡×Ö¿â£¬";
  s[2] = "Ê¹ÓÃÊ±¼´¿É°ÑÔ­×Ö¿âÅ×¿ª¡£";
  s[3] = "Ô¸Óë¸÷Î»ÅóÓÑÉÌÈ¶¡£";
  s[4] = "»¶Ó­³£µ½ËÉÊóÖ®¼ÒÀ´";
  s[5] = "ËÉÊó°İÉÏ¡£";
 zk1fp = fopen("c:\xzku.dat", "wb");
 zkfp = fopen("c:\hzk16", "rb");
 if (zkfp == NULL) {printf("Can't open the cclib");
		  exit(0);
		  }
 for(i = 0; i < s_number; i++)
	{while(*s[i])
		{
		qu = *(s[i]++)-0xa0; 
		wei = *(s[i]++)-0xa0; 
		l = qu*94+wei; 
		for(j = 0; j < number&&a[j] != l; j++); 
		if(j!=number) 
			continue; 
		a[number++] = l; 
		offset = (94l*(qu-1)+(wei-1))*32l;
		fseek(zkfp, offset, SEEK_SET); 
		for(m = 0;m <32;m++) 
			putc(getc(zkfp), zk1fp);  
		}
	}
 fclose(zkfp); 
 fclose(zk1fp); 
 printf("\nOK!\n");
 } 
 
Õâ½ö½öÊÇ×öĞ¡×Ö¿âµÄ³ÌĞò¡£ÏÔÊ¾µÄ³ÌĞòÖ»Òª¸ù¾İÕâ¸öË¼Â·£¬¾ÍÄÜ×ö³öÀ´¡£Ö÷Òª¾ÍÊÇÓÃ¡°for(j=0;j < number&&a[j]!=l;j++);¡±À´¿ØÖÆ²»ÒªÓĞÖØ¸´µÄ×ÖÄ£¡£ ¼¼ÇÉÔÚÓÚ¿ØÖÆÁ½¶Î³ÌĞòºº×Ö³öÏÖµÄË³Ğò¡£===========================			 
Ğ¡×Ö¿âDIY.txt			 
ÓĞÒ»¶ÎÊ±¼äÖ±½Ó¶ÁÈ¡ºº×Ö¿â£¬ÒÔÆÚ²»ÓÃºº×ÖÏµÍ³Ò²ÄÜÏÔÊ¾ºº×Ö£¬ÊÇºÜÁ÷ĞĞµÄ¼¼Êõ£¬ÏÖÔÚÒ²¾ÍÔÚ¹¤¿ØĞĞÒµÓÃµÃÉÏÁË¡£ÕâÊÇÓ²¼ş·¢Õ¹¡¢´óËÁÀË·ÑÄÚ´æµÄ½á¹û¡£ÔİÇÒ²»ÂÛ£¬ÈÃÎÒÃÇ¿´¿´ºº×Ö¿â¡£
16X16µãÕóµÄ×Ö¿â°´ÕÕÄÚÂëË³ĞòÅÅÁĞ£¬Ã¿¸ö×ÖÓÃ32×Ö½Ú£¨256BIT£©´æ·ÅµãÕóĞÅÏ¢¡£¸ñÊ½ÈçÏÂ£º

                 µÚÒ»×Ö½ÚµÚ¶ş×Ö½Ú
                 µÚÈı×Ö½ÚµÚËÄ×Ö½Ú
                 µÚÎå×Ö½ÚµÚÁù×Ö½Ú
                 µÚÆß×Ö½ÚµÚ°Ë×Ö½Ú



Äã¿´³ÌĞò°É£¬ºÜÇå³şµÄ¡£
µ«ÊÇ£¬ÓÖ²»ÊÇÃ¿¸ö×Ö¿â¶¼Ò»Ñù¡£¿ÉÄÜÊÇÒòÎªÓĞĞ©×Ö¿â°ÑÓ¢ÎÄ×ÖÄ£Ò²·ÅÔÚÒ»Æğ°É¡£ÎÒËùÓÃµÄÊÇUCDOSµÄ×Ö¿â


#include < io.h>
#include < fcntl.h>
#include < stdio.h>
#include < dos.h>
#define CCLIB "c:\hzk16"

display(unsignedchar *hzmp, int x, int y, int color, int bkcolor)
 { charfar *p; 
 int i, j, k;
 p= (char far *)(0xa0000000+80*y+x/8); 
 for (i= 0; i < 16; i++) 
	for(j = 0; j < 2; j++)
	 { outport(0x3ce, 0x0205);	// kernel here
		k=*(p+80*i+j);
		outportb(0x3ce, 0x08); 
		outportb(0x3cf, hzmp[2*i+j]); 
		*(p+80*i+j)=color; 
		k=*(p+80*i+j);
		outportb(0x3ce, 0x08); 
		outportb(0x3cf, ~hzmp[2*i+j]); 
		*(p+80*i+j)=bkcolor;
		} 
outport(0x3ce, 0x005);	//reset
outport(0x3ce, 0xff08); 
} 

main()
{
 union REGS r;
 int handle, mode;
 int i;
 int qh, wh, col, row;
 long offset;
 unsigned char *hz, hzm[32];
 handle=open(CCLIB, O_RDONLY|O_BINARY);
 r.h.ah=0x0f;int86(0x10, &r, &r);
 mode=r.h.al;
 r.x.ax= 0x0012; 
 int86(0x10, &r, &r);
 for(i=0; i < 20; i++){
	 col=0;row=20*i; 
	 hz="Ï£ÍûµçÄÔ¹«Ë¾£ºÎªÁË¼ìÑé´Ë³ÌĞòµÄÖ´ĞĞËÙ¶ÈÌØÒâÈç´Ëµ«ÊÇÃ»ÓĞ±êµã·ûºÅÕâÀïÊÇĞ´×ÖÈí¼ş"; 
	 
	while(*hz){ /*find theqh, wh*/
		 qh = *hz-0xa0;
		 wh = *(hz+1)-0xa0;
		 offset = (94l*(qh-1)+(wh-1))*32l;
		 lseek(handle, offset, SEEK_SET); 
		 read(handle, hzm, 32);/*display*/
		 display(hzm, col, row, 4, 3);
		 col += 16;
		 hz += 2; 
	 } 
 } 
 r.h.ah=0x00;
 r.h.al= mode;
 int86(0x10, &r, &r);
 } 


===========================			 
Ğ¡º¢·ÖÌÇ¹û.txt			 
/*10¸öĞ¡º¢·ÖÌÇ¹ûsweer[10]*/
#include <stdio.h>
int j=0;
main()
{
static int sweet[10]={10,2,8,22,16,4,10,6,14,20};//³õÊ¼»¯Êı×é
int i,t[10],l;
printf("               child\n");
printf("round  1   2   3   4   5   6   7   8   9   10 \n");
printf("------------------------------------------------\n");
print(sweet);
while(judge(sweet))
{
for(i=0;i<10;i++)
  if(sweet[i]%2==0)
    t[i]=sweet[i]=sweet[i]/2;      //ÎªÅ¼ÊıÊ±Ö±½Ó·Ö³öÒ»°ë
  else
    t[i]=sweet[i]=(sweet[i]+1)/2;  //ÎªÆæÊıÊÇ¼Ó1ºóÔÙ·Ö³öÒ»°ë
  for(l=0;l<9;l++)
    sweet[l+1]=sweet[l+1]+t[l];
  sweet[0]+=t[9];
  print(sweet);
}
}

judge(c)
  int c[];
{
int i;
  for(i=0;i<10;i++)
    if(c[0]!=c[i])return(1);
  return(0);
}

print(s)
  int s[];
{
int k;
printf(" %2d ",j++);
for(k=0;k<10;k++)
  printf("%4d",s[k]);
printf("\n");
}===========================			 
Ğ¡Ã÷ÂòÊé.txt			 
#include<math.h>
main()
{
	int d[6],m,i,j,m;
	long b[63],flag;
	float c[6],min,x;
        printf("ÇëÊäÈë±³°ü¿É×°µÄÖØÁ¿");
        scanf("%d",&m); 
	printf("ÇëÊäÈëÁù¸öÎïÌåµÄÖØÁ¿ ");
	for(i=0;i<6;i++)                   /*ÊäÈëÁù¸ö¸¡µãÊı*/
		scanf("%f",&c[i]);
	for(i=0,min=-1,d[0]=0;d[0]<2;d[0]++) /*½¨Á¢Áù¸öÊıµÄÈ«²¿×éºÏ²¢´¦Àí*/
		for(d[1]=0;d[1]<2;d[1]++)        /*i:²îÖµ¾ßÓĞmin×éºÏµÄÊıÁ¿*/
			for(d[2]=0;d[2]<2;d[2]++)    /*min:Óë10µÄ×îĞ¡²îÖµ*/
				for(d[3]=0;d[3]<2;d[3]++)/*d[]:×éºÏÊ±ÊÇ·ñÈ¡¸ÃÊıµÄ±êÖ¾*/
					for(d[4]=0;d[4]<2;d[4]++)
						for(d[5]=0;d[5]<2;d[5]++)
						{
							for(flag=0,x=0.,j=5;j>=0;j--)/*flag:½«Áù¸öÊıµÄ×éºÏÓÃ¶ÔÓ¦µÄÒ»¸öÊ®½øÖÆÎ»±íÊ¾*/
							{x+=c[j]*d[j];flag=flag*10+d[j];}/*x:¶ÔÓ¦Áù¸öÊıµÄ×éºÏµÄºÍ*/
							x=((x-m>0)?x-m:m-x);          /*x:×éºÏµÄºÍÓë10µÄ²î*/
							if(min<0)
							{
								min=x;          /*¶ÔµÚÒ»´Î¼ÆËã³öµÄ²îmin½øĞĞ´¦Àí*/
								b[i++]=flag;    /*b[]:¼ÇÂ¼ÓĞÏàÍ¬minµÄflagµÄÊı×é i:b[]Êı×éµÄÏÂ±ê*/
							}
							else if(min-x>1.e-6)/*¶ÔĞÂµÄminµÄ´¦Àí*/
							{
								min=x;
								b[0]=flag;
								i=1;
							}
							else if(fabs((double)x-min)<1.e-6)/*ÏàµÈµÄminµÄ´¦Àí*/
								b[i++]=flag;
						}
						for(m=0;m<i;m++)      /*Êä³öÈ«²¿i¸öÓë10µÄ²îÖµ¾ùÎªminµÄ×éºÏ*/
						{
							printf(" 10(+ -)%.2f=",min);
							for(flag=b[m],j=0;flag>0;j++,flag/=10)
								if(flag%10)  /*½«b[]ÖĞ´æµÄ±ê¼Çflag»¹Ô­Îª¸÷¸öÊıµÄ×éºÏ*/
									if(flag>1)
										printf("%.2f+",c[j]);
									else
										printf("%.2f\n",c[j]);
						}
}===========================			 
Ğ¡°×Êó×êÃÔ¹¬.txt			 
ÕâÊÇ¸ö¾­µäµÄÊıÑ§ÎÊÌâ£¬ËµµÄÊÇ£ºÔÚÒ»¸öËæ»úµÄÃÔ¹¬Àï£¬Ğ¡°×ÊóÈçºÎÄÜ×î¿ìµØ´ÓÆğµã×ßµ½ÖÕµã¡£

-# --------###       #     ## # #   ### 
----#  # #-##  #     # # ####   #### #  
  ## ##  #-#   ##  #    # # #---# ##  #
##    # #    # #  -#   ### ## ####    ##
# #   ----#  # #  ##  #  # # ##   ### ##
-# --#   ---###   -*  #     ## # #   ### 
----#  # #-##  #     # -----###   #### #  
  ## ##  #-#   ##  #    # # #---# ##  #
##    # #    # #  -#   ### ## ####    ##
# #   ----#  # #  ##  #  # # ##   ### ##
 
°´ÉÏÍ¼£¬ÀÏÊóÓÃ¡°*¡±À´±íÊ¾£¬ÒªÇó´ÓÃÔ¹¬µÄ×óÉÏ½ÅÑ¡ÔñÒ»ÌõÂ·¾¶£¬ÅÜµÀÓÒÏÂ½ÅµÄ³ö¿Ú¡£Ò²ĞíÓÃÉñ¾­ÍøÂç¡¢ÓÃÒÅ´«Ëã·¨Ö®ÀàÄÜÕÒµ½Ò»¸ö×î¼ÑµÄ×ö·¨£¬µ«ÎÒÕâ¸ö³ÌĞòÊÇ»ùÓÚ¶ÔÃÔ¹¬ÍêÈ«ÎŞÖª£¬¶øÇÒÃ»ÓĞÊÔÑéµÄÕâ¸öÇ°Ìá£¬ËùÒÔÎÒÖ»ÄÜ²ÉÓÃ×î»úĞµµÄ°ì·¨£ºÃ¿ÌõÂ·¶¼ÊÔÌ½¡£¾ßÌåÊÇÕâÑùµÄ£ºÏò×ó¿´¿´£¬ÄÜ·ñ¹ıÈ¥¡£Ö»Òª×óÃæ²»ÊÇÇ½£¬¾Í×ßµ½³öÒ»²½¡£Èô×óÃæ²»ÄÜ¹ıÈ¥£¬¿´ÏÂÃæ£¬ÔÙ¿´ÓÒÃæ...ÈôÈı¸ö·½Ïò¶¼²»ÄÜ¹ıÈ¥£¬Ö»ÄÜ»Øµ½ÉÏÒ»²½£¬ÖØ¸´¸É...
³ÌĞò²¢²»³¤£¬µ«ËüÔÚËÄÄêÇ°·ÑÁËÎÒÒ»¸öĞÇÆÚµÄËùÓĞÊ±¼ä£¨°üÀ¨ÉÏ¿Î :-)£©¡£Ò»Ö±ÔÚÎÒ´ÅÅÌÀï·Å×Å£¬²»ÄÃ³öÀ´·ÖÏí£¬¹Ö¿ÉÏ§µÄ¡£Äã¿´¿´ÄÜ²»ÄÜÕÒµ½¸üºÃµÄ°ì·¨£¿Íû½»Á÷¡£

×¢ÊÍÒ»£ºÄãÄÜ¿´¼ûÃÔ¹¬¼¸ºõÍêÈ«ÊÇËæ»úµÄ£¬µ«ÎªÁË±£Ö¤Ò»¶¨ÓĞÒ»ÌõÍ¨µÀ£¬ÎÒÔÚÆğµãºÍÖÕµã¸½½ü¸÷·ÅÁË¾Å¸ö¿ÉÒÔÍ¨ĞĞµÄµã¡£²»Ëã×÷±×°É¡£
×¢ÊÍ¶ş£ºÑ­»·ÀïÃæµÄÑÓÊ±¶ÔÓÚPENTIUM¼¸ºõÒ»µã×÷ÓÃ¶¼Ã»ÓĞ¡£ËùÒÔÔËĞĞÊ±Äã»òÕßÑ¡ÓÃ STEP£¬»òÕß°ÑÑÓÊ±Ìá¸ßÒ»µã£¬²ÅÄÜ¿´ÇåĞ¡°×ÊóÊÇÈçºÎÂõÏòÇ°Í¾Î´²·µÄĞÂÒ»²½£¬ÓÖÊÇÈçºÎÃÔÍ¾Öª·µ£¬ÖØĞÂÉóÊÓ×Ô¼ºµÄ²½·¥¡£
×¢ÊÍÈı£ºÕâ¸ö³ÌĞòµÄ¼¼ÇÉºÜºÃ£¬µ«ÍêÈ«Ã»ÓĞ×¢ÊÍ£¬·ç¸ñÒ²²»Ì«ºÃ£¬µ«ÕâÕıÊÇ¼¸ÄêÇ°ÎÒµÄ±ê×¼µÄ³ÌĞò£¬ËùÒÔÏÖÔÚÎÒÒ²²»¸Ä£¬Ö±½ÓÄÃ³öÀ´£¬½ö¹©Ò»Óé¡£
×¢ÊÍËÄ£º³ÌĞòÓÃTC²ÅÄÜ±àÒë¡£VC£¬±ê×¼CÖĞÃ»ÓĞ¡°gotoxy¡±µÈº¯Êı¡£µ±È»£¬ÕâÖ»Ó°Ïì½çÃæÏÔÊ¾£¬²»Ó°ÏìÎÒÃÇÀÏÊóĞĞ×ßµÄËã·¨¡£

Äú»¹¿ÉÒÔÖ±½ÓÏÂÔØÒÑ±àÒëºÃµÄ³ÌĞòmaze.exe 
--------------------------------------------------------------------------------
Ô´³ÌĞòÈçÏÂ£º


#include < stdlib.h>
#include < time.h>
#include < stdio.h>
#include < conio.h>
main()
{int x,y,a[72][22];
 char o;
 int c,d,four,k=0,i,end,step;
 randomize();
/* printf("Do you want it run or step?(0/1)");
 scanf("%d",&step);*/
 clrscr();
 for(x=0;x < 72;x++){
    for (y=0;y <  22;y++){
        if ((y==0)||(x==0)||(x==71)||(y==21)) {
            a[x][y]=11;
            continue;}
        if (random(3)==0) {
            a[x][y]=11;
            gotoxy(x,y);
            printf("#");
            }
        else
            a[x][y]=1;
    }
}

for(y=1;y <  10;y++)
    { a[1][y]=1;
    gotoxy(1,y);
    printf(" ");
    a[70][21-y]=1;
    gotoxy(70,21-y);
    printf(" ");
}
x=1;
y=1;
end=0;
gotoxy(1, 23);
printf("Step?(1/0) ");scanf("%d", &step);
//Above is to prepare the Maze. Now, our little mouse is comming.

while((x < 70)||(y < 20)) {

    c=x;d=y;four=0;
    do{
        k++;
        if ((a[x+1][y]==1)||((a[x+1][y]%7==0)&&(a[x][y]%2!=0)&&(four==1)))
        {
            a[x][y]=a[x][y]*2;
            x=x+1;
            break;
        }
        if ((a[x][y+1]==1)||((a[x][y+1]%5==0)&&(a[x][y]%3!=0)&&(four==1)))
        {
            a[x][y]=a[x][y]*3;
            y=y+1;
            break;
            }
        if ((a[x][y-1]==1)||((a[x][y-1]%3==0)&&(a[x][y]%5!=0)&&(four==1)))
        {
            a[x][y]=a[x][y]*5;
            y=y-1;
            break;}
        if ((a[x-1][y]==1)||((a[x-1][y]%2==0)&&(a[x][y]%7!=0)&&(four==1)))
            {a[x][y]=a[x][y]*7;
            x=x-1;
            break;
        }
        four++;
        if (four == 2){
            gotoxy(25, 23); printf("Cannot go out!");
            end=1;
            break;}

        if (k>3000) {
            gotoxy(30, 23); printf("Too long!");
            end=1;
            break;}
     }while(1);
     if (end==1) break;
    /* gotoxy(x,y);printf("*");*/
     gotoxy(c,d);printf("-");
     gotoxy(16, 23); printf("step:%d ", k);
     gotoxy(x,y); printf("*");
     if (step==1) getch();
 }/* no end point*/
 if (end==1) printf("Error.");
 else printf("ok!");
 getch();
}/*end main()*/


¿´¶®³ÌĞòÁËÂğ£¿µ±Ê±ÎÒ·¢ÏÖ±ØĞëÓÃÒ»Ğ©¶«Î÷À´¼ÇÂ¼ÀÏÊóµÄÀúÊ·£¬¼´ÒªÖªµÀÔÚ¸ÃµãÊÇ·ñÒÑ¾­ÏòÓÒ×ß¹ı£¿ÊÇ·ñÏò×ó×ß¹ı£¿ÓÃÁË4ÌìÄÔ´üÀïÌø³ö¡°ËØÊı¡±ÕâÑùÒ»¸öÓÆ¾ÃµÄÃû´Ê£¬ÓÚÊÇÒ»ÇĞ¾ÍË®µ½Çş³ÉÁË£¡
ÔÚDo-WhileÖĞµÄµÚÒ»¸öifµÄÒâË¼ÊÇ£ºÈç¹ûÓÒ±ßµÄ·½¸ñÊÇÈç¹û´ÓÎ´×ß¹ıµÄ¿ÕµØ£¨ÖµÎª1£©£¬×ß¹ıÈ¥¡£µ«ÊÇ£¬Èç¹ûÉÏÏÂ×óÓÒ¶¼Ã»ÓĞÖµÎª1µÄ¿ÕµØ£¬¾Í±ØĞë¿¼ÂÇÍËÂ·ÁË¡£ÕâÊ±four==1£¬²é¿´Ò»ÏÂÎÒÊÇ·ñÒÑ¾­×ß¹ıÕâ¸öµØ·½ (a[x][y]%2!=0)£¿ÎÒÊÇ·ñ´ÓÄÇÀï¹ıÀ´µÄ(a[x+1][y]%7==0)£¿Ò²¾ÍÊÇËµµ±four==4Ê±ÎÒÖ»×ß»ØÍ·Â·¡£

ÄãµÄ³ÌĞò»á²ÉÈ¡ÕâÖÖ²ßÂÔÂğ£¿ ===========================			 
´øÍ·½áµãË«Á´Ñ­»·ÏßĞÔ±í.txt			 
#define  null  0
  typedef char data;
  typedef  Struct  dulistnode{
  DataType  data;
  Struct  dulistnode  *prior, *next;
}dulistnode
typedef Dulistnode  *Dulinklist;
 Status  InitList_DuL( DuLinkList L ) {
	 If  (!(p = GetElemP_DuL (L ) ))
	   Return  ERROR;					     
	 p->prior = p->next ;
	 p->next = p->prior ;
	 return OK;
} //InitList_DuL
Status  DestroyList_DuL ( DuLinkList &L ) {
		 while  ( L.front ) {
	    L.rear = L.front->next;
		Free  ( L.front );
		L.front = L.rear ;
	 }
	 return OK;
} // DestroyList_DuL
Status  ClearList_DuL ( DuLinkList &L ) {
	 L=Null;
} // ClearList_DuL
Status  ListEmpty_DuL ( DuLinkList L ) {
		 if  ( L.front = = L.rear ) return TRUE;
	 p = L.front->next ;
	 if  (L.rear = = p ) L.rear = L.front ;
	 free  ( p );
	 return FALSE;
} // ListEmpty_DuL
Status  ListLength_DuL ( DuLinkList L ) {
		 int  DuLinkListLength ( sqDuLinkList L ) {
	 return  ( L.rear - L.front + MAXLSIZE )%MAXLSIZE;
	 }
} // ListLength_DuL

Status  GetElem_DuL ( DuLinkList &L, int i, ElemType &e ) {
if  ( ! ( p = GetElemP_DuL ( L, i ) ) )			
	 return  ERROR;						
	 e = p->data;
     return OK
} // GetElem_DuL

Status  LocateElem_DuL ( DuLinkList L, ElemType e, Position &q, int (* compare )  ( ) ) {
} // LocateElem_DuL

Status  PriorElem_DuL ( DuLinkList L, int i, int j, ElemType cur_e, ElemType &pre_e ) {
	 if  ( ! ( p = GetEleP_DuL (L, i ) , 1<i<=length) )		
       return  ERROR;                          
if  ( !(q = GetElemP_DuL (L, j ) ) )		    
	 cyr_e = p->data;
	 pre_e = q->data;
     p->prior = q;
	 q->next = p;
	 return OK;
} // PriorElem_DuL
Status  NextElem_DuL ( DuLinkList L, int i, int j ElemType cur_e, ElemType &next_e ) {
	 if  ( ! ( p = GetEleP_DuL (L, i ) , 1<i<=length) )		return  ERROR;                          
if  ( !(q = GetElemP_DuL (L, j ) ) )		    
	 cyr_e = p->data;
	 next_e = q->data;
     p->next = q;
	 q->prior = p;
	 return OK;

} // NextElem_DuL

Starus  ListInsert_DuL ( DuLinkList &L, int i,ElemType e ) {
if  ( !(p = GetElemP_DuL (L, i ) ) )		
	   return  ERROR;				
	 if  (!(s = ( DuLinkList ) malloc ( sizeof ( DuLNode ) ) ) ) return ERROR;
	 s->data = e;
	 s->prior = p->prior; p->prior->next = s;
	 s->next = p;		  p->prior = s;
	 return OK;
} //ListInsert.DuL

Status  ListDelete_DuL ( DuLinkList &L, int I, ElemType &e ) {
	 if  ( ! ( p = GetElemP_DuL ( L, i ) ) )
	   return  ERROR;			
	 e = p->data;
	 p->prior->next = p->next;
	 p->next->prior = p->prior;
	 free ( p ); return OK;
} //ListDelete_DuL

Status  ListTraverse_DuL ( DuLinkList L, int i, visit ( ) ) {
} // ListTraverse_DuL
main( )
{struct  Lnode  *head, *q;  char  e, y;  int  i, n;  int  select, x1, x2, x3, x4, m, g;
head=setnull(&head);
printf("ÇëÊäÈëÊı¾İ³¤¶È:  ");
scanf("%d",  &n);
for(i=1; i<n; I++)
{printf("½«Êı¾İ²åÈëµ½µ¥Á´±íÖĞ:  ");
 scanf("%d",  &y);
 insert(&head,  y,  i);
}
display(&head);
printf("select  1 Çó³¤¶È  length()\n");
printf("select  2 È¡½áµã  get()\n");
printf("select  3 ÇóÖµ²éÕÒ locate()\n");
printf("select  4 É¾³ı½áµã delete()\n");
printf("input  your  select :  ");
scanf("%d",  &select);
 switch(select)
  { case  1 :{x1=length(&head);
           printf("Êä³öµ¥Á´±íµÄ³¤¶È:  ",  x1);
           display(&head);
          }
   case  2 :{printf("ÇëÊäÈëÒªÈ¡µÄ½áµã:  ");
           scanf("%d,  &m");
           x2=get(&head,   m);
           printf(x2);
          display(&head);
         }
   case  3 :{printf("ÇëÊäÈëÒª²éÕÒµÄÊı¾İ:   ");
           scanf("%d",  &e);
           x3=locate(&head,  e);
           printf(x3);
           display(&head);
          }
   case  4 :{printf("ÇëÊäÈëÒªÉ¾³ıµÄ½áµã:  ");
           scanf(%d,  &m);
           x4=delete(&head,  m);
           printf(x4);
           display(&head);
          }
}===========================			 
Æ½·½¸ù.txt			 
#define Epsilon 1.0E-6  /*¿ØÖÆ½âµÄ¾«¶È*/ 
#include <stdio.h>
#include <math.h> 

main() 
{
	float num,pre,this; 
 	do 
	{   
 		scanf("%f",&num);/*ÊäÈëÒªÇóÆ½·½¸ùµÄÊı*/ 
	}while(num<0); 
	if (num==0) 
 		printf("the root is 0"); 
	else 
	{
		this=1; 
  		do
  		{ 
  			pre=this;
   			this=(pre+num/pre)/2; 
		}while(fabs(pre-this)>Epsilon);/*ÓÃ½âµÄ¾«¶È£¬¿ØÖÆÑ­»·´ÎÊı£¬fabs()ÊÇÇó¾ø¶ÔÖµµÄº¯Êı*/ 
	} 
	printf("the root is %f",this); 
} ===========================			 
½¨Ê÷ºÍ±éÀú.txt			 
/*ÕâÊÇÎÒÔÚÕâÀï°ïÂä³¾¸ÄĞ´µÄ³ÌĞò£¬½ñÌìÓÖ°ÉËü¸ÄĞ´³ÉÁËcµÄ
½è¼øÒ»ÏÂ°É*/
#include <stdio.h>
#include <malloc.h>

typedef struct node{ 
int data; 
struct node *lchild,*rchild; 
}*treetp,tree; 
treetp create (treetp t,int c); 
void print1(treetp); 
void print2(treetp);
void print3(treetp);
int number=0;
void main() 
{
  treetp t=0,r; 
  r=create (t,0); 
  printf("Ç°ĞòÅÅÁĞ £º");
  print1  (r); 
  printf("\nÖĞĞòÅÅÁĞ £º");
  print2 (r);
  printf("\nºóĞòÅÅÁĞ £º");
  print3 (r);
} 

treetp  create(treetp t,int c) 
{ 
treetp p,di; 
do{ 
scanf("%d",&c); 
if (t==0) 
 { 
 t=(treetp)malloc(sizeof(tree)); 
 t->lchild=t->rchild=0; 
 t->data=c; 
 } 
else 
 {   p=t; 
  while(p!=0) 
  { 
  di=p; 
  if(c<(p->data)) 
  p=p->lchild; 
  else 
  p=p->rchild; 
  } 
if(c<(di->data)) 
{ 
treetp NEWdi=(treetp) malloc(sizeof(tree)); 
NEWdi->lchild=NEWdi->rchild=0; 
NEWdi->data=c; 
di->lchild=NEWdi; 
} 
else 
{ 
treetp NEWdi=(treetp) malloc(sizeof(tree)); 
NEWdi->lchild=NEWdi->rchild=0; 
NEWdi->data=c; 
di->rchild=NEWdi; 
} 
 } 
++number;
}while(c!=0); 
printf("Ò¶×ÓµÄÊıÁ¿£º%d",number);
return t;
}   
void print1(treetp  t) 
{ 
   if (t!=0) 
  {     
   printf("%d ",t->data);
   print1(t->lchild); 
   print1(t->rchild); 
   } 
} 
void print2(treetp  t) 
{ 
   if (t!=0) 
  {     
   print2(t->lchild); 
   printf("%d ",t->data); 
   print2(t->rchild); 
   } 
} 
void print3(treetp  t) 
{ 
   if (t!=0) 
  {     
   print3(t->lchild);  
   print3(t->rchild); 
   printf("%d ",t->data);
   } 
} ===========================			 
/* Á´±í½¨Á¢³ÌĞò */

#include"stdio.h"
#include<malloc.h>

#define NULL  0
#define LEN sizeof(struct student)

struct student
{long num;
int score;
struct student *next;
};
int n; /*È«¾Ö±äÁ¿n*/
struct student *creat()
{struct student *head;
  struct student *p1,*p2;
  n=0;
  p1=p2=(struct student *)malloc(LEN);
  scanf("%ld%d",&p1->num,&p1->score);/*%dºÍ%dÖ®¼ä²»Ó¦¸ÃÓĞ¶ººÅ*/
  head=NULL;
  while (p1->num!=0)
    {n=n+1;
    if(n==1) head=p1;
    else p2->next=p1;
    p2=p1;
    p1=(struct student*)malloc(LEN);
    scanf("%ld%d",&p1->num,&p1->score);
    }
    p2->next=NULL;
    return(head);
  }
void print(head)
struct student *head;
{struct student *p;
  p=head;         /*ÔÚÕâÀï¸¶Öµ²Å¿ÉÒÔ*/
  printf("\Now,These %d records are:\n",n);
  if(head!=NULL)
  do
  {printf("%ld%5d\n",p->num,p->score);
  p= p->next;
  } while(p!=NULL);
}
void main()
{struct student *head;
printf("input records:\n");
head= creat();
print(head);
}½¨Á¢Á´±í1.txt			 
===========================			 
#include<stdio.h>
#include<bios.h>

int specialkey(int key[]);

main()
{
  int key[2]={0,0};
  printf("É¨ÃèÂë  ASC¢òÂë\n");
  for(;;)
    {
      specialkey(key);
      if(key[0]||key[1])
	{
	  printf("  %d      ",key[0]);
	  printf("%d \n",key[1]);
	  if(key[0]==1)exit(1);
	}
    }
}

specialkey(int key[2])
{
  if(bioskey(1)){key[0]=0;key[1]=0;return;}
  key[0]=key[1]=bioskey(0);
  key[0]>>=8;
  key[1]&=0xff;
}É¨ÃèÂë.txt			 
===========================			 
Íì¾ÈÈíÅÌ.txt			 
/* ÈíÅÌµÄFAT±í(ÎÄ¼ş·ÖÅä±í)±»Ëğ»µÊ±,¼ÆËã»ú¾Í²»ÄÜ´ÓÈíÅÌÉÏ¶ÁÈ¡Êı¾İ¡£ 
µ«ÊÇ,ÔÚÈíÅÌÖĞÓĞÁ½·İÍêÈ«ÏàÍ¬µÄÎÄ¼ş·ÖÅä±í,¶øDOSÔÚ¶ÁÎÄ¼şÊ±²¢²»Ê¹ÓÃ 
µÚ¶şÕÅÎÄ¼ş·ÖÅä±í,Òò´Ë,Ëü±»Ëğ»µµÄ¿ÉÄÜĞÔ½ÏµÍ¡£ÔÚ¼ÆËã»úÌáÊ¾FAT±íËğ 
»µÊ±,ÀûÓÃµÚ¶şÕÅ·ÖÅä±íÖØĞ´µÚÒ»ÕÅÎÄ¼ş·ÖÅä±í,ÍùÍùÄÜ³É¹¦µØÍì»ØÄãµÄÈí 
ÅÌÉÏµÄÊı¾İ¡£ÎÄ¼ş·ÖÅä±íÔÚ´ÅÅÌÖĞµÄ¾ßÌåÎ»ÖÃ¼°³¤¶ÈÊÓ´ÅÅÌµÄ¹æ¸ñ²»Í¬¶ø 
²»Í¬¡£ 
    ±¾ÎÄÌá¹©µÄ³ÌĞò,ÓÃTurbo C 2.0±àĞ´,ÓÚDos6.22,UCDOS 3.1ÏÂÍ¨¹ı¡£ 
°´ÕÕ³ÌĞòµÄÌáÊ¾,¿É·½±ãµØÍê³ÉÕâÒ»¹¤×÷¡£ */
    #include [dos.h] 
    main () 
      {int i,j,dh,ch; 
      a: printf ("Select drive/Ñ¡¶¨Çı¶¯Æ÷: (0->A/1->B) \n"); 
      scanf(" %d",&ch); 
      if (1       goto a; 
      printf ("Slect disk/Ñ¡¶¨´ÅÅÌÀàĞÍ:"); 
    printf(" (36->360KB/72->720KB/12->1.2MB/14->1.44MB) \n"); 
      scanf(" %d" ,&dh);/*°´Ñ¡¶¨µÄÈíÅÌÀàĞÍ½øĞĞ´¦Àí*/ 
      switch (dh) 
      {case 36:/*´¦Àí360KBÈíÅÌ*/ 
        for (i=1; i<3;i++) 
         {j=j+2 
           absread(ch,1,j,0); 
           abswrite (ch,1,i,0);} 
         break; 
       case 72: /*´¦Àí720KBÈíÅÌ*/ 
         for (i=1; i<4; i++) 
           {j=i+3; 
            absread (ch,1,j,0); 
            abswrite(ch,1,i,0);} 
         break; 
       case 12: /*´¦Àí1.2MBÈíÅÌ*/ 
         for (i=1; i<8; i++) 
            {j=i+7; 
             absread (ch,1,j,0); 
             abswrite (ch,1,i,0); 
            } 
         break; 

       case 14: /*´¦Àí1.44MBÈíÅÌ*/ 
         for (i=1; i<10; i++) 
            { 
             j=i+9; 
             absread (ch,1,j,0); 
             abswrite (ch,1,i,0); 
            } 
         break; 
        } 
        printf ("OK!"); 
      } ===========================			 
#include <stdio.h>

void move(char x,char y) 
{printf("%c-->%c\n",x,y);} 
void hanoi (int n,char one ,char two,char three) 
{
if(n==1) move (one ,three); 
else 
{
hanoi (n-1,one,three,two); 
move(one,three); 
hanoi(n-1,two,one,three); 
} 
} 
main() 
{int m; 
printf("input the number of diskes:"); 
scanf("%d",&m); 
printf("the step to moving %3d diskes:\n",m); 
hanoi(m,'A','B','C'); 
} 
/*ÔËĞĞÇé¿öÈçÏÂ£º 
input the number of diskes:3 »Ø³µ 
the step to moving 3 diskes: 
A-->C 
A-->B 
C-->B 
A-->C 
B-->A 
B-->C 
A-->C 

ÊéÉÏËµhanoi(n-1,one,three,two);ÊÇ°Ñ¡°one¡±ÉÏµÄn-1¸öÍù¡°two¡±ÉÏÒÆ£¬½Ó×Åmove(one,three);È»ºóÊÇhanoi(n-1,two,one,three)¼´°Ñ¡°two¡±ÉÏµÄn-1¸öÍù¡°three¡±ÉÏÒÆ£»
           |h(2,1,3,2)|h(1,1,2,3)=>move(1,3)   <-----1------ 
           |          |  move(1,2)             <-----2------ 
           |          |h(1,3,1,2)=>move(3,2)   <-----3------ 
           |move(1,3)                          <-----4------ 
           | 
h(3,1,2,3) |          |h(1,2,3,1)=>move(2,1)   <-----5------ 
           |h(2,2,1,3)|move(2,3)               <-----6------- 
           |          |h(1,1,2,3)=>move(1,3)       <-----7------ 
           | 
*/ 

»»Î»µİ¹é.txt			 
===========================			 
ÅÅĞò·¨.txt			 
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int key;
}r[20];

struct rnode
{
	int key;
	int point;
};

main()
{
	void print(struct node a[20],int n);
	int creat();
	void shell(struct node a[20],int n);
	int hoare(struct node a[20],int l,int h);
	void quick1(struct node a[20],int n);
	void quick2(struct node a[20],int l,int h);
	void heap(struct node a[20],int i,int m);
	void heapsort(struct node a[20],int n);
	void merges(struct node a[20],struct node a2[20],int h1,int mid,int h2);
	void mergepass(struct node a[20],struct node a2[20],int l,int n);
	void mergesort(struct node a[20],int n);
	int yx(int m,int i);
	int radixsort(struct rnode a[20],int n);
	int num,l,h,c;
	struct rnode s[20];
	c=1;
	while(c!=0)
	{
		printf("        Ö÷²Ëµ¥                       \n");
		printf("   1    ÊäÈë¹Ø¼ü×Ö£¬ÒÔ-9999±íÊ¾½áÊø¡£\n");
		printf("   2    Ï£¶ûÅÅĞò                     \n");
		printf("   3    ·Çµİ¹éµÄ¿ìËÙÅÅĞò             \n");
		printf("   4    µİ¹éµÄ¿ìËÙÅÅĞò               \n");
		printf("   5    ¶ÑÅÅĞò                       \n");
		printf("   6    ¹é²¢ÅÅĞò                     \n");
		printf("   7    »ùÊıÅÅĞò                     \n");
		printf(" ÊäÈëÑ¡Ôñ    (1--7,0±íÊ¾½áÊø):         ");
		scanf("%d",&c);
		switch(c)
		{
		case 1:num=creat();print(r,num);break;
		case 2:shell(r,num);print(r,num);break;
		case 3:quick1(r,num);print(r,num);break;
		case 4:l=0;h=num-1;quick2(r,l,h);
			printf("output quick2sort result:\n");
			print(r,num);break;
		case 5:heapsort(r,num);break;
		case 6:mergesort(r,num);print(r,num);break;
		case 7:radixsort(s,num);
		}
	}
}//main end

void print(struct node a[20],int n)
{
	int i;
	for(i=0;i<n;i++)
		printf("%5d",a[i ].key);
	printf("\n");
}//print end

int creat()
{
	int i,n;
	n=0;
	printf("input keys");
	scanf("%d",&i);
	while(i!=-9999)
	{
		r[n].key=i;
		n++;
		scanf("%d",&i);
	}
	return(n);
}//creat end

void shell(struct node a[20],int n)//Ï£¶ûÅÅĞò
{
	int i,j,k;
	for(i=n;i>=1;i--)
		a[i].key=a[i-1].key;
	k=n/2;
	while(k>=1)
	{
		for(i=k+1;i<=n;i++)
		{
			a[0].key=a[i].key;
			j=i-k;
			while((a[j].key>a[0].key)&&(j>=0))
			{
				a[j+k].key=a[j].key;
				j=j-k;
			}
			a[j+k]=a[0];
		}
		k=k/2;
	}
	for(i=0;i<n;i++)
		a[i].key=a[i+1].key;
	printf("Êä³öÏ£¶ûÅÅĞòµÄ½á¹û:\n");
}//shell end

////////////////////¿ìËÙÅÅĞò///////////////////////////

int hoare(struct node a[20],int l,int h)//·ÖÇø´¦Àíº¯Êı
{
	int i,j;
	struct node x;
	i=l;
	j=h;
	x.key=a[i].key;
	do
	{
		while((i<j)&&(a[j].key>=x.key))
			j--;
		if(i<j)
		{
			a[i].key=a[j].key;
			i++;
		}
		while((i<j)&&(a[i].key<=x.key))
			i++;
		if(i<j)
		{
			a[j].key=a[i].key;
			j--;
		}
	}while(i<j);
	a[i].key=x.key;
	return(i);
}//hoare end

void quick1(struct node a[20],int n)
{
	int i,l,h,tag,top;
	int s[20][2];
	l=0;h=n-1;tag=1;top=0;
	do
	{
		while(l<h)
		{
			i=hoare(a,l,h);
			top++;
			s[top][0]=i+1;
			s[top][1]=h;
			h=h-1;
		}
		if(top==0)
			tag=0;
		else
		{
			l=s[top][0];
			h=s[top][1];
			top--;
		}
	}while(tag==1);
	printf("Êä³ö·Çµİ¹é¿ìËÙÅÅĞò½á¹û:\n");
}//quick end

void quick2(struct node a[20],int l,int h)//µİ¹éµÄ¿ìËÙÅÅĞò
{
	int i;
	if(l<h)
	{
		i=hoare(a,l,h);
		quick2(a,l,i-1);
		quick2(a,i+1,h);
	}
}//quick2 end

////////////////////¿ìËÙÅÅĞò½áÊø////////////////////////

////////////////////¶ÑÅÅĞòº¯Êı//////////////////////////

void heap(struct node a[20],int i,int m)//µ÷Õû¶ÑµÄº¯Êı
{
	struct node x;
	int j;
	x.key=a[i].key;
	j=2*i;
	while(j<=m)
	{
		if(j<m)
			if(a[j].key>a[j+1].key)
				j++;
		if(a[j].key<x.key)
		{
			a[i].key=a[j].key;
			i=j;
			j=2*i;
		}
		else
			j=m+1;
	}
	a[i].key=x.key;
}//heap end

void heapsort(struct node a[20],int n)//¶ÑÅÅĞòµÄÖ÷Ìåº¯Êı
{
	int i,v;
	struct node x;
	for(i=n;i>0;i--)
		a[i].key=a[i-1].key;
	for(i=n/2;i>=1;i--)
		heap(a,i,n);
	printf("Êä³ö¶ÑÅÅĞò½á¹û:\n");
	for(v=n;v>=2;v--)
	{
		printf("%5d",a[1].key);
		x.key=a[1].key;
		a[1].key=a[v].key;
		a[v].key=x.key;
		heap(a,1,v-1);
	}
	printf("%5d",a[1].key);
	for(i=0;i<n;i++)
		a[i].key=a[i+1].key;
}//heapsort end

/////////////////¶ÑÅÅĞòº¯Êı½áÊø///////////////////

//////////////////¹é²¢º¯Êı////////////////////////

void merges(struct node a[20],struct node a2[20],int h1,int mid,int h2)
//¹é²¢ÅÅĞòµÄºËĞÄËã·¨
{
	int i,j,k;
	i=h1;j=mid+1;k=h1-1;
	while((i<=mid)&&(j<=h2))
	{
		k=k+1;
		if(a[i].key<=a[j].key)
		{
			a2[k].key=a[i].key;
			i++;
		}
		else
		{
			a2[k].key=a[j].key;
			j++;
		}
	}
	while(i<=mid)
	{
		k++;
		a2[k].key=a[i].key;
		i++;
	}
	while(j<=h2)
	{
		k++;
		a2[k].key=a[j].key;
		i++;
	}
}//merges end

void mergepass(struct node a[20],struct node a2[20],int l,int n)
//Ò»ÌË¹é²¢
{
	int j,i,h1,mid,h2;
	i=0;
	while((n-i)>=2*l)
	{
		h1=i;
		mid=h1+l-1;
		h2=i+2*l-1;
		merges(a,a2,h1,mid,h2);
		i=i+2*l;
	}
	if((n-i)<=l)
		for(j=i;j<=n;j++)
			a2[j].key=a[j].key;
	else
	{
		h1=i;
		mid=h1+l-1;
		h2=n-1;
		merges(a,a2,h1,mid,h2);
	}
}//mergepass end

void mergesort(struct node a[20],int n)
{
	int l;
	struct node a2[20];
	l=1;
	while(l<n)
	{
		mergepass(a,a2,l,n);
		l=2*l;
		mergepass(a2,a,l,n);
		l=2*l;
	}
	printf("Êä³ö¹é²¢ÅÅĞòµÄ½á¹û:\n");
}//mergesort end

///////////////¹é²¢º¯Êı½áÊø///////////////

///////////////»ùÊıÅÅĞò///////////////////

int yx(int m,int i)//·ÖÀë¹Ø¼ü×Öµ¹ÊıµÚiÎ»ÓĞĞ§Êı×ÖµÄËã·¨
{
	int x;
	switch(i)
	{
	case 1:x=m%10;break;
	case 2:x=(m%100)/10;break;
	case 3:x=(m%1000)/100;break;
	case 4:x=(m%10000)/1000;break;
	}
	return(x);
}//yx end

int radixsort(struct rnode a[20],int n)
{
	int f[11],e[11],i,j,k,l,p,d,t;
	for(i=1;i<=n;i++)
	{
		a[i].key=r[i-1].key;
		a[i].point=i+1;
	}
	a[n].point=0;
	p=1;
	printf("Êä³ö¹Ø¼ü×ÖÓĞĞ§Î»Êı d\n");
	scanf("%d",&d);
	printf("Êä³ö»ùÊıÅÅĞòµÄ½á¹û:\n");
	for(i=1;i<=d;i++)
	{
		for(j=0;j<=10;j++)
		{
			f[j]=0;
			e[j]=0;
		}
		while(p!=0)
		{
			k=yx(a[p].key,i);
			if(f[k]==0)
			{
				f[k]=p;
				e[k]=p;
			}
			else
			{
				l=e[k];
				a[l].point=p;
				e[k]=p;
			}
			p=a[p].point;
		}
		j=0;
		while(f[j]==0)
			j++;
		p=f[j];t=e[j];
		while(j<10)
		{
			j++;
			while((j<10)&&(f[j]==0))
				j++;
			if(f[j]!=0)
			{
				a[t].point=f[j];
				t=e[j];
			}
		}
		a[t].point=0;
		t=p;
		while(t!=0)
		{
			printf("%5d",a[t].key);
			t=a[t].point;
		}
		printf("\n");
	}
	return(p);
}

===========================			 
ÍÆÏä×Ó.txt			 
#include<stdio.h>
#include<stdlib.h>
typedef struct ele{ 
             int vno; /*ÎïÆ·ºÅ*/ 
           struct ele *link; /*ÁíÒ»ÎïÆ·µÄÖ¸Õë*/ 
         }ELE; 
typedef struct hnode{ 
        int remainder;/*Ïä×ÓÉĞÊ£¿Õ¼ä*/ 
        ELE *head; /*ÏäÄÚÎïÆ·Á´Ê×ÔªÖ¸Õë*/ 
        struct hnode *next;/*Ïä×ÓÁ´µÄºó¼ÌÏä×ÓÖ¸Õë*/ 
 }HNODE; 
main() 
{   
  int n,i,box_count,box_volume,*a; 
 HNODE *box_h,*box_t,*j; 
 ELE *p,*q; 
printf("ÊäÈëÏä×ÓÈİ»ı "); 
scanf("%d",&box_volume); 
printf("ÊäÈëÎïÆ·ÖÖÊı "); 
scanf("%d",&n); 
a=(int *)malloc(sizeof(int )*n);/*´æ´¢ÎïÆ·Ìå»ıĞÅÏ¢µÄÊı×é*/ 
printf( "Çë°´Ìå»ı´óĞ¡Ë³ĞòÊäÈë¸÷ÎïÆ·µÄÌå»ı£º "); 
for(i=0;i<n;i++) 
 scanf("%d",a+i); 
box_h=box_t=NULL; /*Ô¤ÖÃÒÑÓÃÏä×ÓÁ´Îª¿Õ*/ 
box_count=0; /*Ô¤ÖÃÒÑÓÃÏä×Ó¼ÆÊıÆ÷Îª0*/ 
for(i=0;i<n;i++) 
{               /*´ÓµÚÒ»Ö»Ïä×Ó¿ªÊ¼Ë³ĞòÑ°ÕÒÄÜ·ÅÈëÎïÆ·i µÄÏä×Ój*/ 
 p=(ELE *)malloc(sizeof(ELE)); 
 p->vno=i; 
 for(j=box_h;j!=NULL;j=j->next) 
      if(j->remainder>=a[i ]) 
         break;     /*ÕÒµ½»¹¿ÉÒÔ×°ÎïÆ·iµÄÏä×Ó*/ 
  if(j==NULL) 
    {            /*ÒÑÓÃÏä×Ó¶¼²»ÄÜ×°ÎïÆ·i*/ 
      j=(HNODE *)malloc(sizeof(HNODE));  /*Ê¹ÓÃÒ»Ö»ĞÂµÄÏä×Ó*/ 
      
      j->remainder=box_volume-a[i ]; 
      j->head=NULL; 
      if(box_h==NULL) 
        box_h=box_t=j;   /* box-tÓĞÊ²Ã´ÓÃ´¦£¬ÄÜ½âÊÍÒ»ÏÂÂğ£¿*/ 
      else box_t=box_t->next=j; /*´ËÍâbox-tÓÖÓĞÊ²Ã´ÓÃ£¨ÔÚ³ÌĞòÖĞ£©£¬ÇëËµÏêÒ»Ï¸*/ 
        j->next=NULL; 
         box_count++; 
     } 
else 
   j->remainder=a[i ];           /*½«ÎïÆ·i·ÅÈëÏä×Ój*/ 
  for(q=j->head;q!=NULL&&q->link!=NULL;q=q->link);/*´ÓÕâÀïÆğÊÇ·ÅÈëÎïÆ·ºÅ*/ 
    if(q==NULL) 
      { 
        p->link=j->head; 
        j->head=p; 
       } 
    else 
        { 
       p->link=NULL; 
       q->link=p; 
        } 
  }/*for i*/ 
}           ===========================			 
#include<stdio.h>

int a[]={0,1,2,5,8,7,6,3};
int b[9];
int c[9];
int count=0;

main()
{
	int i,j,k,t;
	void print();
	printf("Please enter original order of digits 1~8: ");
	for(i=0;i<8;i++)
		scanf("%d",&b[a[i ] ]);
	printf("The sorting process is as felow:\n");
	print();                   //Êä³ö³õÊ¼¾ØÕó
	for(t=-1,j=0;j<8&&t==-1;j++)//È·¶¨1ËùÔÚµÄÎ»ÖÃ
		if(b[a[j] ]==1)t=j;      //t¼ÇÂ¼1µÄÎ»ÖÃ	
	for(j=0;j<8;j++)         //°Ñ1µÄÎ»ÖÃ¶¨Îª»·Ê×
		c[j]=a[(j+t)%8];
	for(i=2;i<9;i++)          //´Ó2¿ªÊ¼ÒÀ´Îµ÷ÕûÊı×Ö
		//iÕıÈ·µÄÎ»ÖÃÊÇi-1
		for(j=i-1;j<8;j++)
			if(b[c[j]]==i&&j!=i-1)
			{
				b[4]=i;
				b[c[j] ]=0;   //¿Õ³öÀ´µÄÎ»ÖÃÎª0
				print();
				for(k=j;k!=i-1;k--)
				{
					b[c[k] ]=b[c[k-1] ];
					b[c[k-1] ]=0;
					print();
				}
				b[c[k] ]=i;
				b[4]=0;
				print();
				break;
			}
			else if(b[c[j] ]==i)break;
}

void print(void)
{
	int c;
	for(c=0;c<9;c++)
		if(c%3==2)printf("%2d\n",b[c]);
		else printf("%2d",b[c]);
	printf("---%2d---\n",count++);
}Êı×ÖÒÆ¶¯.txt			 
===========================			 
Êı¾İ½á¹¹.txt			 
#include <stdio.h>

void main()
{
   struct childrec  /* ¶¨Òå½á¹¹ÀàĞÍ childrec */
   {
     char initial;  /* ĞÕÃûÊ××ÖÄ¸ */
     int age;       /* ÄêÁä       */
     int grade;     /* ¿¼ÊÔ³É¼¨   */ 
   };

   struct childrec kids[12] = /* ¶¨Òå childrec ½á¹¹ÌåÊı×é²¢³õÊ¼»¯ */
   {
      {'A',16, 80},
      {'B',13, 80},
      {'C',19, 84},
      {'D',19, 89},
      {'E',12, 84},
      {'F',17, 82},
      {'G',16, 90},
      {'H',16, 85},
      {'I',16, 96},
      {'J',17, 91},
      {'K',13, 72},
      {'L',14, 69}
   };

   int index;

   for (index = 0;index < 12;index++)
      printf("%c is %d years old and got a grade of %d\n",
         kids[index].initial, kids[index].age,kids[index].grade);
}
===========================			 
Êı¾İ½á¹¹2.txt			 
#include<stdio.h>

struct childrec
{
     char initial;  /* ĞÕÃûÊ××ÖÄ¸ */
     int age;       /* ÄêÁä       */
     int grade;     /* ³É¼¨       */
};

void main()
{
   struct childrec kids[12] = {
	   {'A',16, 80},
	   {'B',13, 80},
	   {'C',19, 84},
	   {'D',19, 89},
	   {'E',12, 84},
	   {'F',17, 82},
	   {'G',16, 90},
	   {'H',16, 85},
	   {'I',16, 96},
	   {'J',17, 91},
	   {'K',13, 72},
	   {'L',14, 69}
   };

   struct childrec  *point,extra;
   int index;

   for (index = 0;index < 12;index++) 
   {
      point = kids + index;
      printf("%c is %d years old and got a grade of %d\n",
       (*point).initial, kids[index].age,point->grade);
   }
   printf("\n");
   getch();

   extra = kids[2];               /* ½á¹¹ÕûÌå¸³Öµ */
   printf("data of extra struct:initial(%c) age(%d) grade(%d)\n",
	          extra.initial,extra.age,extra.grade);
   getch();

   extra = *point;                /* ½á¹¹ÕûÌå¸³Öµ */
   printf("data of extra struct:initial(%c) age(%d) grade(%d)\n",
	          extra.initial,extra.age,extra.grade);
}
===========================			 
Êı¾İ½á¹¹3.txt			 
#include <stdio.h>

void main()
{
   struct  childrec/*¶¨Òå½á¹¹Ìå*/
   {
     char initial;  /* ĞÕÃûÊ××ÖÄ¸   */
     int age;       /* ÄêÁä         */
     int grade;     /* ¿¼ÊÔ³É¼¨     */
   }boy,girl;

   boy.initial = 'R';
   boy.age = 15;
   boy.grade = 75;

   girl.age = boy.age - 1;  /* Å®º¢±ÈÄĞº¢Ğ¡Ò»Ëê */
   girl.grade = 82;
   girl.initial = 'H';

   printf(" girl:  %c is %d years old and got a grade of %d\n",
            girl.initial, girl.age, girl.grade);

   printf("  boy:  %c is %d years old and got a grade of %d\n",
           boy.initial, boy.age, boy.grade);
}
===========================			 
Êı×éÍêÈ«µ¥Ôª.txt			 
#include "stdio.h"
#include"conio.h"
int k=0;
int a[100];
void num(int number)
{
int n1,j,temp=k,i;
for(j = 1 ; j <= number/2 + 1 ; j ++)
{
	if(number-j <= 0)  
		break;
	n1 = number - j;
	a[k ++] = j;
	if(n1 > 1)
		num(n1);
	else
	{
		a[k ++] = 1;
		printf("\n");
		for(i = 0 ; i < k-1 ; i ++)
			printf("%d+",a[i]);
		printf("%d",a[k-1]);
	}
	k=temp;
}
printf("\n");
for(i = 0 ; i < k ;i ++)
printf("%d+",a[i]);
printf("%d",number);
}
void main()
{
int m;
scanf("%d",&m);
num(m);
}  ===========================			 
Êı×é²Ù×÷.txt			 
#include <stdio.h>  

void main()
{
   char strg[40],*there,one,two;
   int *pt,list[100],index;

   strcpy(strg,"This is a character string.");

   one = strg[0];                    /* one ºÍ twoÊÇÏàÍ¬µÄ */
   two = *strg;
   printf("µÚÒ»Êä³öµÄÊÇ %c %c\n",one,two);

   one = strg[8];                   
   two = *(strg+8);
   printf("µÚ¶şÊä³öµÄÊÇ %c %c\n",one,two);

   there = strg+10;           /* strg+10 µÈÍ¬ÓÚ strg[10] */
   printf("µÚÈıÊä³öµÄÊÇ %c\n",strg[10]);
   printf("µÚËÄÊä³öµÄÊÇ %c\n",*there);

   for (index = 0;index < 100;index++)
      list[index] = index + 100;
   pt = list + 27;
   printf("µÚÎåÊä³öµÄÊÇ %d\n",list[27]);
   printf("µÚÁùÊä³öµÄÊÇ %d\n",*pt);
}
===========================			 
Êı×éµİ¹éÍË³ö.txt			 
#include <stdio.h>
void f2();
int a[13],i,j,b=13;
main()
{	
f2();
for(j=0;j<b;j++)
  a[j]=j+1;
for(j=0;j<b;j++)
printf("%d\n",a[j]);
getch();
}
void f2()
{

int n=0;
for(i=0;i<b;i++)
	{
       a[i]=i+1; 
		if(a[i]%10==3)
		{
			n++;
		}
		
	}
     b=i-n;
	for(j=0;j<b;j++)
		if(a[j]%10==3)
			f2();
}

===========================			 
Êı×éµİ¹éÍË³ö2.txt			 
#include <stdio.h>
void f2();
int a[13],k,j=1,b=13,n=0;
main()
{	
for(k=0;k<b;k++)
a[k]=j++;
f2();
for(k=0;k<b;k++)
if(a[k]!=0)
printf("µÚ%d¸öÈËÃ»ÓĞ³ö¾Ö\n",k+1);
getch();
}
void f2()
{
for(k=0;k<b;k++)
	{
		if(a[k]%10==3)
		{
			a[k]=0;
			n++;

		}
		if(a[k]!=0)
			a[k]=j++;
		
	}
if (n<b-1)
			f2();
}===========================			 
ÎÄ¼ş¼ÓÃÜ.txt			 
¸øÎÄ¼ş¼ÓÃÜµÄ¼¼ÊõºÜ¶à,ÆäÖĞÓÖ·ÖÎª²»Í¬µÈ¼¶,ÒÔÊÊºÏ²»Í¬³¡ºÏµÄĞèÒª.ÕâÀï¸ø³ö×î¼òµ¥µÄÎÄ¼ş¼ÓÃÜ¼¼Êõ,¼´²ÉÓÃÎÄ¼şÖğ×Ö½ÚÓëÃÜÂëÒì»ò·½Ê½¶ÔÎÄ¼ş½øĞĞ¼ÓÃÜ,µ±½âÃÜÊ±,Ö»ĞèÔÙÔËĞĞÒ»±é¼ÓÃÜ³ÌĞò¼´¿É.

ÏÂÃæÊÇÒ»¸öÊµÀı³ÌĞò,ÄÜ¶ÔÈÎÒâÒ»¸öÎÄ¼ş½øĞĞ¼ÓÃÜ,ÃÜÂëÒªÇóÓÃ»§ÊäÈë,ÏŞ8Î»ÒÔÄÚ(µ±È»Äã¿ÉÒÔÔÙ¸ü¸Ä).³ÌĞòÓĞºÜºÃµÄÈİ´íÉè¼Æ,ÕâÊÇÎÒÃÇÓ¦¸ÃÑ§Ï°µÄ.

/* Turbo 2.0 pass. give file a password! */

#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
#include<string.h>

void dofile(char *in_fname,char *pwd,char *out_fname);/*¶ÔÎÄ¼ş½øĞĞ¼ÓÃÜµÄ¾ßÌåº¯Êı*/

void main(int argc,char *argv[])/*¶¨Òåmain()º¯ÊıµÄÃüÁîĞĞ²ÎÊı*/
{
    char in_fname[30];/*ÓÃ»§ÊäÈëµÄÒª¼ÓÃÜµÄÎÄ¼şÃû*/
    char out_fname[30];
    char pwd[8];/*ÓÃÀ´±£´æÃÜÂë*/

    if(argc!=4){/*Èİ´í´¦Àí*/
    printf("\nIn-fname:\n");
    gets(in_fname);/*µÃµ½Òª¼ÓÃÜµÄÎÄ¼şÃû*/

    printf("Password:\n");
    gets(pwd);/*µÃµ½ÃÜÂë*/

        printf("Out-file:\n");
        gets(out_fname);/*µÃµ½¼ÓÃÜºóÄãÒªµÄÎÄ¼şÃû*/
        

dofile(in_fname,pwd,out_fname);
      }
    else{/*Èç¹ûÃüÁîĞĞ²ÎÊıÕıÈ·,±ãÖ±½ÓÔËĞĞ³ÌĞò*/
        strcpy(in_fname,argv[1]);
        strcpy(pwd,argv[2]);
        strcpy(out_fname,argv[3]);
        dofile(in_fname,pwd,out_fname);
    }

}


/*¼ÓÃÜ×Óº¯Êı¿ªÊ¼*/
void dofile(char *in_fname,char *pwd,char *out_file)
{
    FILE *fp1,*fp2;
    register char ch;
    int j=0;
    int j0=0;

    fp1=fopen(in_fname,"rb");
    if(fp1==NULL){
    printf("cannot open in-file.\n");
    exit(1);/*Èç¹û²»ÄÜ´ò¿ªÒª¼ÓÃÜµÄÎÄ¼ş,±ãÍË³ö³ÌĞò*/
    }
    fp2=fopen(out_file,"wb");
    if(fp2==NULL){
    printf("cannot open or create out-file.\n");
    exit(1);/*Èç¹û²»ÄÜ½¨Á¢¼ÓÃÜºóµÄÎÄ¼ş,±ãÍË³ö*/
    }
    while(pwd[++j0]);
    ch=fgetc(fp1);

/*¼ÓÃÜËã·¨¿ªÊ¼*/
    while(!feof(fp1)){
    fputc(ch^pwd[j>=j0?j=0:j++],fp2);/*Òì»òºóĞ´Èëfp2ÎÄ¼ş*/
    ch=fgetc(fp1);
    }
    fclose(fp1);/*¹Ø±ÕÔ´ÎÄ¼ş*/
    fclose(fp2);/*¹Ø±ÕÄ¿±êÎÄ¼ş*/
}

/*³ÌĞò½áÊø*/
===========================			 
ÎÄ¼ş¸´ÖÆ.txt			 
#include<stdio.h>
#include<stdlib.h>

void main(int argc,char *argv[])
{
    FILE *in,*out;

    if(argc!=3){
        printf("\n Usage: Hcopy sourcefile targetfile.\n");
        exit(1);
    }
    if((in=fopen(argv[1],"rb"))==NULL){
        printf("\n Cannot open the source file.\n");
        exit(2);
    }
    if((out=fopen(argv[2],"wb"))==NULL){
        printf("\n Cannot open the targetfile.\n");
        exit(3);
    }

    /* start copy */
    while(!feof(in))
        putc(getc(in),out);

    fclose(in);
    fclose(out);
}

===========================			 
ÎÄ¼şÁ¬½Ó.txt			 
/****************fcat.c***************/

#include<stdio.h>
#include<stdlib.h>
#define BUFSIZE 256

void main(int argc,char *argv[])
{
    int i;
    char buff[BUFSIZE];
    FILE *fp1,*fp2;

    if(argc==1){
        printf("Rsage: fcat filename linke_fname[link_fname...].");
        printf("\n");
        exit(1);
    }
    if((fp1=fopen (argv[1],"a"))==NULL){
        printf("file %s cannot opened.\n",argv[1]);
        exit(1);
    }
    for(i=2;i<argc;i++){
        if((fp2=fopen(argv[i],"r"))==NULL){
            printf("file %s cannot opened.\n");
            exit(1);
        }
        while(fgets(buff,BUFSIZE,fp2)!=NULL)
            fputs(buff,fp1);
        fclose(fp2);
    }
    fclose(fp1);
}
===========================			 
ÎŞÏòÍ¼.txt			 
#include<stdio.h>
#include<stdlib.h>
#define MaxSize 20
struct ArcNode
{
	int adjvex;
	struct ArcNode *nextarc;
};

struct Vnode
{
	int data;
	struct ArcNode *firstarc;
};

struct Vnode AdjList[MaxSize];
int m,n,v,cord;

main()
{
	void creatgraph(struct Vnode A[MaxSize]);
	void dfs(struct Vnode A[MaxSize]);
	void bfs(struct Vnode A[MaxSize]);
	do
	{
		printf("\n            Ö÷²Ëµ¥");
		printf("\n      1     ½¨Á¢ÎŞÏòÍ¼µÄÁÚ½Ó±í");
		printf("\n      2     °´Éî¶È±éÀúÍ¼");
		printf("\n      3     °´¹ã¶È±éÀúÍ¼");
		printf("\n      4     ½áÊø³ÌĞòÔËĞĞ");
		printf("\n-----------------------------------");
		printf("\n    ÇëÊäÈëÄúµÄÑ¡Ôñ  1, 2, 3, 4 ");
		scanf("%d",&cord);
		switch(cord)
		{
		case 1:
			creatgraph(AdjList);
			break;
		case 2:
			dfs(AdjList);
			break;
		case 3:
			bfs(AdjList);
			break;
		case 4:
			exit(0);
		}
	}while(cord<=4);
}//main end

void creatgraph(struct Vnode A[MaxSize])
{
	int i,j,k;
	struct ArcNode *p;
	printf("input arces and vexes");
	scanf("%d %d",&m,&n);
	for(k=0;k<n;k++)
	{
		printf("\ninput arc");
		scanf("%d%d",&i,&j);
		p=(struct ArcNode*)malloc(sizeof(struct ArcNode));
		p->adjvex=j;
		p->nextarc=A[i-1].firstarc;
		A[i-1].firstarc=p;
		p=(struct ArcNode*)malloc(sizeof(struct ArcNode));
		p->adjvex=i;
		p->nextarc=A[j-1].firstarc;
		A[j-1].firstarc=p;
	}
	printf("\n");
	for(k=0;k<n;k++)
	{
		printf("%d",A[k].data);
		p=A[k].firstarc;
		while(p)
		{
			printf("%d",p->adjvex);
			p=p->nextarc;
		}
		printf("\n");
	}
}///creatgraph end

void dfs(struct Vnode A[MaxSize])
{
	struct ArcNode *p,*ar[MaxSize];

	int x,i,y,top=-1;
	int visited[MaxSize];
	for(i=0;i<n;i++)
		visited[i]=0;
	printf("\ninput x");
	scanf("%d",&x);
	printf("%d",x);
	visited[x-1]=1;
	p=A[x-1].firstarc;
	while((p)||(top>=0))
	{
		if(!p)
		{
			p=ar[top];
			top--;
		}
		y=p->adjvex;
		if(visited[y-1]==0)
		{
			visited[y-1]=1;
			printf("->%d",y);
			p=p->nextarc;
			if(p)
			{
				top++;
				ar[top]=p;
			}
			p=A[y-1].firstarc;
		}
		else p=p->nextarc;
	}
}

void bfs(struct Vnode A[MaxSize])
{}===========================			 
Ê±¼äÏİÚå.txt			 
/********
Ê¹ÓÃ¹ıbasicÓïÑÔµÄÅóÓÑ¶¼ÖªµÀ,basicÖĞÓĞÒ»ÖÖÖØÒªµÄ¹¦ÄÜ,¾ÍÊÇÊ±¼äÏİÚå.ËüÄÜÊÇÖ÷³ÌĞòµÄÔËĞĞºÍ¶ÔÊÂ¼şµÄ´¦ÀíÒì²½½øĞĞ.Í¨¹ıÉèÖÃÊ±¼äÏİÚå.¿ÉÒÔÔÚ¹æ¶¨µÄÊ±¼ä¼ä¸ôµ½´ïºó×Ô¶¯Ö´ĞĞÄ³¸ö×Ó³ÌĞò.×Ó³ÌĞòÔËĞĞ½áÊøºóÓÖ»Øµ½Ö÷³ÌĞòµÄ¶Ïµã´¦¼ÌĞøÖ´ĞĞ.basicÓïÑÔÌá¹©ÁËÓĞ¹ØÊ±¼äÏİÚåµÄÓï¾ä.¿ÉÒÔÖ±½Óµ÷Óµ«CÓïÑÔÃ»ÓĞÕâÑùµÄ¹¦ÄÜ,ÎªÁËÄÜÊµÏÖÉÏÊö¹¦ÄÜ,ÕâÀï¸ø³öÁË¼¸¸ö×Óº¯ÊıÒÔ°ïÖúÊµÏÖ.

    on_timer(t,p):    Éè¶¨¶¨Ê±Ê±¼ä¼ä¸ôÎªt(ÒÔÃëÎªµ¥Î»).²¢¹æ¶¨ÁËÊÂ¼ş´¦Àí×Óº¯ÊıµÄÈë¿Úµã.tÊÇÕû
                      ĞÍÊı,pÊÇÖ¸Ïò×Óº¯ÊıµÄÖ¸Õë.
    timer_on():      Æô¶¯¶¨Ê±Æ÷¿ªÊ¼¼ÆÊ±.ÒÔºóÃ¿¸ötÃë,Ö¸ÕëpËùÖ¸ÏòµÄ×Óº¯ÊıÔËĞĞÒ»´Î.
    timer_off():    ¹Ø±Õ¶¨Ê±Æ÷.

ÏÂÃæÊÇ×Óº¯ÊıÇåµ¥.
***************/
/*timer Ä£¿éÔ´³ÌĞòÇåµ¥*/

#include<dos.h>

#define Sizeprogram 375
void interrupt (*oldtimer)();
void interrupt newtimer();
static struct SREGS seg;
unsigned intsp,intss;
unsigned myss,stack;
unsigned vseg;
int running=0;
int m1,m2,m3=0;
int (*sub_ptr)();
void on_timer();
void timer_on();
void timer_off();

void on_timer(t,pp)
int t;
int (*pp)();
{
    sub_ptr=pp;
    m1=t;
    segread(&seg);
    stack=(Sizeprogram-(seg.ds-seg.cs))*16-300;
    myss=_SS;
    oldtimer=getvect(0x1c);
}

void timer_on()
{
    m2=0;
    m3=1;
    setvect(0x1c,newtimer);
}
void timer_off()
{
    m3=0;
    setvect(0x1c,oldtimer);
}
void interrupt newtimer()
{
    (*oldtimer)();
    if(running==0)
        running=1;
        disable();
        intsp=_SP;
        intss=_SS;
        _SP=stack;
        _SS=myss;
        enable();
        if(m3==1){
            if(m2==m1*18){
            m2=0;
	    (*sb_ptr)();
            }
            m2+=1;
        }
        disable();
        _SP=intsp;
        _SS=intss;
        enable();
        running=0;
    }
}===========================			 
#include <stdio.h>
int c(x,y);
main()
{
int i,j,n=13;
printf("N=");
while(n>12)
scanf("%d",&n);
for(i=0;i<=n;i++)
{
for(j=0;j<12-i;j++)
printf(" ");
for(j=1;j<i+2;j++)
printf("%6d",c(i,j));
printf("\n");
}
}

int c(x,y)
int x,y;
{
int z;
if((y==1)||(y==x+1))return(1);
z=c(x-1,y-1)+c(x-1,y);

return(z);
}Ñî»ÔÈı½ÇĞÎ.txt			 
===========================			 
Õ»µ¥Ôª¼Ó.txt			 
#include<stdio.h>
#include<stdlib.h>
typedef struct node
{ int data;
  struct node *next;
} st;
st *top=NULL,*p=NULL;

void print()
{ while(p)
  { printf("%d ",p->data);
    p=p->next;
  }
  printf("\n");
}

void fun(int m,int n)
{ if(m==n)
  { p=(st *)malloc(sizeof(st));
    p->next=top;
    p->data=n;
    print();
    free(p);return;
  }
  else if(m>n) return;
  else
  { int i;
    p=(st *)malloc(sizeof(st));
    p->next=top;
    top=p;
    for(i=m;i<=n/2;i++)
    { top->data=i;fun(i,n-i);
    }
    if(top->next)
    { top->data=n;p=top;print();
      p=top;top=top->next;free(p);
    }
  }
}

void main()
{ int n;
  printf("Please type a number(>=2):");
  scanf("%d",&n);
  printf("\n");
  fun(1,n);
} ===========================			 
Õ»²Ù×÷.txt			 
#include<stdio.h>
#include<stdlib.h>
#define MAX 20
#define ElemType int
#define S  (*p)

struct SqStack
{
	ElemType elem[MAX];
	int top;
};

main()
{
	struct SqStack *q;
	int i,y,cord;ElemType a;
	void OutStack(struct SqStack S);
	void InitStack(struct SqStack *p);
	void Push(struct SqStack *p,ElemType x);
	ElemType Pop(struct SqStack *p);
	ElemType GetTop(struct SqStack *p);
	do{
		printf("\n");
		printf("\n           Ö÷²Ëµ¥          \n");
		printf("\n     1     ³õÊ¼»¯Ë³ĞòÕ»    \n");
		printf("\n     2     ²åÈëÒ»¸öÔªËØ    \n");
		printf("\n     3     É¾³ıÕ»¶¥ÔªËØ    \n");
		printf("\n     4     È¡Õ»¶¥ÔªËØ      \n");
		printf("\n     5     ½áÊø³ÌĞòÔËĞĞ    \n");
		printf("\n--------------------------------\n");
		printf("ÇëÊäÈëÄúµÄÑ¡Ôñ( 1, 2, 3, 4, 5)");
		scanf("%d",&cord);
		switch(cord)
		{
			case 1:
				{
					q=(struct SqStack*)malloc(sizeof(struct SqStack));
					InitStack(q);
					OutStack(q);
				}break;
			case 2:
				{
					printf("ÇëÊäÈëÒª²åÈëµÄÊı¾İ a=");
					scanf("%d",&a);
					Push(q,a);
					OutStack(q);
				}break;
			case 3:
				{
					Pop(q);
					OutStack(q);
				}break;
			case 4:
				{
					y=GetTop(q);
					printf("\ny=%d\n",y);
					OutStack(q);
				}break;
			case 5:
				exit(0);
		}
	}while (cord<=5);
}

void InitStack(struct SqStack *p)
{
	if(!p)
		printf("Eorror");
	S.top=0;
}

void Push(struct SqStack *p,ElemType x)
{
	if(S.top<MAX-1)
	{
		S.top=S.top+1;
		S.elem[S.top]=x;
	}
	else
		printf("Overflow!\n");
}

ElemType Pop(struct SqStack *p)
{
	ElemType x;
	if(S.top!=0)
	{
		x=S.elem[S.top];
		S.top=S.top-1;
		return(x);
	}
	else
	{
		printf("Underflow!\n");
		return(0);
	}
}

ElemType GetTop(struct SqStack *p)
{
	ElemType x;
	if(S.top!=0)
	{
		x=S.elem[S.top];
		return(x);
	}
	else
	{
		printf("Underflow!\n");
		return(0);
	}
}

void OutStack(struct SqStack *p)
{
	int i,j;
	if(S.top==0)
		printf("The stack is null");
	for(i=S.top;i>0;i--)
		printf("%2d %6d\n",i,S.elem[i]);
}===========================			 
ÌÒ×Óºï.txt			 
#include <stdio.h> 
#include <stdlib.h> 

void main() 
{ 
int total = 0; 
int n,b;
scanf("%d%d",&n,&b);
while(1) 
{ 
int i = ++total; 
int j; 
for(j = 0; j< n;j++, i = (i-b)*(n-1)/n) 
{ 
  if((i - b) % n == 0) 
      continue; 
  else 
      break; 
 } 
 if ( j == n ) 
     break; 
} 
printf("The result is %d", total); 
} 
===========================			 
Í°ÅÅĞò.txt			 
#include<stdio.h>

void comp(int k[],int m,int l)
{
	int i=10,j=0,z=1,y=1,x,w,b[500][10];
	for(w=0;w<m;w++)
		for(x=0;x<10;x++)
		{
			b[w][x]=-1;
		}
	while(z>0)
	{
		z=l/i;
		i=i*10;
		++j;  //¼ÇÂ¼×î´óÊıµÄÎ»Êı
	}
	i=10;
	while(j>0)
	{
		for(z=0;z<=m;z++)
		{
			x=(k[z]/y)%i;
			b[z][x]=k[z];
		}
		w=0;
		for(z=0;z<10;z++)
			for(x=0;x<m;x++)
			{
				if(b[x][z]>=0)
				{
					k[w]=b[x][z];
					b[x][z]=-1;
					w++;
				}
			}
		--j;
		y=y*10;
	}
	for(z=0;z<m;z++)
	{
		printf("%d ",k[z]);
	}
}

main()
{
	int n,m=0,l=0;
	int a[500];
	printf("ÇëÊäÈëÕıÕûÊı,¸ºÊı±íÊ¾½áÊø:");
	scanf("%d",&n);
	while(n>=0)
	{
		a[m]=n;
		++m;
		if(n>l)
			l=n;//¼ÇÂ¼×î´óÊı
		scanf("%d",&n);
	}

	comp(a,m,l);
}===========================			 
¼ì³ö´íÎó.txt			 
¼ì³öºÍ·ÖÀëcÓïÑÔÔ´³ÌĞò´íÎóµÄ·½·¨

ÎÒÃÇÖªµÀ£¬±àÒë³ÌĞò¿ÉÒÔÕÒµ½Ô´³ÌĞòÖĞµÄÓï·¨´íÎóºÍÓïÒå´íÎó£¬²¢½«Æä·ÖÀë³öÀ´£¬µ«Ëı²»ÄÜ¼ì³ö³ÌĞò±àÖÆµÄÊÇ·ñµÃµ±¼°Ëã·¨ÊÇ·ñÕıÈ·¡£ÔÚcÓïÑÔÔ´³ÌĞòµ÷ÊÔ¹ı³ÌÖĞ£¬±È½ÏÂé·³µÄÒ»ÖÖ´íÎóÊÇ³ÌĞò¿ÉÒÔÖ´ĞĞ£¬µ«µÃ²»µ½Ï£ÍûµÄ½á¹û£¬¼´Ê¹ÔÚËã·¨ÕıÈ·µÄÇé¿öÏÂ£¬³ÌĞòÔ±Ò²Òª´ÓÍ·µ½Î²µÄ¶ÔÕû¸ö³ÌĞò¼ì²é¡£ÕÒ³ö´íÎóµÄ·½·¨¿ÉÒÔ´ÓÒ»×é¼ì²éÊı¾İ¿ªÊ¼£¬°ÑÒÑÖªµÄÊı¾İËÍÈë³ÌĞò£¬²¢°Ñ³ÌĞòÖğ²½»®Ğ¡£¬Ö±µ½ÕÒ³ö´íÎóËùÔÚ²¢½«Æä·ÖÀë³öÀ´ÎªÖ¹¡£ÕâÖÖ·½·¨´ó¶¼²ÉÓÃÔÚÔ´³ÌĞòÖĞ¼ÓÈëÈô¸Éprintf()Óï¾äÀ´ÊµÏÖ£¬Í¨¹ı¼ì²éÖĞ¼ä½á¹û£¬¾Í¿ÉÄÜ°Ñ³ö´íµÄÔ­ÒòÕÒ³öÀ´¡£µ«ÕâÖÖ·½·¨¹ıÓÚ·±Ëö¸´ÔÓ£¬Ê¹ÓÃ²»±ã¡£±¾ÎÄ½éÉÜÒ»ÖÖ½â¾öÕâ¸öÎÊÌâµÄ¼òµ¥·½·¨£¬ÒÔÆğÅ××©ÒıÓñµÄ×÷ÓÃ¡£

    Ê×ÏÈÉè¼ÆÒ»¸öÅÅ´íº¯Êıdebug(),ÕâÀï¼Ù¶¨±àÒë³ÌĞò½øÖ§³ÖÕûĞÍ£¬×Ö·ûĞÍ£¬ÕûĞÍÊı×éºÍ×Ö·ûĞÍÊı×éÀàĞÍ¡£Èç¹û±àÒë³ÌĞò»¹Öµ³ÖÆäËüµÄÊı¾İÀàĞÍ£¬ÉÔ¼ÓĞŞ¸Ädebug()º¯Êı¼´¿É¡£debug()º¯ÊıÈçÏÂ£º

/* function to print ints,chars,and int&char arrays*/
#include<stdio.h>
#include<conio.h>
#define CLEARS 111

void debug(char let,char c_array[],int n_array[],int asize,int num,int opt)
{
    int i;
    switch(opt)
    {
        case 1:
            printf("The value is %d",num);
            break;
        case 2:
            printf("The letter is %c",let);
            break;
        case 3: {
            puts("The number array contains\n");
            for(i=0;i<=asize;++i)
            printf("%d",n_array[i]);
            break;
        }
        case 4:{
            puts("The character array contains\n");
            for(i=0;i<=asize;++i)
            printf("%c",c_array[i]);
            break;
        }
        default:
            puts("\nInvalid option selected!");
            break;
    }
    puts("\tPlease press any key to continue:");
    getch();
}


void main()
{
    int i,j,a[10];
    char ch,b[10];
    for(i=5,j=0;i<15;++i,++j){
        a[j]=j;
        b[j]=j;
    }
    putchar(CLEARS);
    ch='a';
    debug(0,0,0,0,i,1); /*display value of i*/
    debug(ch,0,0,0,0,2);/*display value of ch*/
    debug(0,0,a,10,0,3);/*display value of a*/
    debug(0,b,0,10,0,4);/*display value of b*/
    debug(0,0,0,0,0,7);/*error*/
}

¹ØÓÚ´Ëº¯ÊıµÄ¼¸µãËµÃ÷£º

    debug()º¯ÊıÌá¹©Ò»¸öÔÚÅÅ´í¹ı³ÌÖĞ°ÑËùĞè¹ı³Ì´òÓ¡³öÀ´µÄ·½·¨£¬Ë¼ÏëºÜ¼òµ¥£¬¼´°ÑÒª´òÓ¡µÄÊı¾İÀàĞÍ´«µİ¸øËü£¬²¢ÓÉºóÃæµÄprintf()Óï¾ä½«Æä´òÓ¡³öÀ´£¬µ÷ÓÃgetch()º¯ÊıÒıÆğ³ÌĞòÔİÍ£ÔËĞĞ£¬Ö±µ½°´ÈÎÒâ¼ü¼ÌĞø¡£debug()²ÎÊı°üÀ¨ÁËÎ»ÊÇÆä¹¤×÷ËùĞèÄÚÈİ£¨¸ù¾İĞèÒª»¹¿ÉÌí¼ÓÆäËüÓĞ¹ØµÄ²ÎÊı£©¡£optÊÇÒªÊ¹ÓÃµÄ¿ÉÑ¡Ïî¡£

    Êµ¼ÊÓ¦ÓÃÊ±£¬°Ñdebug()º¯Êı°üº¬½øÄãµÄ³ÌĞò£¬°Ñ´íÎóÕÒ³öÀ´ºó£¬¿ÉÒÔºÜÈİÒ×µÄ°ÑËùÓĞµÄdebug()º¯Êı¶¼Çå³ı³öÈ¥¡£°ÑËùÓĞÕâĞ©µ÷ÓÃºÍÎª°üº¬º¯Êıdebug()ËùÓÃµÄ#include´Ó³ÌĞòÖĞ³·ÏúÊÇºÜÈİÒ×µÄÊÂ¡£Èçvi±à¼­ÔÚ¡°ex×ª»»·½Ê½¡±ÏÂÊ¹ÓÃµÄËÑË÷²¢Ìæ»»ÃüÁîgºÍs)£¬ÕâĞ©ÔÚÔ´³ÌĞòÖĞÊ¹ÓÃprintf()º¯ÊıÊÇºÜÄÑ°ìµ½µÄ¡£

===========================			 
¼ì²âÊó±ê.txt			 
/*±¾³ÌĞòÄÜ¶ÁÈ¡ÏµÍ³»·¾³±äÁ¿,²é¿´ÓĞÎŞÊó±ê.ÈôÓĞ,±ãÊä³öMouse is OK,
·´Ö®±ãÊä³öNo mouse.*/

/********************read mouse***********************/

#include<stdio.h>/*for function of printf()*/
#include<stdlib.h>/*for function of exit()*/
#include<string.h>/*for function of strcmp()*/


void loadmous(void); /*²é¿´ÓĞÎŞÊó±ê×Óº¯Êı*/
/*Ö÷º¯Êı¿ªÊ¼*/
main()
{
    loadmous();
    return 0;
}
/*×Óº¯Êı*/
void loadmous()
{
    char *p;
    if((p=getenv("MOUSE"))!=NULL){/*µ÷ÓÃgetenv()º¯Êı,¶ÁÈ¡ÏµÍ³»·¾³±äÁ¿*/
        if(!strcmp(p,"YES"))/*ÅĞ¶ÏÓĞÎŞÊó±ê*/
        printf("Mouse is OK\n");
    }
    else{
	printf("\n No mouse");
	getch();
	exit(1);/*Õı³£ÍË³ö³ÌĞò*/
    }
}===========================			 
ºº×Ö×ÖÄ£.txt			 
//#include "graphics.h" 
#include "fcntl.h" 
#include "stdio.h" 
#define  N 30 
int   hzk_p; 
void  open_hzk(void); 
void  get_mat(char hz_code[ ],unsigned char buff[ ]); 
void  creatclib(char *name); 
void  sort( ); 
void  writeclib(char *name); 
unsigned char bytes[32]; 
unsigned *point1[2]; 



struct hz_mat{ 
 unsigned  incode; 
 unsigned  char mat[32]; 
 }; 

 struct hzlib 
 { int n; 
 struct hz_mat lib[N]; 
 }clib; 

 main( ) 
 { 
  open_hzk( ); 
  creatclib("hz.txt"); 
  writeclib("mylib.h"); 
  } 

  void creatclib(char *name ) 
  { 
    register i,j,found,n; 
    FILE *fp; 
    n=0; 
    fp=fopen("li.txt","rt"); 
    rewind(fp); 
    printf("%x  ",fp); 
    if(fp==NULL) 
    { 
     printf("li.txt not exist!ENTER to system"); 
     exit(1); 
     } 
  while(!feof(fp)) 
    { 
    fread(point1,2,1,fp); 
    printf("%x  %x ",*point1,fp); 
    found=0; 
    for(i=0;i<N&&!found;i++) 
{if(clib.lib[i ].incode==*point1) 
found=1; 
      } 
    if(!found) 
{ 
clib.lib[n].incode=*point1; 
      get_mat(point1,bytes); 
      for(j=0;j<32;j++) 
     clib.lib[n].mat[j]=bytes[j]; 
     n++; 
    } 
     } 
   clib.n=n; 
   fclose(fp); 
   sort( ); 
  } 




  void open_hzk( ) 
   { 
   hzk_p=open("c:\\windows\\command\\pdos95.bat",0); 
   printf("%x  ",hzk_p); 
   if(hzk_p==-1) 
   { 
      printf("the hzk 16 not exist!enter to system\n"); 
      getch( ); 
      exit(1); 
      } 
   } 

   void get_mat(char hz_code[ ],unsigned char buff[ ]) 
    { int i; 
    unsigned char qh,wh; 
    unsigned long offset; 
    qh=hz_code[0]-0xa0; 
    wh=hz_code[1]-0xa0; 
    offset=(94*(qh-1)+(wh-1))*32L; 
    lseek(hzk_p,offset,SEEK_SET); 
    read(hzk_p,buff,32); 
    } 

    void writeclib(char *name) 
    { 
FILE *fp; 
int i,j; 
fp=fopen(name,"w"); 
fprintf(fp,"struct hz_mat{\n"); 
fprintf(fp,"unsigned incode;\n"); 
fprintf(fp,"unsigned char mat[32];\n"); 
fprintf(fp,"};\n"); 
fprintf(fp,"struct hzlib{\n"); 
fprintf(fp,"int n;\n"); 
fprintf(fp,"struct hz_mat lib[%d];\n",clib.n); 
fprintf(fp,"}clib={%d,\n{\n",clib.n); 
j=0; 
while(j<clib.n) 
{ 
fprintf(fp,"{0x%x,",clib.lib[j].incode); 
for(i=0;i<32;i++) 
 { 
  fprintf(fp,"0x%x",(unsigned char )clib.lib[j].mat); 
  if(i!=31) 
  fprintf(fp,","); 
  if((i+1)%8==0&&i!=31) 
  fprintf(fp,"\n"); 
  } 
j++; 
if(j!=clib.n) 
  fprintf(fp,"\n"); 
else 
 fprintf(fp,"}\n"); 
 } 
fprintf(fp,"}\n};\n"); 
fclose(fp); 
} 



   void sort(void) 
   { 
    register int a,b,i,m; 
    unsigned t; 
    char buffer[32]; 
    m=clib.n; 
    for(a=1;a<m;++a) 
     for(b=m-1;b>=a;--b) 
      { 
if(clib.lib[b-1].incode>clib.lib[b ].incode) 
 {t=clib.lib[b-1].incode; 
 clib.lib[b-1].incode=clib.lib[b ].incode; 
 clib.lib[b ].incode=t; 
 for(i=0;i<32;i++) 
  { buffer[i ]=clib.lib[b-1].mat[ i]; 
  clib.lib[b-1].mat[i ]=clib.lib[b ].mat[i ]; 
  clib.lib[b ].mat[i ]=buffer[i ]; 
  } 
} 
      } 
      } ===========================			 
ººÅµËş.txt			 
ÕâÊÇ¸öººÅµËş³ÌĞò£¬ÔÚµ÷ÊÔµÄÊ±ºò£¬ÊäÈëµÄÊı×Ö×îºÃ²»Òª´óÓÚ15£¬ÒòÎªÃ¿´óÒ»¸öÊı
ËùµÃµÄ½á¹ûµÄ²½Öè¶¼»á¶àÒ»±¶¡£Èç¹ûÄãÓĞÄÍĞÄµÈ´ı½á¹ûµÄ»°³ıÍâ¡£ººÅµËşÊÇÔÚÅ·ÖŞ
Á÷ĞĞµÄÒ»ÖÖÓÎÏ·£¬ÓĞa,b,cÈı¸ö¸Í¡£a¸ÍÉÏÓĞÈô¸É¸öÓÉ´óµ½Ğ¡µÄÔ²ÅÌ£¬´óµÄÔÚÏÂÃæ£¬
Ğ¡µÄÔÚÉÏÃæ£¬b,c¶¼ÊÇ¿Õ¸Ë£¬ÇëÄã°Ña¸ËÉÏµÄÔ²ÅÌ¶¼µ¹µ½±ğµÄ¸ËÉÏ£¬»òb»òc£¬ÔÚµ¹ÅÌ
µÄ¹ı³ÌÖĞ²»¿ÉÒÔ´óµÄÑ¹Ğ¡µÄ£¬ÊµÀı³ÌĞòÈçÏÂ£º

#include <stdio.h>
int i=0;
main()
{
	unsigned n;
	printf("Please enter the number of discs: ");
	scanf("%d",&n);
	printf("\tneedle:\ta\t b\t c\n");
	movedisc(n,'a','c','b');
	printf("\t Total: %d\n",i);
	getch();
}
movedisc(n,fromneedle,toneedle,usingneedle)
unsigned n;
char fromneedle,toneedle,usingneedle;
{
	if(n>0)
	{
		movedisc(n-1,fromneedle,usingneedle,toneedle);
		i++;
		switch(fromneedle)
		{
		   case 'a':switch(toneedle)
				 {
		            case 'b':printf("\t[%d]:\t%2d------>%2d\n",i,n,n);
						break;
					case 'c':printf("\t[%d]:\t%2d------------->%2d\n",i,n,n);
						break;
				 }
			   break;
            case 'b':switch(toneedle)
				 {
		            case 'a':printf("\t[%d]:\t%2d<----------%2d\n",i,n,n);
						break;
					case 'c':printf("\t[%d]:\t\t%2d------>%2d\n",i,n,n);
						break;
				 }
			   break;
            case 'c':switch(toneedle)
				 {
		            case 'a':printf("\t[%d]:\t%2d<--------------%2d\n",i,n,n);
						break;
					case 'b':printf("\t[%d]:\t\t%2d<--------%2d\n",i,n,n);
						break;
				 }
			   break;
		}
        movedisc(n-1,usingneedle,toneedle,fromneedle);
	}
}===========================			 
ººÅµËş2.txt			 
move(char getone,char putone)
{
printf("%c-->%c\n",getone,putone);
}
void hanoi(int n,char one,char two,char three)
{
if(n==1)move(one,three);
else{
hanio(n-1,one,three,two);    \*°ÑAÕëµÄn-1¸öÅÌ×ÓÍ¨¹ıCÕëÒÆµ½BÕë*\
move(one,three);             \*°ÑAÕëµÄµÚn¸öÅÌ×ÓÒÆµ½CÕë£¬´òÓ¡³öÀ´*\
hanoi(n-1,two,one,three);    \*°ÑBÕëµÄn-1¸öÅÌ×ÓÍ¨¹ıAÕëÒÆµ½CÕë*\ 
}
}
main()
{
int m;
printf("input the number of diskes:");
scanf("%d",&m);
printf("the step to moving %3d diskes:\n",m);
hanoi(m,'A','B','C');
}
a===========================			 
µÆËşÎÊÌâ.txt			 
//µÆËşÎÊÌâ
#include <iostream.h>
#include <fstream.h>
#include <conio.h>
int sz[11][11],cf=1,k,n,a[20],b[20],c[20];
void shuru(void);
void shuchu(void);
bool panduan(void);
void goujian(void);
void main()
{
    int i,j,lj=0,d;
    shuru();
for(i=1;i<=n;i++)cf=cf*2;
for(i=0;i<cf;i++)
{
    d=i;
    for(j=1;j<=n;j++)
    {sz[n][n-j+1]=d%2;d=d/2;}
    goujian();
    if(panduan()==true){lj=lj+1;shuchu();}
}
cout<<"¹²ÓĞ"<<lj<<"ÖÖÇé¿ö"<<endl;
getch();
}
void goujian(void)
{
    int i1,j1;
    for(i1=n-1;i1>0;i1--)
    {
for(j1=1;j1<=i1;j1++)
{
    if(sz[i1+1][j1]==1&&sz[i1+1][j1]==1)
        sz[i1][j1]=0;
    if(sz[i1+1][j1]==0&&sz[i1+1][j1+1]==0)
        sz[i1][j1]=0;
    if(sz[i1+1][j1]==1&&sz[i1+1][j1+1]==0)
        sz[i1][j1]=1;
    if(sz[i1+1][j1]==0&&sz[i1+1][j1+1]==1)
        sz[i1][j1]=1;
}
}
}
bool panduan()
{
    int pd=1,j1;
for(j1=1;j1<=k;j1++)
    if(sz[a[j1]][b[j1]]!=c[j1]) pd=0;
if(pd==0) return false;else return true;
}
void shuchu(void)
{
    int i2,j2;
for(i2=1;i2<=n;i2++)
{
    for(j2=1;j2<=n-i2;j2++) cout<<" ";
for(j2=1;j2<=i2;j2++) cout<<sz[i2][j2]<<" ";
cout<<endl;
    }
cout<<endl;
}
void shuru(void)
{
//    char filename[18];
ifstream input;
// cout<<"Input filename:";
// cin>>filename;
// input.open(filename);
input.open("dt.txt");
input>>n;
k=0;
do{
    k++;
input>>a[k]>>b[k]>>c[k];
}while((a[k]!=0)&&(b[k]!=0));
k--;
}===========================			 
ºï×ÓºÍÌÒ.txt			 
#include <stdio.h>
main() 
{ 
int x,x1,x2,x3,x4;/*ÎÒÓÃµÄ²»ÖªËã²»ËãÊÇÇî¾Ù·¨£¬ÌÒ×ÓµÄ³õÖµÉèµÄÊÇ£±£°£°*/

 for(x=100;x<10000;x++)     /*ÔÚ£±£°£°£­£±£°£°£°£°Ö®¼ä²éÕÒ£¬»¹¿ÉÒÔÉèµÄ¸ü´óĞ©*/ 
  { if((x-1)%5==0)    /*Âú×ãµÚÒ»Ö»ºï×ÓµÄÌõ¼ş*/
      {x1=(x-1)-(x-1)/5; 
if((x1-1)%5==0)    /*ÕâÀï¾ÍÊÇÂú×ãµÚ¶şÖ»ºï×ÓµÄÌõ¼ş*/
 { x2=(x1-1)-(x1-1)/5; 
   if((x2-1)%5==0)    /*Âú×ãµÚÈıÖ»ºï×ÓµÄÌõ¼ş*/ 
    { x3=(x2-1)-(x2-1)/5; 
      if((x3-1)%5==0)    /*Âú×ãµÚËÄÖ»ºï×ÓµÄÌõ¼ş*/
{ x4=(x3-1)-(x3-1)/5;   
                if((x4-1)%5==0)    /*Âú×ãµÚÎåÖ»ºï×ÓµÄÌõ¼ş*/
    { 
      printf("%d\n",x);    /*£¼£­  »¹¿ÉÒÔÔÚÕâÀïÉèÖÃÂú×ãÁù£¬Æß£¬°ËµÈºï×ÓµÄÌõ¼ş*/ 
    } 
} 
    }                                                                     
 } 
      } 

  } 
}
 ===========================			 
°Ù¼¦°ÙÇ®.txt			 
#include<stdio.h>
main()
{
	int x,y,z,j=0;
	for(x=0;x<=20;x++)
	{
		y=(100-7*x)/4;
		z=100-x-y;
		if(z%3==0&&y>0&&5*x+3*y+z/3==100)
			printf("%2d: cock=%2d hen=%2d chicken=%2d\n",++j,x,y,z);
	}
}===========================			 
¾ØÕó³Ë·¨¶¯Ì¬¹æ»®.txt			 
/*
* File:        multi.c
* Description:  ¾ØÕó³Ë·¨¶¯Ì¬¹æ»®
* Created:      10:20 2001-12-3
* Author:      Justin Hou [mailto:justin_hou@hotmail.com]
*
*/

#include <stdio.h>
#define  N  7

int middle[N][N];

void Show(int, int);

void main()
{
        int i, j, l, k;
        unsigned long m[N+1][N+1], min;
        int r[N+1] = {10, 20, 50, 1, 100, 4, 20, 2};                            /* ¾ØÕóÎ¬Êı */

        /* ³õÊ¼»¯ */
        for (i = 1; i <= N; i++) {
                m[i][i] = 0;
        }
        /* Ã¿´ËÔöÁ¿¼ÓÒ» */
        for (l = 1; l < N; l++) {

                /* ¶ÔÓÚ²îÖµÎª l µÄÁ½¸öÔªËØ */
                for (i = 1; i <= N - l; i++) {
                        j = i + l; 

                        /* ÇóÆä×îĞ¡×éºÏ·½Ê½ */
                        min = m[i][i] + m[i+1][j] + r[i-1] * r[i] * r[j];
                        middle[i][j] = i;
                        for (k = i + 1; k < j; k++) {
                                if (min > m[i][k] + m[k+1][j] + r[i-1] * r[k] * r[j]) {
                                        min = m[i][k] + m[k+1][j] + r[i-1] * r[k] * r[j];
                                        middle[i][j] = k;
                                }
                        }
                        m[i][j] = min;
                }
        }
        printf("M = ");
        Show(1, N);
        printf("\nMultiply Count: %d\n", m[1][N]);
}
                        
void Show(int i, int j)
{
        int k, m;

        if (i == j){
                printf("M%d", i);                              /* Èç¹ûÏÂÒ»¸öÊÇ¾ØÕó£¬Êä³ö  */
        }
        else {
                m = middle[i][j];                              /* ·Ö¸î³É×óÓÒÁ½×é          */
                if (i != m) printf("(");                        /* Èç¹ûÏÂÒ»¸öÏÔÊ¾µÄ²»ÊÇ¾ØÕó */
                Show(i, m);                                    /* ÏÔÊ¾×ó±ßµÄÄÚÈİ          */
                if (i != m) printf(")");                        /* Èç¹ûÉÏÒ»¸öÏÔÊ¾µÄ²»ÊÇ¾ØÕó */
                printf(" x ");                                  /* ´òÓ¡³Ë·¨·ûºÅ            */
                if (m+1 != j) printf("(");                      /* Èç¹ûÏÂÒ»¸öÏÔÊ¾µÄ²»ÊÇ¾ØÕó */
                Show(m + 1, j);                                /* ÏÔÊ¾ÓÒ±ßµÄÄÚÈİ          */
                if (m+1 != j) printf(")");                      /* Èç¹ûÏÂÒ»¸öÏÔÊ¾µÄ²»ÊÇ¾ØÕó */
        }

}===========================			 
void trans(int *p,int n)
{
	int i,j,temp;
	int *pi,*pj;
	for(i=0;i<=n-1;i++)
	{
		for(j=0;j<=i;j++)
    		{
			pi =p +i*n;  /*pÊ×µØÖ· */
			pj =p +j*n;
			temp=pi[j];
			pi[j]=pj[i];
			pj[i]=temp;
    		}

	}
	return;
}

main()
{
	int a[4][4]={ 1, 2, 3, 4,
		      5, 6, 7, 8,
		      9, 10,11,12,
		      13,14,15,16};
	int i,j;
    	printf("before transform:\n");
    	for(i=0;i<=3;i++)
    	{
    		for(j=0;j<=3;j++)
    			printf("  %d",a[i][j]);
 		printf("\n");
      	}
    	trans((int*)a,4);
    	
    	printf("after transform:\n");
    	for(i=0;i<=3;i++)
      	{
      		for(j=0;j<=3;j++)
      			printf("  %d",a[i][j]);
  		printf("\n");
      	}
    	return;
}¾ØÕó×ª»».txt			 
===========================			 
Ó²±Ò·Ö·¨.txt			 
#include "stdio.h" 
main() 
{ 
	int i,j,k,s,n=0;    /*  i,j,k ·Ö±ğ´ú±í Ò»·ÖÓ²±Ò¡¢¶ş·ÖÓ²±ÒºÍÎå·ÖÓ²±Ò*/ 
 	printf("%5c%5c%5c\n",'1','2','5'); 
 	for(i=1;i<100;i++) 
 		for(j=1;j<50;j++) 
 			for(k=1;k<20;k++) 
			{ 
				s=1*i+j*2+k*5; 
 				if (s==100) 
				{ 
  					printf("%5d%5d%5d\n",i,j,k);
  					++n; 
 				} 
			} 
	printf("The ways is %d\n",n); 
} ===========================			 
Éñ¾­ÔªÄ£ĞÍ.txt			 
/*Éñ¾­ÔªÄ£ĞÍ*/
#include < math.h>
#include < stdio.h>
#include < time.h>
#include < stdlib.h>
#include < conio.h>
#define AND1 .571388
#define AND2 .560999
#define OR1 1.149045
#define OR2 1.131896
#define SITA 1
#define NIU .1
#define OMIGA 50

float w[2]; 
float terg[4][3]; 

main()
{int m_result = 1, s; 
 float w1[2]; 
 while(m_result != 5){
	m_result = menu(m_result); 
	date(); 
	switch(m_result){
		case(1):             /*    Ñ§Ï°*/
		case(3):randomize();  /*ÖØĞÂÑ§Ï°*/
			w[0] = random(80)+10; w[0] = w[0]/100.0; 
			w[1] = random(80)+10; w[1] = w[1]/100.0; 
			study(); 
			break; 
		case(2):practic(w);   /*Êµ¼ùĞÂÄ£ĞÍ*/
			break; 
		case(4):printf(" what do you want to see, OR or AND?(1/2) " ); 
			scanf(" %d" , & s); 
			if(s==1){w1[0] = OR1;  w1[1] = OR2;  }
			   else if(s==2){w1[0] = AND1; w1[1] = AND2; }
				else break; 
			practic(w1); 
			break;        /*ÑİÊ¾ÒÑÓĞÄ£ĞÍ*/
		default:{}
		}       /*End Switch*/
	}               /*End While */
 clrscr(); 
 printf(" Good Bye!" ); 
}
menu(int r)
{int r1; 
 clrscr(); 
 printf(" \n\n\n" ); 
 printf(" \t\t1\tStudy a Model\n" );     /*    Ñ§Ï°    */
 printf(" \t\t2\tPratice the model\n" ); /*ÖØĞÂÑ§Ï°    */
 printf(" \t\t3\tDefail the MOdel\n" );  /*Êµ¼ùĞÂÄ£ĞÍ  */
 printf(" \t\t4\tPrepared Model\n" );    /*ÑİÊ¾ÒÑÓĞÄ£ĞÍ*/
 printf(" \t\t5\tEnd\n" );               /*½áÊø        */
 printf(" \n\n\t\tWhat do you want to choice?(%d)" , r); 
 r1 = getche(); 
 if (r1!=13) r = r1-48; 
 return(r); 
}

date()    /*ÏÔÊ¾Ä£ĞÍ*/
{int i, j; 
 clrscr(); 
 for(i = 0; i < 4; i++) 
	 for(j = 0; j< 3; j++){ 
		gotoxy(20+j*4, i+5);  
		printf("%.0f", terg[i][j]);  
		} 
printf("\n\n\tThe quarities:%f, %f \n", w[0], w[1]);  
} 

study() /*Ñ§Ï°×Óº¯Êı*/ 
{float x, y, width;  
	int wrong = 1, i, total = 0; 
	input();  /*andinput(); */ /*orinput();  */ 
	while(wrong){ 
		wrong = 0;  
		for(i = 0; i< 4; i++){
			x = OMIGA*(w[0]*terg[i][0]+w[1]*terg[i][1]-SITA); 
			y = 1.0/(1.0+exp(-x)); 
			width = terg[i][2]-y;  /*Îó²î = "½ÌÊ¦ĞÅºÅ-Y" */ 
			if(fabs(width)>=.01){
			 wrong = 1; 
			 total++; 
			 w[0] = w[0]*(1+width*NIU);     /*¸Ä±äÈ¨Öµ0*/
			 w[1] = w[1]*(1+width*NIU);     /*¸Ä±äÈ¨Öµ1*/
			 if(total> =200)       /*·ÀÖ¹³ÌĞò½øÈëËÀÑ­»·*/
				{error(); return 1; }
			 }
		 }
	 }/*ÈôiµÄËÄ´ÎÑ­»·¾ùÂú×ã" fabs(width)> =.01" Ôòwrong=0, ½áÊøÑ­»·*/
}
practic(quarity) /*Êµ¼ùĞÂÄ£ĞÍ»òÑİÊ¾ÒÑÓĞÄ£ĞÍ, ÓÉquarity[]Öµ¾ö¶¨*/
float quarity[2]; 
{int k, y; 
 float x, width, x1, x2; 
 for(k = 0; k < 4; k++){ 
	 gotoxy(0, 4+k*3);  
	 printf("\nPlease input :x1, x2 ");  
	 scanf("%f, %f", &x1, &x2);  
	 x = OMIGA*(quarity[0]*x1+quarity[1]*x2-SITA); 
	 y = 1.0/(1.0+exp(-x))+.01;  /*¾«¶ÈÎª0.01*/ 
	 printf("\t\t\ty = "%d" , y); 
	 getch();  
	 } 
} 

input() /*µ±Ñ¡Ôñ"Ñ§Ï°"¹¦ÄÜÊ±ÊäÈëÊÂ¼ş*/ 
{int i;  
	printf("Please input the 4 groups data:\n\n");  
	for(i = 0; i< 4; i++){
		printf("\tThe %d group x1, x2, teacher's point: ", i+1);  
		scanf("%f, %f, %f", &terg[i][0], &terg[i][1], &terg[i][2]);  
		} 
	clrscr();  
} 

andinput() 
{terg[0][0] = 1; terg[0][1] = 1; terg[0][2] = 1; 
	terg[1][0] = 1; 
	terg[1][1] = 0; 
	terg[1][2] = 0; 
	terg[2][0] = 0; 
	terg[2][1] = 1; 
	terg[2][2] = 0; 
	terg[3][0] = 0; 
	terg[3][1] = 0; 
	terg[3][2] = 0; 
} 

orinput() 
{terg[0][0] = 1; 
	terg[0][1] = 1; 
	terg[0][2] = 1; 
	terg[1][0] = 1; 
	terg[1][1] = 0; 
	terg[1][2] = 1; 
	terg[2][0] = 0; 
	terg[2][1] = 1; 
	terg[2][2] = 1; 
	terg[3][0] = 0; 
	terg[3][1] = 0; 
	terg[3][2] = 0; 
} 

error() /*³õÊ¼È¨ÖµÑ¡Ôñ²»µ±»òÄ£ĞÍÎŞ·¨ÊµÏÖ(ÈçÒì»òÄ£ĞÍ)Ê±ÍË³ö*/ 
{clrscr();  
	printf("\n\n\n\tBecause the firse QUARITIES's choise is unavailble, \n");  
	printf("\tIt can't get the right result, forveve!");  
} 
 ===========================			 
Çî¾ÙËÑË÷·¨.txt			 
#include <stdio.h>

#define SIDE_N 3
#define LENGTH 3
#define VARIABLES 6

/********¶¨ÒåÈ«¾Ö±äÁ¿*********/
int A,B,C,D,E,F;
int *pt[]={&A,&B,&C,&D,&E,&F};
int *side[SIDE_N][LENGTH]={&A,&B,&C,
			   &C,&D,&E,
			   &E,&F,&A};
int side_total[SIDE_N];

main()
{
	int i,j,t,equal;
	for(j=0;j<VARIABLES;j++)
		*pt[j]=j+1; 	/*³õÊ¼»¯ÅÅÁĞ 1,2,3.....*/

	while(1)
	{
		for(i=0;i<SIDE_N;i++)
		{
			for(t=j=0;j<LENGTH;j++)
				t+=*side[i][j];
			side_total[i]=t;
		}
		for(equal=1,i=0;equal && i<SIDE_N-1;i++)
			if(side_total[i]!=side_total[i+1])	equal=0;
		if(equal)
		{
			for(i=0;i<VARIABLES;i++)
				printf("%4d",*pt[i]);
			printf("\n");
			scanf("%*c");
		}
		for(j=VARIABLES-1;j>0;j--)
			if(*pt[j]>*pt[j-1])	break;
		if(j==0)	break;
		for(i=VARIABLES-1;i>=j;i--)
			if(*pt[i]>*pt[j-1])	break;
		t=*pt[j-1];
		*pt[j-1]=*pt[i];
		*pt[i]=t;
		for(i=VARIABLES-1;i>j;i--,j++)
		{
			t=*pt[j];
			*pt[j]=*pt[i];
			*pt[i]=t;
		}
	}
}

===========================			 
·ûºÅÍ¼ĞÎ.txt			 
#include<stdlib.h> 
#include<stdio.h>
#include<math.h> 
void just(int); 
void fall(int); 
void diamond(int); 
main() 
{ 
int hose,row; 
char ch; 
//clrscr(); 
printf("\t\t\t1.jut     2.fall     3.diamond\n"); 
printf("ÇëÊäÈëÑ¡Ôñ£¬ºÍ¿í¶È£º"); 
scanf("%d%d",&hose,&row); 
while(row!=0)
{
if(row<17&&row>-17)
{
switch(hose) 
{ 
case 1: 
{
   printf("Ensample:"); 
   just(row);
}
break; 
case 2: 
{
   printf("Ensample:"); 
   fall(row); 
}
   break; 
case 3: 
{
    printf("Ensample:"); 
    diamond(row); 
}break; 
default: 
	{
    printf("Error Enter!!"); 
    getch(); 
    exit(1); 
	}
} 
}//end if
else
{
	getch();
	exit(1);
}
printf("ÇëÊäÈëÑ¡Ôñ£¬ºÍ¿í¶È£º"); 
scanf("%d%d",&hose,&row); 
}
}
///***********define function*********/  

void just(int choose) 
{ 
	int i,s,j; 
      for(i=1;i<=choose;i++) 
      { 
         printf("\n\t\t\t\t\t"); 
          for(j=1;j<=2*i-1;j++) 
           { 
             printf("\b"); 
            } 
          for(s=1;s<=2*i-1;s++) 
          { 
          printf("* ");  /*×¢ÒâÕâÀïÃæµÄ¿Õ¸ñ£¬Ò»¶¨Òª¿ÕÒ»¸ñ£¬²»È»½á¹ûÈ«È»²»¶Ô*/ 
          } 
        } 
printf("\n"); 
} 

void fall(int choose) 
{ 
int i,s,j; 
for(i=abs(choose);i>=1;i--) 
{ 
printf("\n\t\t\t\t\t"); 
for(j=1;j<=2*i-1;j++) 
{ 
printf("\b"); 
} 
for(s=1;s<=2*i-1;s++) 
{ 
printf("* ");  ///**Ò»ÑùµÄÇë×¢Òâ¿ÕÒ»¸ñ***/ 
} 
} 
printf("\n"); 
} 

void diamond(int choose) 
{ 
int i,s,j; 
int a,b,c; 
for(i=1;i<=abs(choose);i++) 
{ 
printf("\n\t\t\t\t\t"); 
for(j=1;j<=2*i-1;j++) 
{ 
printf("\b"); 
} 
for(s=1;s<=2*i-1;s++) 
{ 
printf("* "); 
} 
} 

for(a=abs(choose);a>=1;a--) 
{ 
if(a==abs(choose))
printf("\r\t\t\t\t\t"); 
else 
printf("\n\t\t\t\t\t"); 
for(b=1;b<=2*a-1;b++) 
{ 
printf("\b"); 
} 
for(c=1;c<=2*a-1;c++)
{ 
printf("* "); 
} 
} 
printf("\n"); 
} ===========================			 
¼òµ¥Êı¾İ¿â.txt			 
#include <stdio.h>
#include <conio.h>

int main(void)
{
   char label[20];
   char name[20];
   int entries = 0;
   int loop, age;
   double salary;

   struct Entry_struct
   {
      char  name[20];
      int   age;
      float salary;
   } entry[20];

/* Input a label as a string of characters restricting to 20 characters */
   printf("\n\nPlease enter a label for the chart: ");
   scanf("%20s", label);
   fflush(stdin);  /* flush the input stream in case of bad input */

/* Input number of entries as an integer */
  printf("How many entries will there be? (less than 20) ");
  scanf("%d", &entries);

  fflush(stdin);   /* flush the input stream in case of bad input */

/* input a name restricting input to only letters upper or lower case */
   for (loop=0;loop<entries;++loop)
   {
      printf("Entry %d\n", loop);
      printf("  Name   : ");
      scanf("%s", &entry[loop].name);
      fflush(stdin);  /* flush the input stream in case of bad input */

/* input an age as an integer */
      printf("  Age    : ");
      scanf("%d", &entry[loop].age);
      fflush(stdin);  /* flush the input stream in case of bad input */

/* input a salary as a float */
      printf("  Salary : ");
      scanf("%f", &entry[loop].salary);
      fflush(stdin); /* flush the input stream in case of bad input */
   }

/* Input a name, age and salary as a string, integer, and double */
   printf("\nPlease enter your name, age and salary\n");
   scanf("%20s %d %lf", name, &age, &salary);


/* Print out the data that was input */
   printf("\n\nTable %s\n",label);
   printf("Compiled by %s  age %d  $%15.2lf\n", name, age, salary);
   printf("-----------------------------------------------------\n");

   for (loop=0;loop<entries;++loop)
      printf("%4d | %20s | %5d | %15.2lf\n",
         loop + 1,
         entry[loop].name,
         entry[loop].age,
         entry[loop].salary);
   printf("-----------------------------------------------------\n");
   return 0;
}===========================			 
¼òµ¥¼ÆËãÆ÷.txt			 
#include <stdio.h> 

int result=0,valuess=0,k,y=1,l; 
char a,b[1],d[50],r; 

int main (void)
{ 
	while (1)
	{
		int j=0;
       		printf ("%d",result); 
       		printf ("please input a char and number\n"); 
	   	while ((a=getchar())!='\n') 
		{   
			b[ j ]=a; 
		}
		
       		while((r=getchar())!='\n')
	   	{
			d[j]=r;
		   	j++;
	   	}
	   	for(k=0;k<j;k++)
	   	{
			   for(l=0;l<k;l++)
				   y*=10;
		   	   valuess+=((int)d[k]-48)*y;
	   	}
	   	y=1;j=0;
       		if ((b[0]=='q')||(b[0]=='Q')) 
       		{ 
			break;
		} 
       		switch (b[0]) 
       		{ 
			case '+': 
			{
               			result += valuess; 
               			break; 
			}
			case '-':
			{
           	    		result -= valuess; 
           			break; 
			}
			case '*':
			{
               			result *= valuess; 
               			break;
			}
			case '/':
			{
               			if (valuess==0) 
           				printf ("wrong ,please input a number\n"); 
               			else 
                   			result /= valuess; 
               			break;
			}
       			default:
		   	{
           			printf ("unknow the operator%c","a\n"); 
           			break;
		   	}
		}
		valuess=0;	   
	} 
	return (0); 
}
===========================			 
¼òµ¥ÄæÕó.txt			 
# include "stdio.h" 
# define M  3 


void main (  ) 

 { 
  float MAT[M][2*M]; 
  float MAT1[M][M]; 
  float t; 
  int i,j,k,l; 

/***********************************************/ 

   /*¶Ô¾ØÕó½øĞĞ³õÊ¼»¯*/ 
  for(i=0;i<M;i++) 
    for(j=0;j<2*M;j++) 
      MAT1[i][j]='\0'; 
  
  for(i=0;i<M;i++) 
     for(j=0;j<2*M;j++) 
     MAT[i][j]='\0'; 

    /*¶ÔMAT1¾ØÕó¸³³õÖµ  */ 
  for(i=0;i<M;i++) 
    for (j=0;j<M;j++) 
      scanf("%f",&MAT1[i][j]); 


  /*´òÓ¡Ä¿±ê¾ØÕó?*/ 
  printf("Ô­¾ØÕóÎª£º\n"); 
  for (i=0;i<M;i++) 
    { 
     for (j=0;j<M;j++)   
printf("%5.2f",MAT1[i][j]); 
     printf("\n"); 
     } 

/********************************************/ 

    /*¶ÔMAT1¾ØÕó½øĞĞÀ©Õ¹,MAT1¾ØÕóÌí¼Óµ¥Î»Õó£¬ÓÉM*M±ä³É2M*2M¾ØÕó  */ 
  for(i=0;i<M;i++) 
    for(j=0;j<2*M;j++) 
      if (j<M)  MAT[i][j]=MAT1[i][j]; 
     else if (j==M+i)  MAT[i][j]=1; 
   else MAT[i][j]=0; 


    /*¶ÔM¾ØÕó½øĞĞ±ä»»£¬Ê¹µÃÇ°°ë²¿·Ö¾ØÕó³ÉÎªµ¥Î»Õó£¬Ôò  */ 
    /*ºó°ë²¿·Ö¾ØÕó¼´ÎªËùÇó¾ØÕóÄæÕó  */ 
  for(i=0;i<M;i++) 
   { 
    /*¶ÔµÚiĞĞ½øĞĞ¹éÒ»»¯    */ 
     for (j=0;j<2*M;j++) 
     for(k=i+1;k<M;k++) 
MAT[i][j]=MAT[i][j]+MAT[k][j]; 
     t=MAT[i][i]; 
     for(j=i;j<2*M;j++) 
MAT[i][j]=MAT[i][j]/t; 

     /*¶Ô¾ØÕó½øĞĞĞĞ±ä»»£¬Ê¹µÃµÚi ÁĞÖ»ÓĞÒ»¸öÔªËØ²»ÎªÁã£¬ÇÒÎª1*/ 
     for(k=0;k<M;k++) 
if(k!=i) 
  { 
   t=MAT[i][k]; 
   for (l=i;l<2*M;l++) 
   MAT[k][l]=MAT[k][l]-MAT[i][l]*t; 
  } 
     } 


 /*½«ºó°ë²¿·Ö¾ØÕó¼´ËùÇó¾ØÕóÄæÕó´æÈëMAT2¾ØÕó¡£*/ 
  for(i=0;i<M;i++) 
   { 
  
    for(j=0;j<M;j++) 
      MAT1[i][j]=MAT[i][j+M]; 
    printf("\n"); 
      
   } 


/*********************************************/ 

   /*Êä³öËùÇóµÄÄæÕó*/ 
   printf("ÄæÕóÎª£º\n"); 
   for(i=0;i<M;i++) 
   { 
    
     for(j=0;j<M;j++) 
     printf("%5.2f",MAT1[i][j]); 
     printf("\n"); 
   } 

} ===========================			 
ÏßĞÔË³Ğò´æ´¢½á¹¹.txt			 
#include<stdio.h>
#include<stdlib.h>
#define MAX 20
#define ELEMTP int
#define v (*p)

struct sequnce
{
	ELEMTP elem[MAX];
	int len;
};

main()
{
	struct sequnce *pz;
	int i,y,cord;
	void outlin(struct sequnce s);
	void create(struct sequnce *p);
	void insert(struct sequnce *p,int i,int x);
	void deletes(struct sequnce *p,int i);
	do{
		printf("\n        Ö÷²Ëµ¥        \n");
		printf("     1   ½¨Á¢ÏßĞÔ±í     \n");
		printf("     2   ²åÈëÒ»¸öÔªËØ   \n");
		printf("     3   É¾³ıÒ»¸öÔªËØ   \n");
		printf("     4   ½áÊø³ÌĞòÔËĞĞ   \n");
		printf("------------------------------------\n");
		printf(" ÇëÊäÈëÄúµÄÑ¡Ôñ(1, 2, 3, 4) ");
		scanf("%d",&cord);
		switch(cord)
		{
			case 1:
			{
				pz=(struct sequnce *)malloc(sizeof(struct sequnce));
				create(pz);
				outlin(*pz);
			}break;
			case 2:
			{
				printf("ÇëÊäÈë²åÈëµÄÎ»ÖÃ i: ");
				scanf("%d",&i);
				printf("ÇëÊäÈë²åÈëµÄÊı¾İ y: ");
				scanf("%d",&y);
				insert(pz,i,y);
				outlin(*pz);
			}break;
			case 3:
			{
				scanf("%d",&i);
				deletes(pz,i);
				outlin(*pz);
			}break;
			case 4:
				exit(0);
		}
	}while(cord<=4);
}

void outlin(struct sequnce s)
{
	int i;
	for(i=1;i<=s.len;i++)
		printf("%2d%6d\n",i,s.elem[i]);
}

void deletes(struct sequnce *p,int i)
{
	int j;
	if(i<1||i>v.len)
		printf("i, Î»ÖÃ²»´æÔÚ ");
	else
	{
		for(j=i;j<v.len;j++)
			v.elem[j]=v.elem[j+1];
		v.len--;
	}
}

void insert(struct sequnce *p,int i,int x)
{
	int j;
	if(i<1||i>v.len+1)
		printf("i Î»ÖÃ²»´æÔÚ¡£");
	else
	{
		for(j=v.len;j>=i;j--)
			v.elem[j+1]=v.elem[j];
		v.elem[i]=x;
		v.len++;
	}
}

void create(struct sequnce *p)
{
	int i;
	printf("n= ");
	scanf("%d",&(v.len));
	for(i=1;i<=v.len;i++)
	{
		printf("data= ");
		scanf("%d",&(v.elem[i]));
	}
}
===========================			 
ÏßË÷»¯¶ş²æÊ÷.txt			 
#include<stdio.h>
#include<stdlib.h>
struct node
{
	int data;
	struct node *lh,*rh;
	int ltag,rtag;
}*pr,*t,*s[30];

struct node* creat()
{
	struct node *t,*q;
	int i,x,j;
	printf("i,x=");
	scanf("%d%d",&i,&x);
	while((i!=0)&&(x!=0))
	{
		q=(struct node *)malloc(sizeof(struct node));
		q->data=x;
		q->lh=NULL;
		q->rh=NULL;
		s[i ]=q;
		if(i==1)
			t=q;
		else
		{
			j=i/2;
			if((i%2)==0)
				s[j]->lh=q;
			else
				s[j]->rh=q;
		}
		printf("i,x=");
		scanf("%d%d",&i,&x);
	}
	return(t);
}

/*void inthread(struct node *p) //µİ¹éËã·¨
{
	if(p!=NULL)
	{
		inthread(p->lh);
		printf("%6d\t",p->data);
		if(p->lh!=NULL)
			p->ltag=0;
		else
		{
			p->ltag=1;
			p->lh=pr;
		} //½¨Á¢P½ÚµãµÄ×óÏßË÷£¬Ö¸ÏòÇ°Ç÷½ÚµãPR
		if(pr!=NULL)
		{
			if(pr->rh!=NULL)
				pr->rtag=0;
			else
			{
				pr->rtag=1;
				pr->rh=p;
			}//Ç°Ç÷½ÚµãPR½¨Á¢×óÏßË÷£¬Ö¸Ïò½ÚµãP
		}
		pr=p;//pr¸úÉÏp,ÒÔ±ãpÏòºóÒÆ¶¯
		inthread(p->rh);
	}
}*/

void inthread(struct node *t)//·Çµİ¹éËã·¨
{
	int top,bools;
	struct node *p;
	pr=NULL;p=t;top=0;bools=1;
	do{
		while(p!=NULL)
		{
			top++;
			s[top]=p;
			p=p->lh;
		}
		if(top==0)bools=0;
		else
		{
			p=s[top];
			top--;
			printf("%6d",p->data);
			if(p->lh!=NULL)
				p->ltag=0;
			else
			{
				p->ltag=1;
				p->lh=pr;
			} //½¨Á¢P½ÚµãµÄ×óÏßË÷£¬Ö¸ÏòÇ°Ç÷½ÚµãPR
			if(pr!=NULL)
			{
				if(pr->rh!=NULL)
					pr->rtag=0;
				else
				{
					pr->rtag=1;
					pr->rh=p;
				}//Ç°Ç÷½ÚµãPR½¨Á¢×óÏßË÷£¬Ö¸Ïò½ÚµãP
			}
			pr=p;//pr¸úÉÏp,ÒÔ±ãpÏòºóÒÆ¶¯
			p=p->rh;
		}//END else
	}while(bools);
	pr->rh=NULL;
}

main()
{
	pr=NULL;
	t=creat();
	inthread(t);
	pr->rh=NULL;
}===========================			 
#include<stdio.h>
#include<math.h>
main()
{
double y;
int x,m;
for(y=10;y>=-10;y--)
{
m=2.5*sqrt(100-y*y);
for(x=1;x<30-m;x++)
printf(" ");
printf("*");
for(;x<30+m;x++)
printf(" ");
printf("*\n");
}
}»æÖÆÔ².txt			 
===========================			 
±àËæ»úÊı.txt			 
/*×Ô±àËæ»úÊı*/

#include"sys\types.h"
#include"sys\timeb.h"
#include<stdio.h>

#define ALPHA 3.95 /*ºê¶¨ÒåALPHAÖµÎª3.95*/

double init_value(void);
double random(void);

void main()
{
    float rdnmb;int m;
    rdnmb=random()*10+1; /* random()µÃµ½0--0.9µÄĞ¡Êı*/
    m=rdnmb;
    printf("\n%f\n",rdnmb);
    printf("\n%d\n",m);
    getch();
}

double random(void)
{
   static double f=-1.0;
   if(f==-1.0)
     f=init_value();
   else
     f=ALPHA*f*(1.0-f);
   return f;
}

double init_value(void)
{
   double f0;
   struct timeb *pr;
   for(;;)
     {
       ftime(pr);
       f0=pr->millitm*0.9876543*0.001;
       if(f0<0.001)
         continue;
       break;
     }
   return f0;
}===========================			 
ÍøÂç×î¶ÌÂ·¾¶DijkstraËã·¨.txt			 
/*
* File: shortest.c
* Description: ÍøÂçÖĞÁ½µã×î¶ÌÂ·¾¶ Dijkstra Ëã·¨
*              Shortest Path Dijkstra Algorithm
* Created: 2001/11/25
* Author: Justin Hou [mailto:justin_hou@hotmail.com]
*/

#include <stdio.h>
#define true  1
#define false 0
#define I  9999                                /* ÎŞÇî´ó        */
#define N  20                                  /* ³ÇÊĞ¶¥µãµÄÊıÄ¿ */

int cost[N][N] = {
    {0,3,I,I,I,1,I,I,I,I,I,I,I,I,I,I,I,I,I,I},
    {3,0,5,I,I,I,6,I,I,I,I,I,I,I,I,I,I,I,I,I},
    {I,5,0,4,I,I,I,1,I,I,I,I,I,I,I,I,I,I,I,I},
    {I,I,4,0,2,I,I,I,6,I,I,I,I,I,I,I,I,I,I,I},
    {I,I,I,2,0,I,I,I,I,7,I,I,I,I,I,I,I,I,I,I},
    {1,I,I,I,I,0,1,I,I,I,2,I,I,I,I,I,I,I,I,I},
    {I,6,I,I,I,1,0,6,I,I,I,7,I,I,I,I,I,I,I,I},
    {I,I,1,I,I,I,6,0,2,I,I,I,3,I,I,I,I,I,I,I},
    {I,I,I,6,I,I,I,2,0,8,I,I,I,4,I,I,I,I,I,I},
    {I,I,I,I,7,I,I,I,8,0,I,I,I,I,5,I,I,I,I,I},
    {I,I,I,I,I,2,I,I,I,I,0,4,I,I,I,3,I,I,I,I},
    {I,I,I,I,I,I,7,I,I,I,4,0,3,I,I,I,4,I,I,I},
    {I,I,I,I,I,I,I,3,I,I,I,3,0,3,I,I,I,5,I,I},
    {I,I,I,I,I,I,I,I,4,I,I,I,3,0,7,I,I,I,2,I},
    {I,I,I,I,I,I,I,I,I,5,I,I,I,7,0,I,I,I,I,3},
    {I,I,I,I,I,I,I,I,I,I,3,I,I,I,I,0,5,I,I,I},
    {I,I,I,I,I,I,I,I,I,I,I,4,I,I,I,5,0,8,I,I},
    {I,I,I,I,I,I,I,I,I,I,I,I,5,I,I,I,8,0,6,I},
    {I,I,I,I,I,I,I,I,I,I,I,I,I,2,I,I,I,6,0,4},
    {I,I,I,I,I,I,I,I,I,I,I,I,I,I,3,I,I,I,4,0}
};
int dist[N];                                          /* ´æ´¢µ±Ç°×î¶ÌÂ·¾¶³¤¶È */
int v0 = 'A' - 65;                                    /* ³õÊ¼µãÊÇ A          */

void main()
{
    int final[N], i, v, w, min;

    /* ³õÊ¼»¯×î¶ÌÂ·¾¶³¤¶ÈÊı¾İ£¬ËùÓĞÊı¾İ¶¼²»ÊÇ×îÖÕÊı¾İ */
    for (v = 0; v < N; v++) {
    final[v] = false;
        dist[v] = cost[v0][v];
    }

    /* Ê×ÏÈÑ¡v0µ½v0µÄ¾àÀëÒ»¶¨×î¶Ì£¬×îÖÕÊı¾İ */
    final[v0] = true;

    /* Ñ°ÕÒÁíÍâ N-1 ¸ö½áµã */
    for (i = 0; i < N-1; i++) {
        min = I;                                      /* ³õÊ¼×î¶Ì³¤¶ÈÎŞÇî´ó  */
        
        /* Ñ°ÕÒ×î¶ÌµÄ±ß */
        for (w = 0; w < N; w++) {
            if (!final[w] && dist[w] < min) {
                min = dist[w];
                v = w;
        }
        }
        final[v] = true;                              /* ¼ÓÈëĞÂ±ß          */

        for (w = 0; w < N; w++) {                      /* ¸üĞÂ dist[] Êı¾İ  */
            if (!final[w] && dist[v] + cost[v][w] < dist[w]) {
                dist[w] = dist[v] + cost[v][w];
            }
        }
    }

    for (i = 0; i < N; i++) {                          /* ÏÔÊ¾µ½¼àÊÓÆ÷      */
        printf("%c->%c: %2d\t", v0 + 65, i + 65, dist[i]);
    }
}===========================			 
×ÔÎÒ¸´ÖÆ.txt			 
#include "stdio.h" 
main() 
{ 
    	int i; 
    	FILE *in,*out[10]; /* ¶¨ÒåÖ¸ÏòÊäÈë¡¢Êä³öÎÄ¼şµÄÖ¸Õë£¬inÖ¸ÏòÊäÈëÎÄ¼ş£¬¼´³ÌĞò±¾Éí¡£out[10]ÊÇÖ¸ÕëÊı×é£¬Ã¿Ò»¸öÔªËØÖ¸ÏòÒ»¸öÊä³öÎÄ¼ş*/ 
    	char *vir[10]={"vir0.exe","vir1.exe","vir2.exe","vir3.exe","vir4.exe", 
		       "vir5.exe","vir6.exe","vir7.exe","vir8.exe","vir9.exe"}; /*¶¨ÒåÒ»×éÖ¸ÕëÊı×é£¬Ã¿Ò»¸öÖ¸ÕëÔªËØÖ¸ÏòÒ»¸ö×Ö·û´®µÄÊ×µØÖ·£¬¸Ã×Ö·û´®¼´Êä³öÎÄ¼şµÄÎÄ¼şÃû*/ 
	if((in=fopen("vir.exe","rb"))==NULL) /*ÒÔ¶ş½øÖÆ·½Ê½´ò¿ªÎÄ¼ş"vir.exe"£¬Èç¹û³ö´í¾ÍÏÔÊ¾³ö´íĞÅÏ¢*/ 
	{ 
		printf("can't not open the infile"); 
		exit(0); 
	} 
	for(i=0;i<10;i++) /*ÒÀÒÔ¶ş½øÖÆ·½Ê½´Î´ò¿ªÊ®¸öÒª´´½¨µÄÎÄ¼ş£¬Èç¹û³ö´í¾ÍÏÔÊ¾³ö´íĞÅÏ¢*/ 
	{ 
		if((out[i]=fopen(vir[i],"wb"))==NULL) 
		{
			printf("can't not open the %d outfile",i+1); 
			exit(0);
		} 
	} 
	for(i=0;i<10;i++) /*ÒÀ´Î½«vir.exeµÄÄÚÈİ¸´ÖÆµ½Êä³öÎÄ¼şÉÏ£¬¼´vir0.exe¡¢vir1.exe.......µÈÎÄ¼ş»ñµÃvir.exeµÄÄÚÈİ*/ 
	{ 
		while(!feof(in)) 
			fputc(fgetc(in),out[i]);
		rewind(in); 
	} 
	fclose(in); /*¹Ø±Õvir.exe*/ 
	for(i=0;i<10;i++) /*¹Ø±Õvir.0¡¢vir1¡¢vir2.....*/ 
	fclose(out[i]); 
}===========================			 
½Úµã.txt			 
#include <stdio.h>

#define TYPE struct stu
#define LEN sizeof(struct stu)

struct stu
{
      int num;
      int age;
      struct stu *next;
};

TYPE * creatlink(int n);
TYPE * deletelink(TYPE * head,int num);
TYPE * insertlink(TYPE * head,TYPE * pi);
void printlink(TYPE * head);
void destroylink( TYPE * head );

void main(void)
{
    TYPE *head=NULL,*pnum=NULL;
    int n=3,num;

    /* ´´½¨Ò»¸öº¬ n ¸ö½ÚµãµÄÁ´±í */
    printf("input number of node:");
 
    head=creatlink(n);
    printlink(head);
    
    /* É¾³ıÁ´±íÖĞÖµÎª num µÄ½Úµã */
    printf("Input the deleted number:");
    scanf("%d",&num);
    head=deletelink(head,num);
    printlink(head);

    /* ÔÚÁ´±íÖĞ²åÈëÒ»¸ö½Úµã */
    printf("Insert a record\n");
    pnum=(TYPE *)malloc(LEN);
    if(pnum==NULL)
      printf("Pointer is NULL--memory alloc fail!");
    printf("Input the inserted number:");
    scanf("%d",&pnum->num);
    printf("Input the inserted age:");
    scanf("%d",&pnum->age);
    head=insertlink(head,pnum);
    printlink( head );

    /* Ïú»ÙÁ´±í, ÊÍ·Å¶¯Ì¬·ÖÅäµÄÄÚ´æ */
    destroylink( head );
}

/* ´´½¨Ò»¸öº¬ n ¸ö½ÚµãµÄÁ´±í */
TYPE * creatlink(int n)
{
    TYPE *head=NULL, *pf, *pb;
    int i;
    for(i=0;i<n;i++)
    {
        pb=(TYPE *)malloc(LEN);
		printf("record %d\n",i);
        printf("input Number:");
        scanf("%d",&pb->num);
        printf("input age:");
        scanf("%d",&pb->age);
        if(i==0)
          pf=head=pb;
        else 
          pf->next=pb;
        pb->next=NULL;
        pf=pb;
    }
    return(head);
}

/* É¾³ıÁ´±íÖĞÖµÎª num µÄ½Úµã */
TYPE * deletelink(TYPE * head,int num)
{
    TYPE *pf, *pb;
    if(head==NULL)
    {
        printf("\nempty list!\n");
        return NULL;
    }
    pb=head;
    while (pb->num!=num && pb->next!=NULL)
    {
       pf=pb;
       pb=pb->next;
    }
    if(pb->num==num)
    {
        if(pb==head)
          head=pb->next;
        else
          pf->next=pb->next;
        free(pb);
        printf("The node is deleted\n");
    }
    else
      printf("The node not been found!\n");

    return head;
}

/* ÔÚÁ´±íÖĞ²åÈëÒ»¸ö½Úµã */
TYPE * insertlink(TYPE * head,TYPE * pi)
{
    TYPE *pb, *pf;
    pb=head;
    if(head==NULL)
    { 
        head=pi;
        pi->next=NULL; 
    }
    else
    {
      while((pi->num > pb->num)&&(pb->next!=NULL))
      {
          pf=pb;
          pb=pb->next;
      }
      if(pi->num <= pb->num)
      {
          if(head==pb)
            head=pi;
          else
            pf->next=pi;
          pi->next=pb;
      }
      else
      {
          pb->next=pi;
          pi->next=NULL;
      }
   }
   return head;
}

/* ´òÓ¡Á´±íÖĞ¸÷½ÚµãĞÅÏ¢ */
void printlink(TYPE * head)
{
    printf("Number\t\tAge\n");
    while(head!=NULL)
    {
        printf("%d\t\t%d\n",head->num,head->age);
	    head=head->next;
    }
}

/* Ïú»ÙÁ´±í, ÊÍ·Å¶¯Ì¬·ÖÅäµÄÄÚ´æ */
void destroylink(TYPE * head)
{
    TYPE *p, *q;
     
    p = head;
    while( p != NULL )
    {
         q = p->next;
         free(p);
         p = q;
    }
}===========================			 
Æ»¹û·Ö·¨.txt			 
#include<stdio.h>
main()
{
	int b[6],k=2520/6,j,m,x,y,p=0;
	y=x=k-k/2;
	for(m=0,j=7;m<6;m++,j--)
	{
		b[m]=(k-x)+y/j;
		x=y/j;
		y=k;
	}
	for(m=0,y=1;m<6;m++,y++)
	{
		p=p+b[m];
		printf("%dÔ­À´ÓĞ: %d\n",y,b[m]);
	}
	printf("ºÏÎª: %d\n",p);
	getch();
}===========================			 
ÂİĞıÊı×é1.txt			 
#include"stdio.h" 
#include"iostream.h" 

int array[11][11]; 
int temp; 
int ROW; 
void godown(int &m,int &a) 
{ 
for(temp=1;temp<=ROW;temp++) 
if(array[temp][a]==0) 
array[temp][a]=m++; 
a++; 
} 
void goright(int &m,int &b) 
{ 
for(temp=1;temp<=ROW;temp++) 
if(array[b ][temp]==0) 
array[b ][temp]=m++; 
b--; 
} 
void goup(int &m,int &c) 
{ 
for(temp=ROW;temp>0;temp--) 
if(array[temp][c]==0) 
array[temp][c]=m++; 
c--; 
} 
void goleft(int &m,int &d) 
{ 
for(temp=ROW;temp>0;temp--) 
if(array[d][temp]==0) 
array[d][temp]=m++; 
d++; 
} 
void main() 
{ 
int a,b,c,d,max,m; 
cout<<"ÇëÊäÈëçĞĞı·½ÕóµÄÎ¬Êın(²»ÄÜ´óÓÚ10):"; 
cin>>ROW; 
cout<<endl; 
for(a=1;a<=ROW;a++) 
for(b=1;b<=ROW;b++) 
array[a][b ]=0; 
m=1; 
a=d=1; 
b=c=ROW; 
max=ROW*ROW; 
while(m<=max) 
{ 
godown(m,a); 
goright(m,b); 
goup(m,c); 
goleft(m,d); 
} 
for(a=1;a<=ROW;a++) 
{ 
for(b=1;b<=ROW;b++) 
printf("%3d ",array[a][b ]); 
cout<<endl; 
} 
} } ===========================			 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <conio.h> 

#define h 5  // height 
#define w 5  // width 

void main ()  
{ 
    int a[h][w]; 
    int d=0, direct[4][2]= {{0,1},{1,0},{0,-1},{-1,0}}; 
    int x=0, y=0, i; 
    int x1,y1; 
    memset(a, 0, sizeof(a)); 
    for (i=1; i<= h * w; i++) 
{ 
a[y][x]= i; 
// next postion 
x1= x + direct[d][0]; 
y1= y + direct[d][1]; 
// try next postion 
if (x1 <0|| x1 >=w || y1 <0 || y1 >=h ||a[y1][x1]!=0) 
        { 
            // change direct 
            d = (d + 1) % 4; 
            x1= x + direct[d][0]; 
            y1= y + direct[d][1]; 
        } 
        x= x1; 
        y= y1; 
    } 
    
    // display array 
    for (y= 0; y<h; y++) { 
for (x= 0; x<w; x++) 
printf("%4d", a[y][x]); 
printf("\n"); 
} 
getch(); 
return; 
} ÂİĞıÊı×é2.txt			 
===========================			 
ÊÔÌâ.txt			 
#define N sizeof tbl/sizeof tbl[0]  /*È¡µÃÊı×éÓĞ¶àÉÙ¸öÔªËØ*/

int A,B,C,D,E,F;

struct ele
  {
   char vn;
   int *vp;
  }tbl[]={{'A',&A},{'B',&B},{'C',&C},
	  {'D',&D},{'E',&E},{'F',&F}},t;

main()
{
  int k,j,m;
  for(k=0;k<N;k++)
    {
      printf("Enter data for %c\n",tbl[k].vn);
      scanf("%d",tbl[k].vp);
    }
  m=N-1;
  while(m>0)
    {
      for(k=j=0;j<m;j++)
	if(*tbl[j].vp<*tbl[j+1].vp)
	  {
	    t=tbl[j];
	    tbl[j]=tbl[j+1];
	    tbl[j+1]=t;
	    k=j;
	  }
	m=k;
    }
  for(k=0;k<N;k++)
    printf("%c(%d)",tbl[k].vn,*tbl[k].vp);
  printf("\n");
  getch();
}
===========================			 
/*ÕâÊÇÎÒÀÏÊ¦±àµÄ³ÌĞò Andy*/
#include <conio.h>
#include <string.h>
char dd[10][20],space[20];
int a[11],b[11],c[11];

init()
{
	int i,j;
	for(i=0;i<20-1;i++) space[i]=' ';
	space[i]='\0';
	
	for(i=0;i<10;i++)
	{  for(j=0;j<20-1;j++)dd[i][j]=' ';
	   dd[i][j]='\0';
	   for(j=9-i;j<=9+i;j++)dd[i][j]='a'+i;
	}
	for(i=0;i<10;i++) a[i]=i,b[i]=-1,c[i]=-1;
	
	a[10]=2,b[10]=25,c[10]=50;

	for(i=0;i<10;i++)
	{	gotoxy(a[10],10+i);
		cprintf("%s",dd[i]);
	}
}

move(int *s,int *d)
{    int i,j;
	  for(i=0;s[i]==-1&&i<10;i++);
	  gotoxy(s[10],10+i);
	  cprintf("%s",space);
	  for(j=0;d[j]==-1&&j<10;j++);
	  j--;
	  gotoxy(d[10],10+j);
	  cprintf("%s",dd[s[i]]);
	  d[j]=s[i];s[i]=-1;
	  getche();
}

void hanoi(int n,int *s,int *w,int *d)
{	int i;
	if(n==1)move(s,d);
	else
	{	hanoi(n-1,s,d,w);
		move(s,d);
		hanoi(n-1,w,s,d);
	}
}

main()
{
clrscr();
init();
getche();
hanoi(10,a,b,c);
getche();
}ÅµººËş»­Í¼°æ.txt			 
===========================			 
¶ÁĞ´ÎÄ±¾ÎÄ¼ş.txt			 
#include "stdio.h"
void main()
{
   FILE *funny,*printer,*fp;
   char c;

   funny = fopen("TENLINES.TXT","r"); /*´ò¿ªÎÄ±¾ÎÄ¼ş */
   printer = fopen("PRN","w");        /*¿ªÆô´òÓ¡»ú*/
   fp = fopen("weew.TXT","w");
   do{
     c = getc(funny);    /* ´ÓÎÄ¼şÖĞµÃµ½Ò»¸ö×Ö·û */
     if(c != EOF)
     {
       putchar(c);      //ÆÁÄ»ÉÏÏÔÊ¾×Ö·û
       putc(c,printer); // ´òÓ¡»úÉÏ´òÓ¡×Ö·û
     
     }
   }while (c != EOF);    /*ÖØ¸´Ö±µ½ EOF (end of file)  */
   fprintf(fp,"%s",*funny);
   fclose(funny);
   fclose(printer);
   fclose(fp);//¹Ø±Õ´òÓ¡»ú
}
===========================			 
»õÀÉµ£·ÖÖ¦ÏŞ½çÍ¼ĞÎÑİÊ¾.txt			 
/*
* File: tsp.c
* Description: Çó½â»õÀÉµ£ÎÊÌâµÄ·ÖÖ¦ÏŞ½çËã·¨Í¼ĞÎÑİÊ¾
*          Branch-and-bound algorithm to solve the
*            travelling salesman problem. CG demo.
* Use:    tcc tsp graphics.lib
* Created: 2001/11/29 - 2001/12/01
* Author: Justin Hou [mailto:justin_hou@hotmail.com]
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <graphics.h>

#define  MAX_CITIES  15                                /* ³ÇÊĞµÄÊıÄ¿      */
#define  INFINITY    9999                              /* ±íÊ¾ÎŞÇî´ó      */
#define  I          INFINITY                          /* ±íÊ¾ÎŞÇî´ó      */

typedef struct _POINT {                                /* ¶¨ÒåµãµÄ½á¹¹    */
        int x;
        int y;
} POINT;

typedef struct _EDGE {                                /* ¶¨Òå±ßµÄ½á¹¹    */
        int head;
        int tail;
} EDGE;

typedef struct _PATH {                                /* ¶¨ÒåÂ·¾¶½á¹¹    */
        EDGE edge[MAX_CITIES];
        int  edgesNumber;
} PATH;

typedef struct _MATRIX {                              /* ¶¨Òå»¨·Ñ¾ØÕó½á¹¹ */
        int distance[MAX_CITIES][MAX_CITIES];
        int citiesNumber;
} MATRIX;

typedef struct _NODE {                                /* ¶¨ÒåÊ÷½áµã      */
        int bound;                                    /* ½áµãµÄ»¨·ÑÏÂ½ç  */
        MATRIX matrix;                                /* µ±Ç°»¨·Ñ¾ØÕó    */
        PATH path;                                    /* ÒÑ¾­Ñ¡¶¨µÄ±ß    */
} NODE;

int  minDist = INFINITY;
int  GraphDriver;
int  GraphMode;
int  ErrorCode;
POINT city[MAX_CITIES] = {
        {459, 333}, {345, 234}, {362, 245}, {332, 183},
        {323, 343}, {630, 345}, {154, 263}, {213, 112},
        {432, 254}, {534, 223}, {334, 333}, {432, 234},
        { 23, 442}, {600, 400}, {500, 300}
};

int    Simplify(MATRIX *);                    /* ¹éÔ¼¾ØÕó²¢·µ»Ø¹éÔ¼³£Êı  */
int    MatrixSize(MATRIX, PATH);              /* ¼ÆËã¾ØÕó½×Êı            */
EDGE    SelectBestEdge(MATRIX);                /* ·µ»Ø×îºÏÊÊµÄ·ÖÖ¦±ß      */
MATRIX  InitMatrix(void);                      /* ³õÊ¼»¯·ÑÓÃ¾ØÕóÊı¾İ      */
MATRIX  LeftNode(MATRIX, EDGE);                /* ¼ÆËã×óÖ¦½áµã·ÑÓÃ¾ØÕó    */
MATRIX  RightNode(MATRIX, EDGE, PATH);        /* ¼ÆËãÓÒÖ¦½áµã·ÑÓÃ¾ØÕó    */
PATH    AddEdge(EDGE, PATH);                  /* ½«±ßÌí¼Óµ½Â·¾¶Êı×éÖĞ    */
PATH    BABA(NODE *);                          /* ·ÖÖ¦»ØËİº¯Êı B-and-B Ar. */
PATH    MendPath(PATH, MATRIX);                /* ĞŞ²¹Ã»ÓĞÍê³ÉµÄÂ·¾¶      */
void    ShowMatrix(MATRIX);                    /* ÎÄ±¾ÏÔÊ¾·ÑÓÃ¾ØÕó µ÷ÊÔÓÃ  */
void    ShowPath(PATH);                        /* ÎÄ±¾ÏÔÊ¾Â·¾¶            */
void    DrawPath(PATH);                        /* Í¼ĞÎÏÔÊ¾Â·¾¶            */

void main()
{
        PATH path;
        NODE root;
        GraphDriver = DETECT;
        initgraph( &GraphDriver, &GraphMode, "" );
        ErrorCode = graphresult();
        if( ErrorCode != grOk ) {
                printf(" Graphics System Error: %s\n",
                      grapherrormsg(ErrorCode));
                exit(1);
        }

        /* ³õÊ¼»¯Êı¾İ£¬¹éÔ¼£¬½¨Á¢¸ù½áµã */
        root.matrix = InitMatrix();
        root.bound = Simplify(&(root.matrix));
(root.path).edgesNumber = 0;

        /* ½øÈëËÑË÷Ñ­»·£¬×îÖÕ·µ»Ø×î¼ÑÂ·Ïß */
        path = BABA(&root);

        /* ÏÔÊ¾½á¹û */
        DrawPath(path);
        ShowPath(path);
        printf("\nminDist:%d\n", minDist);

        getch();
        closegraph();
}

/* ³õÊ¼»¯Êı¾İ */
MATRIX InitMatrix()
{
        int row, col, n;
        double dx, dy;
        MATRIX c;

        n = MAX_CITIES; /* ÓĞ´ıÍêÉÆÊı¾İ¶ÁÈ¡·½Ê½ */
        c.citiesNumber = n;
        for (row = 0; row < n; row++) {
                putpixel(city[row].x, city[row].y, 5);
                for (col = 0; col < n; col++) {
                        dx = (double)(city[row].x - city[col].x);
                        dy = (double)(city[row].y - city[col].y);
                        /* ÇóÁ½µã¼ä¾àÀë */
                        c.distance[row][col] = (int)sqrt(dx * dx + dy * dy);
                        if (row == col)
                                c.distance[row][col] = INFINITY;
                }
        }
        return c;
}
/*
* Ëã·¨Ö÷ËÑË÷º¯Êı£¬Branch-And-Bound Algorithm Search
*            root ÊÇµ±Ç°µÄ¸ù½áµã£¬ÒÑ¹éÔ¼£¬Êı¾İÍêÉÆ
*/
PATH BABA(NODE* root)
{
        static PATH minPath;
        EDGE selectedEdge;
        NODE *left, *right;

        /* Èç¹ûµ±Ç°¾ØÕó´óĞ¡Îª2£¬ËµÃ÷»¹ÓĞÁ½Ìõ±ßÃ»ÓĞÑ¡£¬¶øÕâÁ½Ìõ±ß±Ø¶¨Ö»ÄÜÓĞÒ»
        * ÖÖ×éºÏ£¬²ÅÄÜ¹¹³ÉÕûÌå»ØÂ·£¬ËùÒÔÊÂÊµÉÏËùÓĞÂ·ÏßÒÑ¾­È·¶¨¡£
        */
        if (MatrixSize(root->matrix, root->path) == 2) {
                if (root->bound < minDist) {
                        minDist = root->bound;
                        minPath = MendPath(root->path, root->matrix);
                        free(root);
                        return (minPath);
                }
        }
        /* ¸ù¾İ×óÏÂ½ç¾¡Á¿´óµÄÔ­ÔòÑ¡·ÖÖ¦±ß */
        setcolor(7);
        selectedEdge = SelectBestEdge(root->matrix);
        line(city[selectedEdge.head].x, city[selectedEdge.head].y,
                city[selectedEdge.tail].x, city[selectedEdge.tail].y);
        putpixel(city[selectedEdge.head].x, city[selectedEdge.head].y, MAGENTA);
        putpixel(city[selectedEdge.tail].x, city[selectedEdge.tail].y, MAGENTA);

        /*
        * ½¨Á¢×óÓÒ·ÖÖ¦½áµã
        */
        right = (NODE *)malloc(sizeof(NODE));
        if (right == NULL) {
                fprintf(stderr,"Error malloc branch.\n");
                exit(-1);
        }
        /* Ê¹×óÖ¦½áµãÕ¾¾ÖÔ­¸ù½áµãÎ»ÖÃ£¬½ÚÊ¡¿Õ¼ä */
        left = root;
        /* ³õÊ¼»¯×óÓÒ·ÖÖ¦½áµã */
        right->matrix = RightNode(root->matrix, selectedEdge, root->path);
        right->bound =        root->bound + Simplify(&(right->matrix));
        right->path = AddEdge(selectedEdge, root->path);

        left->matrix = LeftNode(left->matrix, selectedEdge);
        left->bound = left->bound + Simplify(&(left->matrix));

        /* Èç¹ûÓÒ½áµãÏÂ½çĞ¡ÓÚµ±Ç°×î¼Ñ´ğ°¸£¬¼ÌĞø·ÖÖ¦ËÑË÷ */
        if (right->bound < minDist) {
                BABA(right);
        }
        /* ·ñÔòÉ¾³ıÕâÌõ²»¿ÉÄÜ²úÉú¸ü¼ÑÂ·ÏßµÄËÀÖ¦ */
        else {
                free(right);
        }

        setcolor(BLACK);;
        line(city[selectedEdge.head].x, city[selectedEdge.head].y,
                city[selectedEdge.tail].x, city[selectedEdge.tail].y);
        putpixel(city[selectedEdge.head].x, city[selectedEdge.head].y, MAGENTA);
        putpixel(city[selectedEdge.tail].x, city[selectedEdge.tail].y, MAGENTA);

        /* Èç¹ûÓÒ½áµãÏÂ½çĞ¡ÓÚµ±Ç°×î¼Ñ´ğ°¸£¬¼ÌĞø·ÖÖ¦ËÑË÷ */
        if (left->bound < minDist) {
                BABA(left);
        }
        /*
        *  Èç¹û²»ÊÇ×î³õ¸ù½áµã²ÅÉ¾³ı£¬±ÜÃâ'Null pointer assignment'ÎÊÌâ
        * ¡®Null pointer assingnment'ÎÊÌâÖ¸Èç¹ûÊÖ¶¯É¾³ıÖ÷º¯ÊıÀïÃæµÄÊı¾İ
        *  µ±main()Ö´ĞĞÍê±ÏºóÊÍ·Å¿Õ¼äÊ±ÕÒ²»µ½Êı¾İµÄÖ¸Õë¡£
        */
        else if ((left->path).edgesNumber != 0){
                free(left);
        }

        gotoxy(1, 1);
        printf("Current minDist: %d  ", minDist);
        return (minPath);
}

/* ĞŞ²¹Â·¾¶ */
PATH MendPath(PATH path, MATRIX c)
{
        int row, col;
        EDGE edge;
        int n = c.citiesNumber;

        for (row = 0; row < n; row++) {
                edge.head = row;
                for (col = 0; col < n; col++) {
                        edge.tail = col;
                        if (c.distance[row][col] == 0) {
                                path = AddEdge(edge, path);
                        }
                }
        }
        return path;

}

/* ¹éÔ¼·ÑÓÃ¾ØÕó£¬·µ»Ø·ÑÓÃ¾ØÕóµÄ¹éÔ¼³£Êı */
int Simplify(MATRIX* c)
{
        int row, col, min_dist, h;
        int n = c->citiesNumber;

        h = 0;
        /* ĞĞ¹éÔ¼ */
        for (row = 0; row < n; row++) {
                /* ÕÒ³ö±¾ĞĞ×îĞ¡µÄÔªËØ */
                min_dist = INFINITY;
                for (col = 0; col < n; col++) {
                        if (c->distance[row][col] < min_dist) {
                                min_dist = c->distance[row][col];
                        }
                }
                /* Èç¹û±¾ĞĞÔªËØ¶¼ÊÇÎŞÇî£¬ËµÃ÷±¾ĞĞÒÑ¾­±»É¾³ı */
                if (min_dist == INFINITY) continue;
                /* ±¾ĞĞÃ¿ÔªËØ¼õÈ¥×îĞ¡ÔªËØ */
                for (col = 0; col < n; col++) {
                        if (c->distance[row][col] != INFINITY) {
                                c->distance[row][col] -= min_dist;
                        }
                }
                /* ¼ÆËã¹éÔ¼³£Êı */
                h += min_dist;
        }

        /* ÁĞ¹éÔ¼ */
        for (col = 0; col < n; col++) {
                /* ÕÒ³ö±¾ÁĞ×îĞ¡µÄÔªËØ */
                min_dist = INFINITY;
                for (row = 0; row < n; row++) {
                        if (c->distance[row][col] < min_dist) {
                                min_dist = c->distance[row][col];
                        }
                }
                /* Èç¹û±¾ÁĞÔªËØ¶¼ÊÇÎŞÇî£¬ËµÃ÷±¾ÁĞÒÑ¾­±»É¾³ı */
                if (min_dist == INFINITY) continue;
                /* ±¾ÁĞÔªËØ¼õÈ¥×îĞ¡ÔªËØ */
                for (row = 0; row < n; row++) {
                        if (c->distance[row][col] != INFINITY) {
                                c->distance[row][col] -= min_dist;
                        }
                }
                /* ¼ÆËã¹éÔ¼³£Êı */
                h += min_dist;
        }
        return (h);
}

/* ËÑË÷ËùÓĞ»¨·ÑÎªÁãµÄ±ßÖĞ×îºÏÊÊµÄ£¬Ê¹×óÖ¦ÏÂ½ç¸ü´ó */
EDGE SelectBestEdge(MATRIX c)
{
        int row, col;
        int n = c.citiesNumber;
        int maxD;
        EDGE best, edge;

        /* ËùÓÃº¯ÊıÉùÃ÷ */
        int D(MATRIX, EDGE);

        maxD = 0;
        for (row = 0; row < n; row++) {
                for (col = 0; col < n; col++) {
                        edge.head = row;
                        edge.tail = col;
                        if (!c.distance[row][col] && maxD < D(c, edge)) {
                                maxD = D(c, edge);
                                best = edge;
                        }
                }
        }
        return (best);
}

/* ¼ÆËãÈç¹ûÑ¡ edge ×÷Îª·ÖÖ¦±ß£¬×óÖ¦( ²»º¬ edge )ÏÂ½çµÄÔöÁ¿ */
int D(MATRIX c, EDGE edge)
{
        int row, col, dRow, dCol;
        int n = c.citiesNumber;

        dRow = INFINITY;
        for (col = 0; col < n; col++) {
                if (dRow < c.distance[edge.head][col] && col != edge.tail) {
                        dRow = c.distance[edge.head][col];
                }
        }
        dCol = INFINITY;
        for (row = 0; row < n; row++) {
                if (dCol < c.distance[row][edge.tail] && row != edge.head) {
                        dCol = c.distance[row][edge.tail];
                }
        }
        return (dRow + dCol);
}

/* É¾µôËùÑ¡·ÖÖ¦±ß( left ) */
MATRIX LeftNode(MATRIX c, EDGE edge)
{
        c.distance[edge.head][edge.tail] = INFINITY;
        return c;
}

/* É¾³ıĞĞÁĞºÍ»ØÂ·±ß( right ) */
MATRIX        RightNode(MATRIX c, EDGE edge, PATH path)
{
        int row, col;
        int n = c.citiesNumber;
        EDGE loopEdge;

        /* ÉùÃ÷ËùĞèÒªµÄÇó»ØÂ·±ßº¯Êı */
        EDGE LoopEdge(PATH, EDGE);

        for (col = 0; col < n; col++)
                c.distance[edge.head][col] = INFINITY;
        for (row = 0; row < n; row++)
                c.distance[row][edge.tail] = INFINITY;

        loopEdge = LoopEdge(path, edge);
        c.distance[loopEdge.head][loopEdge.tail] = INFINITY;

        return (c);
}

/* ¼ÆËã»ØÂ·±ßµÄº¯Êı
* ³ıÁË¼ÓÈëµÄĞÂ±ß£¬ µ±Ç°½áµãÂ·Ïß¼¯ºÏÖĞ»¹¿ÉÄÜ°üº¬Ò»Ğ©ÒÑ¾­Ñ¡¶¨µÄ±ß£¬ ÕâĞ©±ß¹¹³É
* Ò»Ìõ»ò¼¸ÌõÂ·¾¶£¬ ÎªÁË²»¹¹³É»ØÂ·£¬ ±ØĞëÊ¹ÆäÖĞ°üº¬ĞÂ±ßµÄÂ·¾¶Í·Î²²»ÄÜÏàÁ¬£¬±¾
* º¯Êı·µ»ØÕâ¸öÍ·Î²ÏàÁ¬µÄ±ß£¬ÒÔ±ã°ÑÕâ¸ö»ØÂ·±ßµÄ³¤¶ÈÉè³ÉÎŞÇî¡£
*/

EDGE LoopEdge(PATH path, EDGE edge)
{
        int i, j;
        EDGE loopEdge;

        /* ×îĞ¡µÄ»ØÂ·±ß */
        loopEdge.head = edge.tail;
        loopEdge.tail = edge.head;

        /* Ñ°ÕÒ»ØÂ·±ßµÄÍ·¶Ëµã£¬¼´°üº¬ĞÂ±ßµÄÂ·¾¶µÄÎ²¶Ëµã */
        for (i = 0; i < path.edgesNumber; i++) {
                for (j = 0; j < path.edgesNumber; j++) {
                        if (loopEdge.head == path.edge[j].head) {
                                /* À©´ó»ØÂ·±ß */
                                loopEdge.head = path.edge[j].tail;
                                break;
                        }
                }
        }
        /* Ñ°ÕÒ»ØÂ·±ßµÄÎ²¶Ëµã£¬¼´°üº¬ĞÂ±ßµÄÂ·¾¶µÄÍ·¶Ëµã */
        for (i = 0; i < path.edgesNumber; i++) {
                for (j = 0; j < path.edgesNumber; j++) {
                        if (loopEdge.tail == path.edge[j].tail) {
                                /* À©´ó»ØÂ·±ß */
                                loopEdge.tail = path.edge[j].head;
                                break;
                        }
                }
        }

        return (loopEdge);
}

/* ½«ĞÂ±ß¼ÓÈëµ½Â·¾¶ÖĞ */
PATH AddEdge(EDGE edge, PATH path)
{
        path.edge[path.edgesNumber++] = edge;
        return path;
}


/* ¼ÆËã»¨·Ñ¾ØÕóµ±Ç°½×Êı */
int MatrixSize(MATRIX c, PATH path)
{
        return (c.citiesNumber - path.edgesNumber);
}

/* ÎÄ±¾·½Ê½ÏÔÊ¾Â·¾¶ */
void ShowPath(PATH path)
{
        int i;
        EDGE edge;
        int n = path.edgesNumber;

        printf("\nThe path is:\n");
        for (i = 0; i < n; i++) {
                edge = path.edge[i];
                printf("(%d,%d)", edge.head + 1, edge.tail + 1);
        }
}

/* Í¼ĞÎ·½Ê½ÏÔÊ¾Â·¾¶ */
void DrawPath(PATH path)
{
        int i;
        POINT a, b;
        int n = path.edgesNumber;

        for (i = 0; i < n; i++) {
                a.x = city[(path.edge[i]).head].x;
                a.y = city[(path.edge[i]).head].y;
                b.x = city[(path.edge[i]).tail].x;
                b.y = city[(path.edge[i]).tail].y;
                line(a.x, a.y, b.x, b.y);
                setcolor(MAGENTA);
                circle(a.x, a.y, 5);
                circle(b.x, b.y, 5);
                setcolor(BLUE);
        }
}


/* ÎÄ±¾·½Ê½ÏÔÊ¾»¨·Ñ¾ØÕó£¬µ÷ÊÔÓÃ */
void ShowMatrix(MATRIX c)
{
        int row, col;
        int n =  c.citiesNumber;

        for (row = 0; row < n; row++) {
                for (col = 0; col < n; col++) {
                        if (c.distance[row][col] != INFINITY) {
                                printf("%4d", c.distance[row][col]);
                        }
                        else {
                                printf("  -");
                        }
                }
                printf("\n");
        }
}===========================			 
»õÀÉµ£ÏŞ½çËã·¨.txt			 
/*
* File: tsp.c
* Description: Çó½â»õÀÉµ£ÎÊÌâµÄ·ÖÖ¦ÏŞ½çËã·¨
*              Branch-and-bound algorithm to solve
*                  the travelling salesman problem.
* Created: 2001/11/29
* Author: Justin Hou [mailto:justin_hou@hotmail.com]
*        C.S.Department of Tongji University
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define TRUE (1)
#define FALSE (0)

#define MAX_CITIES (10)
#define INFINITY  (999)
#define I INFINITY

typedef int bool;

/* ¶¨Òå±ß½á¹¹ */
typedef struct _EDGE {
int head;
int tail;
} EDGE;

/* ¶¨ÒåÂ·¾¶½á¹¹ */
typedef struct _PATH {
EDGE edge[MAX_CITIES];
int  edgesNumber;
} PATH;

/* ¶¨Òå»¨·Ñ¾ØÕó½á¹¹ */
typedef struct _MATRIX {
int distance[MAX_CITIES][MAX_CITIES];
int citiesNumber;
} MATRIX;

/* ¶¨ÒåÊ÷½áµã */
typedef struct _NODE {
int bound; /* ÏàÓ¦ÓÚ±¾½áµãµÄ»¨·ÑÏÂ½ç */
MATRIX matrix; /* µ±Ç°»¨·Ñ¾ØÕó */
PATH path; /* ÒÑ¾­Ñ¡¶¨µÄ±ß */
struct _NODE* left; /* ×óÖ¦ */
struct _NODE* right; /* ÓÒÖ¦ */
} NODE;

int Simplify(MATRIX*);
EDGE SelectBestEdge(MATRIX);
MATRIX LeftNode(MATRIX, EDGE);
MATRIX RightNode(MATRIX, EDGE, PATH);
PATH AddEdge(EDGE, PATH);
PATH BABA(NODE);
PATH MendPath(PATH, MATRIX);
int MatrixSize(MATRIX, PATH);
void ShowMatrix(MATRIX);
void ShowPath(PATH, MATRIX);

main()
{
PATH path;
NODE root = {
0, /* »¨·ÑÏÂ½ç */
{{{I, 1, 2, 7, 5}, /* »¨·Ñ¾ØÕó */
  {1, I, 4, 4, 3},
  {2, 4, I, 1, 2},
  {7, 4, 1, I, 3},
  {5, 3, 2, 3, I}}, 5}, /* ³ÇÊĞÊıÄ¿ */
{{0}, 0}, /* ¾­Àú¹ıµÄÂ·¾¶ */
NULL, NULL /* ×óÖ¦ÓëÓÒÖ¦ */
};

/* ¹éÔ¼£¬½¨Á¢¸ù½áµã */
root.bound += Simplify(&root.matrix);
/* ½øÈëËÑË÷Ñ­»· */
path = BABA(root);
ShowPath(path, root.matrix);

}

/*
* Ëã·¨Ö÷ËÑË÷º¯Êı£¬Branch-And-Bound Algorithm Search
*            root ÊÇµ±Ç°µÄ¸ù½áµã£¬ÒÑ¹éÔ¼£¬Êı¾İÍêÉÆ
*/
PATH BABA(NODE root)
{
int i;
static int minDist = INFINITY;
static PATH minPath;
EDGE selectedEdge;
NODE *left, *right;

puts("Current Root:\n------------");
ShowMatrix(root.matrix);
printf("Root Bound:%d\n", root.bound);

/* Èç¹ûµ±Ç°¾ØÕó´óĞ¡Îª2£¬ËµÃ÷»¹ÓĞÁ½Ìõ±ßÃ»ÓĞÑ¡£¬¶øÕâÁ½Ìõ±ß±Ø¶¨Ö»ÄÜÓĞÒ»ÖÖ×éºÏ£¬
* ²ÅÄÜ¹¹³ÉÕûÌå»ØÂ·£¬ËùÒÔÊÂÊµÉÏËùÓĞÂ·ÏßÒÑ¾­È·¶¨¡£
*/
if (MatrixSize(root.matrix, root.path) == 2) {
if (root.bound < minDist) {
minDist = root.bound;
minPath = MendPath(root.path, root.matrix);
getch();
return (minPath);
}
}
/* ¸ù¾İ×óÏÂ½ç¾¡Á¿´óµÄÔ­ÔòÑ¡·ÖÖ¦±ß */
selectedEdge = SelectBestEdge(root.matrix);
printf("Selected Edge:(%d, %d)\n", selectedEdge.head + 1, selectedEdge.tail + 1);

/* ½¨Á¢×óÓÒ·ÖÖ¦½áµã */
left = (NODE *)malloc(sizeof(NODE));
right = (NODE *)malloc(sizeof(NODE));
if (left == NULL || right == NULL) {
fprintf(stderr,"Error malloc.\n");
exit(-1);
}
/* ³õÊ¼»¯×óÓÒ·ÖÖ¦½áµã */
left->bound = root.bound; /* ¼Ì³Ğ¸¸½áµãµÄÏÂ½ç */
left->matrix = LeftNode(root.matrix, selectedEdge); /* É¾µô·ÖÖ¦±ß */
left->path = root.path; /* ¼Ì³Ğ¸¸½áµãµÄÂ·¾¶£¬Ã»ÓĞÔö¼ÓĞÂ±ß */
left->left = NULL;
left->right = NULL;

right->bound = root.bound;
right->matrix = RightNode(root.matrix, selectedEdge, root.path);/* É¾³ıĞĞÁĞºÍ»ØÂ·±ß */
right->path = AddEdge(selectedEdge, root.path); /* ¼ÓÈëËùÑ¡±ß */
right->left = NULL;
right->right = NULL;

/* ¹éÔ¼×óÓÒ·ÖÖ¦½áµã */
left->bound += Simplify(&left->matrix);
right->bound += Simplify(&right->matrix);

/* Á´½Óµ½¸ù */
root.left = left;
root.right = right;

/* ÏÔÊ¾µ½¼àÊÓÆ÷ */
puts("Right Branch:\n------------");
ShowMatrix(right->matrix);
puts("Left Branch:\n-----------");
ShowMatrix(left->matrix);

/* Èç¹ûÓÒ½áµãÏÂ½çĞ¡ÓÚµ±Ç°×î¼Ñ´ğ°¸£¬¼ÌĞø·ÖÖ¦ËÑË÷ */
if (right->bound < minDist) {
BABA(*right);
}
/* ·ñÔò²»ËÑË÷£¬ÒòÎªÕâÌõÖ¦ÒÑ¾­²»¿ÉÄÜ²úÉú¸ü¼ÑÂ·Ïß */
else {
printf("Current minDist is %d, ", minDist);
printf("Right Branch's Bound(= %d).\n", right->bound);
printf("This branch is dead.\n");
}

/* Èç¹ûÓÒ½áµãÏÂ½çĞ¡ÓÚµ±Ç°×î¼Ñ´ğ°¸£¬¼ÌĞø·ÖÖ¦ËÑË÷ */
if (left->bound < minDist) {
BABA(*left);
}
/* ·ñÔò²»ËÑË÷£¬ÒòÎªÕâÌõÖ¦ÒÑ¾­²»¿ÉÄÜ²úÉú¸ü¼ÑÂ·Ïß */
else {
printf("Current minDist is %d, ", minDist);
printf("Left Branch's Bound(= %d).\n", left->bound);
printf("This branch is dead.\n");
}

printf("The best answer now is %d\n", minDist);
return (minPath);
}

/* ĞŞ²¹Â·¾¶ */
PATH MendPath(PATH path, MATRIX c)
{
int row, col;
EDGE edge;
int n = c.citiesNumber;

for (row = 0; row < n; row++) {
edge.head = row;
for (col = 0; col < n; col++) {
edge.tail = col;
if (c.distance[row][col] == 0) {
path = AddEdge(edge, path);
}
}
}
return path;

}

/* ¹éÔ¼·ÑÓÃ¾ØÕó£¬·µ»Ø·ÑÓÃ¾ØÕóµÄ¹éÔ¼³£Êı */
int Simplify(MATRIX* c)
{
int row, col, min_dist, h;
int n = c->citiesNumber;

h = 0;
/* ĞĞ¹éÔ¼ */
for (row = 0; row < n; row++) {
/* ÕÒ³ö±¾ĞĞ×îĞ¡µÄÔªËØ */
min_dist = INFINITY;
for (col = 0; col < n; col++) {
if (c->distance[row][col] < min_dist) {
min_dist = c->distance[row][col];
}
}
/* Èç¹û±¾ĞĞÔªËØ¶¼ÊÇÎŞÇî£¬ËµÃ÷±¾ĞĞÒÑ¾­±»É¾³ı */
if (min_dist == INFINITY) continue;
/* ±¾ĞĞÃ¿ÔªËØ¼õÈ¥×îĞ¡ÔªËØ */
for (col = 0; col < n; col++) {
if (c->distance[row][col] != INFINITY) {
c->distance[row][col] -= min_dist;
}
}
/* ¼ÆËã¹éÔ¼³£Êı */
h += min_dist;
}

/* ÁĞ¹éÔ¼ */
for (col = 0; col < n; col++) {
/* ÕÒ³ö±¾ÁĞ×îĞ¡µÄÔªËØ */
min_dist = INFINITY;
for (row = 0; row < n; row++) {
if (c->distance[row][col] < min_dist) {
min_dist = c->distance[row][col];
}
}
/* Èç¹û±¾ÁĞÔªËØ¶¼ÊÇÎŞÇî£¬ËµÃ÷±¾ÁĞÒÑ¾­±»É¾³ı */
if (min_dist == INFINITY) continue;
/* ±¾ÁĞÔªËØ¼õÈ¥×îĞ¡ÔªËØ */
for (row = 0; row < n; row++) {
if (c->distance[row][col] != INFINITY) {
c->distance[row][col] -= min_dist;
}
}
/* ¼ÆËã¹éÔ¼³£Êı */
h += min_dist;
}
return (h);
}

/* ËÑË÷ËùÓĞ»¨·ÑÎªÁãµÄ±ßÖĞ×îºÏÊÊµÄ£¬Ê¹×óÖ¦ÏÂ½ç¸ü´ó */
EDGE SelectBestEdge(MATRIX c)
{
int row, col;
int n = c.citiesNumber;
int maxD;
EDGE best, edge;

/* ËùÓÃº¯ÊıÉùÃ÷ */
int D(MATRIX, EDGE);

maxD = 0;
for (row = 0; row < n; row++) {
for (col = 0; col < n; col++) {
edge.head = row;
edge.tail = col;
if (!c.distance[row][col] && maxD < D(c, edge)) {
maxD = D(c, edge);
best = edge;
}
}
}
return (best);
}

/* ¼ÆËãÈç¹ûÑ¡ edge ×÷Îª·ÖÖ¦±ß£¬×óÖ¦£¨²»º¬ edge£©ÏÂ½çµÄÔöÁ¿ */
int D(MATRIX c, EDGE edge)
{
int row, col, dRow, dCol;
int n = c.citiesNumber;

dRow = INFINITY;
for (col = 0; col < n; col++) {
if (dRow < c.distance[edge.head][col] && col != edge.tail) {
dRow = c.distance[edge.head][col];
}
}
dCol = INFINITY;
for (row = 0; row < n; row++) {
if (dCol < c.distance[row][edge.tail] && row != edge.head) {
dCol = c.distance[row][edge.tail];
}
}
return (dRow + dCol);
}

/* É¾µôËùÑ¡·ÖÖ¦±ß */
MATRIX LeftNode(MATRIX c, EDGE edge)
{
c.distance[edge.head][edge.tail] = INFINITY;
return c;
}

/* É¾³ıĞĞÁĞºÍ»ØÂ·±ßºóµÄ¾ØÕó */
MATRIX RightNode(MATRIX c, EDGE edge, PATH path)
{
int row, col;
int n = c.citiesNumber;
EDGE loopEdge;

/* ÉùÃ÷ËùĞèÒªµÄÇó»ØÂ·±ßº¯Êı */
EDGE LoopEdge(PATH, EDGE);

for (col = 0; col < n; col++)
c.distance[edge.head][col] = INFINITY;
for (row = 0; row < n; row++)
c.distance[row][edge.tail] = INFINITY;

loopEdge = LoopEdge(path, edge);
c.distance[loopEdge.head][loopEdge.tail] = INFINITY;

return (c);
}

/* ¼ÆËã»ØÂ·±ßµÄº¯Êı
* ³ıÁË¼ÓÈëµÄĞÂ±ß£¬ µ±Ç°½áµãÂ·Ïß¼¯ºÏÖĞ»¹¿ÉÄÜ°üº¬Ò»Ğ©ÒÑ¾­Ñ¡¶¨µÄ±ß£¬ ÕâĞ©±ß¹¹³ÉÒ»Ìõ»ò
* ¼¸ÌõÂ·¾¶£¬ ÎªÁË²»¹¹³É»ØÂ·£¬ ±ØĞëÊ¹ÆäÖĞ°üº¬ĞÂ±ßµÄÂ·¾¶Í·Î²²»ÄÜÏàÁ¬£¬±¾º¯Êı·µ»ØÕâ¸ö
* Í·Î²ÏàÁ¬µÄ±ß£¬ÒÔ±ã°ÑÕâ¸ö»ØÂ·±ßµÄ³¤¶ÈÉè³ÉÎŞÇî¡£
*/
EDGE LoopEdge(PATH path, EDGE edge)
{
int i, j;
EDGE loopEdge;

/* ×îĞ¡µÄ»ØÂ·±ß */
loopEdge.head = edge.tail;
loopEdge.tail = edge.head;

/* Ñ°ÕÒ»ØÂ·±ßµÄÍ·¶Ëµã£¬¼´°üº¬ĞÂ±ßµÄÂ·¾¶µÄÎ²¶Ëµã */
for (i = 0; i < path.edgesNumber; i++) {
for (j = 0; j < path.edgesNumber; j++) {
if (loopEdge.head == path.edge[j].head) {
/* À©´ó»ØÂ·±ß */
loopEdge.head = path.edge[j].tail;
break;
}
}
}
/* Ñ°ÕÒ»ØÂ·±ßµÄÎ²¶Ëµã£¬¼´°üº¬ĞÂ±ßµÄÂ·¾¶µÄÍ·¶Ëµã */
for (i = 0; i < path.edgesNumber; i++) {
for (j = 0; j < path.edgesNumber; j++) {
if (loopEdge.tail == path.edge[j].tail) {
/* À©´ó»ØÂ·±ß */
loopEdge.tail = path.edge[j].head;
break;
}
}
}

return (loopEdge);
}

/* ½«ĞÂ±ß¼ÓÈëµ½Â·¾¶ÖĞ */
PATH AddEdge(EDGE edge, PATH path)
{
path.edge[path.edgesNumber++] = edge;
return path;
}


/* ¼ÆËã»¨·Ñ¾ØÕóµ±Ç°½×Êı */
int MatrixSize(MATRIX c, PATH path)
{
return (c.citiesNumber - path.edgesNumber);
}

/* ÏÔÊ¾Â·¾¶ */
void ShowPath(PATH path, MATRIX c)
{
int i, dist;
EDGE edge;
int n = path.edgesNumber;

dist = 0;
printf("\nThe path is: ");
for (i = 0; i < n; i++) {
edge = path.edge[i];
printf("(%d, %d) ", edge.head + 1, edge.tail + 1);
dist += c.distance[edge.head][edge.tail];
}
/* printf("[Total Cost: %d]\n", dist); */
}

/* ÏÔÊ¾»¨·Ñ¾ØÕó */
void ShowMatrix(MATRIX c)
{
int row, col;
int n =  c.citiesNumber;

for (row = 0; row < n; row++) {
for (col = 0; col < n; col++) {
if (c.distance[row][col] != INFINITY) {
printf("%3d", c.distance[row][col]);
}
else {
printf("  -");
}
}
putchar('\n');
}
getch();
}===========================			 
ÖÊÒò×Ó.txt			 
#include <stdio.h> 
#include <stdlib.h>

struct node
{
	long factorarray;
	struct node *next;
};
struct node *head,*q,*p;

void factoring(long n) 
{ 
long i; 
for(i=2; i<=n/2; i++)
{ 
	if(n%i==0)
	{  
		q=(struct node*)malloc(sizeof(struct node));
		q->factorarray=i;
		q->next=NULL;
		if(head==NULL)
		{
			head=q;
			p=q;
		}
		else
		{
			p->next=q;
			p=q;
		} 
	} 
} 
}

void deletes()
{
	while(head!=NULL)
	{
		p=head;
		head=p->next;
		free(p);
	}
}

void main() 
{ 
long num; 
head=NULL;
printf("Please input the number you want to find factors: "); 
while(scanf("%ld", &num)) { 
printf("The factors of the number %ld is: \n", num); 
factoring(num); 
p=head;
while(p!=0) 
{
printf("* %ld", p->factorarray);
p=p->next;
} 
printf("\nPlear input the number you want to find factors: ");
deletes(); 
} 
} ===========================			 
Êä³ö×ÔÒÑ.txt			 
char s[]={
        '\t',
        '0',
        '\n',
        '}',
        ';',
        '\n',
        '\n',
        'm',
        'a',
        'i',
        'n',
        '(',
        ')',
        '\n',
        '{',
        '\n',
        '\t',
        'i',
        'n',
        't',
        ' ',
        'i',
        ';',
        '\n',
        '\n',
        '\t',
        'p',
        'r',
        'i',
        'n',
        't',
        'f',
        '(',
        '"',
        'c',
        'h',
        'a',
        'r',
        ' ',
        's',
        '[',
        ']',
        '=',
        '{',
        '\\',
        'n',
        '"',
        ')',
        ';',
        '\n',
        '\t',
        'f',
        'o',
        'r',
        '(',
        'i',
        '=',
        '0',
        ';',
        ' ',
        's',
        '[',
        'i',
        ']',
        ';',
        ' ',
        'i',
        '+',
        '+',
        ')',
        '\n',
        '\t',
        '\t',
        'p',
        'r',
        'i',
        'n',
        't',
        'f',
        '(',
        '"',
        '\\',
        't',
        '%',
        'd',
        ',',
        '\\',
        'n',
        '"',
        ',',
        's',
        '[',
        'i',
        ']',
        ')',
        ';',
        '\n',
        '\t',
        'p',
        'r',
        'i',
        'n',
        't',
        'f',
        '(',
        '"',
        '%',
        's',
        '"',
        ',',
        's',
        ')',
        ';',
        '\n',
        '}',
        '\n',
        0
};

main()
{
        int i;

        printf("char s[]={\n");
        for(i=0; s[i]; i++)
                printf("\t%d,\n",s[i]);
        printf("%s",s);
}

===========================			 
ÃÔ¹¬.txt			 
 #include<stdio.h> 
#define MAX 20    /* the max size of a[] and stack.serial[] */ 
#define OVER 0 
#define OK 1 
struct 
{ 
int serial[MAX]; 
int i; 
}stack; 
int weight,a[MAX]; 
void put(int serial) 
{ 
if(stack.i<MAX-1)stack.serial[++stack.i]=serial; 
else printf("The stack is full!\n"); 
} 
int seek(int num) 
{ 
int p; 
if(a[num]==0)return(OVER); 
else{ 
weight-=a[num]; 
if(weight>0) 
{ 
p=seek(num+1); 
if(p==OK){ 
put(num); 
return(OK); 
} 
else{ 
weight+=a[num]; 
p=seek(num+1); 
if(p==OK)return(OK); 
else return(OVER); 
   } 
} 
if(weight==0){put(num);return(OK);} 
if(weight<0) 
{ 
weight+=a[num]; 
p=seek(num+1); 
if(p==OK)return(OK); 
else return(OVER); 
} 

    } 


} 
main() 
{ 
int temp=0; 
stack.i=-1; 
printf("\nPlease input the total wieght you need:"); 
scanf("%d",&weight); 
printf("Please input the weight of little case(Input '0' to end):"); 
do 
scanf("%d",&a[temp]); 
while(a[temp++]!=0); 
/* printf("\t%d",weight); 
for(temp=0;a[temp]!=0;temp++)printf("\t%d",a[temp]); */ 
temp=seek(0); 
if(temp==OK)printf("Complete\n"); 
else printf("Uncomlete\n"); 
for(;stack.i!=-1;stack.i--){ 
temp=stack.serial[stack.i]; 
printf("\t%d",a[temp]); 
} 
} 

 ===========================			 
ÃÔ¹¬ÎÊÌâ.txt			 
#include<stdio.h>
#define r 64
#define m2 8
#define n2 10
int m=m2-2,n=n2-2;
typedef struct
{
	int x,y;    //ĞĞÁĞ×ø±ê
	int pre;
}sqtype;

sqtype sq[r];
struct moved
{
	int x, y;  //×ø±êÔöÁ¿£¬È¡Öµ-1£¬0£¬1
}move[8];

int maze[m2][n2];

int PATH(int maze[][n2])  //ÕÒÃÔ¹¬mazeµÄÂ·¾¶
{
	int i,j,k,v,front,rear,x,y;
	int mark[m2][n2];
	for(i=0;i<m2;i++)
		for(j=0;j<n2;j++)
			mark[i ][j]=0;
	printf("Please Input move array\n");
	for(i=0;i<8;i++)
	{
		scanf("%d,%d",&move[i ].x,&move[i ].y);
	sq[1].x=1;
	sq[1].y=1;
	sq[1].pre=0;
	front=1;
	rear=1;
	mark[1][1]=1;   //±ê¼ÇÈë¿ÚÒÔµ½´ï¹ı
	while(front<=rear)
	{
		x=sq[front].x;
		y=sq[front].y;    //(x,y)Îª³ö·¢µã
		for(v=0;v<8;v++)  //ËÑË÷(x,y)µÄ8¸öÏàÁÚ(i,j)ÊÇ·ñ¿ÉÒÔµ½´ï
		{
			i=x+move[v].x;
			j=y+move[v].y;
			if((maze[i ][j]==0)&&(mark[i ][j]==0))//(i,j)Îª¿ÉÒÔµ½´ïµã£¬½«ÆğÈë¶Ó
			{
				rear++;
				sq[rear].pre=front;
				mark[i ][j]=1; //±ê¼Ç(i,j)ÒÑ¾­µ½´ï¹ı
			}
			if((i==m)&&(j==n))    //µ½´ï³ö¿Ú
			{
				printf("THE PATH: \n");
				k=rear;
				do
				{
					printf("(%d %d)<-",sq[k].x,sq[k].y);
					k=sq[k].pre;//ÕÒÇ°Ò»µã
				}while(k!=0);//k=0ÊÇÒÑ¾­µ½´ï
				for(i=1;i<19;i++)
					printf("%3d",i);
				printf("\n");
				for(i=1;i<19;i++)
					printf("%3d",sq[i ].x);
				printf("\n");
				for(i=1;i<19;i++)
					printf("%3d",sq[i ].y);
				printf("\n");
				for(i=1;i<19;i++)
					printf("%3d",sq[i ].pre);
				printf("\n");
				return(1);      //³É¹¦·µ»Ø
			}
		}
		front++;   //³ö¶Ó£¬front Ö¸ÏòĞÂµÄ³ö·¢µã
	} 
	}
     //¶Ó¿Õ£¬Ñ­»·½áÊø
	printf("There is no path! \n");
	return(0);   //ÃÔ¹¬Ã»ÓĞÂ·¾¶·µ»Ø
}

main()
{
	int i,j;
	for(i=0;i<10;i++)
	{
		maze[0][i ]=1;
		maze[7][i ]=1;
	}
	for(i=0;i<8;i++)
	{
		maze[i ][0]=1;
		maze[i ][9]=1;
	}
	/*for(i=1;i<7;i++)
		for(j=1;j<9;j++)
		{
			printf("%d %d",i,j);
			scanf("%d",&maze[i ][j]);
		}*/	
	maze[1][1]=0;maze[1][2]=1;maze[1][3]=0;maze[1][4]=1;maze[1][5]=1;maze[1][6]=0;maze[1][7]=1;maze[1][8]=1;
    maze[2][1]=1;maze[2][2]=0;maze[2][3]=0;maze[2][4]=1;maze[2][5]=1;maze[2][6]=0;maze[2][7]=1;maze[2][8]=0;
	maze[3][1]=0;maze[3][2]=1;maze[3][3]=1;maze[3][4]=0;maze[3][5]=0;maze[3][6]=1;maze[3][7]=1;maze[3][8]=1;
	maze[4][1]=1;maze[4][2]=0;maze[4][3]=0;maze[4][4]=1;maze[4][5]=1;maze[4][6]=0;maze[3][7]=0;maze[4][8]=1;
	maze[5][1]=1;maze[5][2]=1;maze[5][3]=0;maze[5][4]=0;maze[5][5]=1;maze[5][6]=1;maze[5][7]=0;maze[5][8]=1;
	maze[6][1]=0;maze[6][2]=1;maze[6][3]=1;maze[6][4]=1;maze[6][5]=0;maze[6][6]=0;maze[6][7]=0;maze[6][8]=0;

	printf("\n");
	for(i=0;i<8;i++)
	{
		for(j=0;j<10;j++)
			printf("%d",maze[i ][j]);
		printf("\n");
	}
	PATH(maze);
}===========================			 
Äæ²¨À¼¼ÆËãÆ÷.txt			 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#define  MAXOP  100
#define  NUMBER  '0'
int getop (char [] );
void push (double);
double pop(void);

int getch(void);
void ungetch(int);

int getop(char s[])
{
int i,c;
while ((s[0]=c=getch())==' '|| c=='\t');
        s[1]='\0';
if(!isdigit(c)&&c!='.')
return c;
        i=0;
if(isdigit(c))
while (isdigit(s[++i]=c=getch()));
if (c=='.')
              while (isdigit(s[++i]=c=getch()));
s[i]='\0';
if (c!=EOF)
ungetch(c);
return NUMBER;
}


#define BUFSIZE 100
char buf[BUFSIZE];
int bufp=0;
int getch(void)
{
return(bufp>0) ? buf[--bufp]:getchar();
}
void ungetch(int c)
{
if (bufp>=BUFSIZE)
  printf("ungetch:too many characters\n");
else
buf[bufp++]=c;
}
main()
{
int type;
double op2;
char s[MAXOP];
while ((type=getop(s))!=EOF)  {
  switch (type)  {
          case NUMBER:
              push(atof(s));
      break;

          case '+':
              push(pop()+pop());
              break;
          case '*':
              push(pop()*pop());
              break;
          case '-':
              op2=pop();
              push(pop()-op2);
              break;
  case '/':
              op2=pop();
              if (op2!=0.0)
                  push(pop()/op2);
              else
                  printf("error:zero divisor\n");
                  break;
          /*case '/n':
                  printf("\t%.8g\n",pop());
                  break;*/
          case 0x0a:
                  printf("\t%.8g\n",pop());
                  break;

          default:
                  printf("error:unknown command %s\n",s);
                  break;
  }
}
return 0;
}


#define MAXVAL 100

int sp=0;
double val[MAXVAL];

void push(double f)
{
if (sp<MAXVAL)
                val[sp++]=f;
else
printf("error:strack full,can't push %g\n",f);
}
double pop(void)
{
if (sp>0)
return val[--sp];
else {
printf("error:stack empty\n");
return 0.0;
}
}

===========================			 
Äæ¾ØÕó.txt			 
#define N 5      /*[×¢]£ºĞŞ¸Ä6ÎªÄãËùÒªµÄ¾ØÕó½×Êı*/ 
#include "stdio.h" 
#include "conio.h" 


/*js()º¯ÊıÓÃÓÚ¼ÆËãĞĞÁĞÊ½,Í¨¹ıµİ¹éËã·¨ÊµÏÖ*/ 
int js(s,n) 
int s[][N],n; 
{int z,j,k,r,total=0; 
int b[N][N];/*b[N][N]ÓÃÓÚ´æ·Å£¬ÔÚ¾ØÕós[N][N]ÖĞÔªËØs[0]µÄÓà×ÓÊ½*/ 
if(n>2) {for(z=0;z<n;z++) 
{for(j=0;j<n-1;j++) 
for(k=0;k<n-1;k++) 
if(k>=z) b[j][k]=s[j+1][k+1]; 
else b[j][k]=s[j+1][k]; 
if(z%2==0) r=s[0][z]*js(b,n-1);  /*µİ¹éµ÷ÓÃ*/ 
else  r=(-1)*s[0][z]*js(b,n-1); 
total=total+r; 
} 
} 
else if(n==2) total=s[0][0]*s[1][1]-s[0][1]*s[1][0]; 
return total; 
} 


/*n_1()º¯ÊıÓÃÓÚÇóÔ­¾ØÕó¸÷ÔªËØ¶ÔÓ¦µÄÓà×ÓÊ½£¬´æ·ÅÔÚÊı×éb[N][N]ÖĞ£¬¶¨ÒåÎªfloatĞÍ*/ 
void n_1(s,b,n) 
int s[][N],n; 
float b[][N]; 
{int z,j,k,l,m,g,a[N][N]; 
for(z=0;z<n;z++) 
   {l=z; 
    for(j=0;j<n;j++) 
{ m=j; 
 for (k=0;k<n-1;k++) 
      for(g=0;g<n-1;g++) 
 { if(g>=m&&k<l) a[k][g]=s[k][g+1]; 
   else if(k>=l&&g<m)  a[k][g]=s[k+1][g]; 
   else if(k>=l&&g>=m) a[k][g]=s[k+1][g+1]; 
   else a[k][g]=s[k][g]; 
 } 
         b[z][j]=js(a,n-1); 
} 
   } 
} 



main() 
{int a[N][N]; 
float b[N][N]; 
int r,z,j; 
float temp; 
//clrscr(); 
printf("Input original data:\n"); 
for(z=0;z<N;z++)              /*ÊäÈëËùĞèÒªµÄÊı¾İ£¬ÎªÕûĞÍÊı¾İ*/ 
    for(j=0;j<N;j++) 
scanf("%d",&a[z][j]); 
printf("\nPress Enter continue......"); 
getchar(); 
//gotoxy(1,1); 
printf("The original matrix is:\n"); 
for(z=0;z<N;z++)/*´òÓ¡Ô­¾ØÕó*/ 
    {for(j=0;j<N;j++) 
 printf("%5d",a[z][j]); 
     printf("\n"); 
    } 
r=js(a,N);                     /*µ÷ÓÃjs()º¯Êı¼ÆËãÔ­¾ØÕóµÄĞĞÁĞÊ½Öµ*/ 
printf("\nThe original matrix hanglieshi is:|A|==%d\n",r);     
if (r==0) printf("Because |A|==0,the original matrix have no nijuzhen!");  /*ÅĞ¶ÏÌõ¼ş:Èô|A|==0£¬ÔòÔ­¾ØÕóÎŞÄæ¾ØÕó£¬·´Ö®Ôò´æÔÚÄæ¾ØÕó*/ 
else 
    {n_1(a,b,N);                                       /*µ÷ÓÃn_1()º¯Êı£¬µÃµ½Ô­¾ØÕó¸÷ÔªËØ¶ÔÓ¦µÄ"Óà×ÓÊ½",´æ·ÅÔÚÊı×éb[N][N]ÖĞ*/ 
     for(z=0;z<N;z++)                                  /*Çó´úÊıÓà×ÓÊ½£¬´ËÊ±b[N][N]ÖĞ´æ·ÅµÄÎªÔ­¾ØÕó¸÷ÔªËØ¶ÔÓ¦µÄ"´úÊıÓà×ÓÊ½"*/ 
          for(j=0;j<N;j++) 
              if((z+j)%2!=0 && b[z][j]!=0) b[z][j]=-b[z][j]; 
     for(z=0;z<N;z++)        /*¶Ôb[N][N]×ªÖÃ,´ËÊ±b[N][N]ÖĞ´æ·ÅµÄÎªÔ­¾ØÕóµÄ°éËæ¾ØÕó*/ 
  for(j=z+2;j<N;j++) 
{temp=b[z][j]; 
b[z][j]=b[j][z]; 
b[j][z]=temp; 
} 
     printf("Because |A|!=0,the original matrix have nijuzhen!\n"); 
     printf("The bansuijuzhen A* is:\n"); 
     for(z=0;z<N;z++)/* ´òÓ¡°éËæ¾ØÕóA* */ 
         {for(j=0;j<N;j++) 
              printf("%4.0f\t",b[z][j]); 
          printf("\n"); 
         } 

     for(z=0;z<N;z++)                                  /*ÇóÄæ¾ØÕó£¬´ËÊ±b[N][N]ÖĞ´æ·ÅµÄÊÇÔ­¾ØÕóµÄÄæ¾ØÕó*/ 
          for(j=0;j<N;j++) 
b[z][j]=b[z][j]/r; 
     printf("\nThe nijuzhen is:(A*)/|A|(|A|=%d)\n",r);  /*´òÓ¡Äæ¾ØÕó*/ 
     for(z=0;z<N;z++) 
    {for(j=0;j<N;j++) 
printf("%8.3f",b[z][j]); 
   printf("\n"); 
  } 
    } 
}
===========================			 
#include "stdio.h" 
float z[4][4],*y=z;   /*¶¨ÒåÒ»¸öÈ«¾Ö¶şÎ¬Êı×éÓÃÀ´´æ·ÅN-1½×Óà×ÓÊ½,ÒòÎªAµÄ°éËæ¾ØÕó³ıÒÔ|A|Ê±»á²úÉúĞ¡Êı£¬Òò´Ë¶¨Òå³Éfloat¶ø·Çint*/ 

int js(int *p,int n)               /*¼ÆËãĞĞÁĞÊ½µÄº¯Êı*/ 
{int k=0,i,s2=0,s1=0,j,s,t; 
printf("\n"); 
for(j=0;j<n;j++) 
  { k=j;t=1; 
   for(i=1;i<=n;i++) 
{ t=t*p[k]; 
 if ((k+1)%n==0) k=k+1; 
 else  k=k+n+1; 
} 
   s1=s1+t; 
  } 
for(j=0;j<n;j++) 
   { k=j;t=1; 
     for(i=1;i<=n;i++) 
{ t=t*p[k]; 
  if (k%n==0) k=k+(2*n-1); 
  else k=k+(n-1); 
} 
    s2=s2+t; 
   } 
s=s1-s2; 
return s; 
} 

void n_1(int b[][4])      /*°Ñ³ıµÚiĞĞjÁĞºóµÄN-1½×¾ØÕóµÄÃ¿¸öÔªËØ¸³¸øÒ»Î¬Êı×éd[]µÄº¯Êı*/ 
{int i,j,e,f,l,m,d[9],*q='\0'; 
int js(int *p,int n); 
printf("\n"); 
for(i=0;i<4;i++) 
   {l=i; 
    for(j=0;j<4;j++) 
{ m=j;q=d; 
 for (e=0;e<4;e++) 
    { if(e==l) continue; 
      for(f=0;f<4;f++) 
 { if(f==m) continue; 
   *q=b[e][f]; 
   q++; 
 } 
    } 
                        /*Ã¿µÃµ½Ò»¸öÒ»Î¬Êı×éd[]µÄÖµ£¬±ãµ÷ÓÃJS()º¯Êı,µÃµ½³ıµÚiĞĞjÁĞºóµÄN-1½×¾ØÕóµÄĞĞÁĞÊ½µÄÖµ,Ò²¼´ÊÇÓà×ÓÊ½M[j]*/ 
          *(y++)=js(d,3); /*²¢°ÑÓà×ÓÊ½µÄÖµ´æ·ÅÔÚÈ«¾Ö¶şÎ¬Êı×éz[]ÖĞ*/ 
} 
   } 
} 


prt(int *p,int n) /*¾ØÕó´òÓ¡º¯Êı*/ 
{int i; 
for(i=0;i<n*n;i++) 
    {if(i%n==0) printf("\n"); 
     printf("%4d",p); 
    } 
} 

main() 
{int a[4][4]={1,2,3,4,5,6,7,8,9,9,11,12,13,14,15,16}; 
int m=4,r,i,j,ch; 
 
printf("The old juzhen is:\n"); 
prt(*a,m); 
r=js(*a,m); 
printf("\nThe old juzhen hanglieshi is:|A|==%d",r); 
printf("\nPress Enter continue......"); /*¿ØÖÆÆÁÄ»*/ 
ch=getchar(); 
if (r==0) printf("Because |A|==0,the juzhen have no nijuzhen!"); 
else 
    {n_1(a);  /*µ÷ÓÃn_1()º¯Êı*/ 

     for(i=0;i<m;i++)     /*Çó´úÊıÓà×ÓÊ½*/ 
          for(j=0;j<m;j++) 
              if((i+j)%2!=0 && z[i][j]!=0) z[i][j]=-z[i][j]; 
     printf("Because |A|!=0,the juzhen have nijuzhen!\n"); 
     printf("The bansuijuzhen A* is:\n");  /*´òÓ¡°éËæ¾ØÕóA* ,i,j¶Ôµ÷ÓÃÓÚ×ªÖÃ*/ 
     for(i=0;i<m;i++) 
         {for(j=0;j<m;j++) 
               if ((i+j)%2==0) printf("%4.0f\t",z[j][i]); 
               else 
           printf("%4.0f\t",z[i][j]); 
          printf("\n"); 
         } 
     printf("\nThe nijuzhen is:(*A)/|A|\n"); 
     for(i=0;i<m;i++)    /*´òÓ¡AµÄÄæ¾ØÕó*/ 
          {for(j=0;j<m;j++) 
if ((i+j)%2==0)  printf("%.3f\t",z[i][j]/r); 
               else 
    printf("%.3f\t",z[j][i]/r); 
           printf("\n"); 
          } 
    } 


}ÄæÕó.txt			 
===========================			 
µİ¶Ñ·¨.txt			 
/*** P402 ***/

#include <stdio.h>
#include <malloc.h>

#define MAXN 1000

void pnext(int a[],int k)
{
	int *b,m=a[0],i,j,r,carry;
	b=(int *)malloc(sizeof(int)*(m+1));
	for(i=1;i<=m;i++)
		b[i]=a[i];
	for(j=1;j<k;j++)
	{
		for(carry=0,i=1;i<=m;i++)
		{
			r=(i<=a[0]?a[i]+b[i]:a[i])+carry;
			a[i]=r%10;
			carry=r/10;
		}
		if(carry)
			a[++m]=carry;
	}
	free(b);
	a[0]=m;
}

void write(int *a,int k)
{
	int i;
	printf("%4d!=",k);
	for(i=a[0];i>0;i--)
		printf("%d",a[i]);
	printf("\n\n");
}

void main()
{
	int a[MAXN],n,k;
	printf("Enter the number n:  ");
	scanf("%d",&n);
	a[0]=1;
	a[1]=1;
	write(a,1);
	for(k=2;k<=n;k++)
	{
		pnext(a,k);
		write(a,k);
		getchar();
	}
}===========================			 
µİ¹éÌÒºï.txt			 
#include<stdio.h> 
int sub(int n) 
{ 
if(n==1){ 
static int i=0; 
do 
{ 
i++; 
} 
while(i%5!=0); 
//printf("*%d*",i); 
return(i+1); 
} 
else 
{ 
int temp; 
do 
{ 
temp=sub(n-1); 
} 
while(temp%4!=0); 
//printf("*%d*",temp); 
return(temp/4*5+1); 
} 
} 
main() 
{ 
int total; 
total=sub(5); 
printf(" %d\n",total); 
} 

===========================			 
/**********µİ¹éÌâ¸ÄÎª·Çµİ¹éÌâÊµÀı ³µÏá********/
#include<stdio.h> 

#define MAX 4 

int stack[MAX],p=-1; 

struct 
{ 
  int num; 
  int sign; 
}train[MAX]; 

void sub() 
{ 
  int inc; 
  if(p==MAX-1) 
    { 
      for(inc=0;inc<=p;inc++)
        printf("%3d",stack[inc]); 
      printf("\n"); 
    }
  else 
    {  
      for(inc=0;inc<MAX;inc++) 
        if(train[inc].sign==0) 
          { 
            train[inc].sign=1; 
            stack[++p]=train[inc].num; /*½øÕ»*/
            sub();                     /*µİ¹é*/
            train[inc].sign=0; 
            p--;                       /*³öÕ»*/ 
          } 
    } 
} 

main() 
{ 
  int temp; 
  for(temp=0;temp<MAX;temp++) 
    { 
      train[temp].num=temp+1; 
      train[temp].sign=0; 
    } 
  printf("The result is:\n"); 
  sub(); 
} 

µİ¹é³µÏá.txt			 
===========================			 
#define NUM 10
#include<stdio.h>
int i[NUM];
main()
{
	int sum,n,total,k,flag,count=0;
	printf("Please enter requried terms(<=10):");
	scanf("%d",&n);
	printf("          their sum:");
	scanf("%d",&total);
	sum=0;
	k=n;
	i[n]=1;
	printf("There are following possible series:\n");
	while(1)
	{
		if(sum+i[k]<total)
			if(k<=1)
			{i[1]=total-sum;flag=1;}
			else
			{
				sum+=i[k--];
				i[k]=i[k+1];
				continue;
			}
			else if(sum+i[k]>total||k!=1)
			{
				sum-=i[++k];flag=0;
			}
			else flag=1;
			if(flag)
			{
				printf("[%d]:",++count);
				for(flag=1;flag<=n;++flag)
					printf("%d",i[flag]);
				printf("\n");
			}
			if(++k>n)
				break;
			sum-=i[k];
			i[k]++;
	}
}µİÍÆ.txt			 
===========================			 
Âß¼­ÒÆ¶¯.txt			 
#include<stdio.h>
int main(void)
{
  int x = 32;
  unsigned int y = 23;

  x<<=1; //Óë (signed int)x<<=2; ÏàÍ¬£¬ÒòÎª±äÁ¿±¾ÉíÊÇsigned
  //(unsigned int)x<<=2;
  //x>>=2;
  //(unsigned int)x>>=2;

  (signed int)y<<=2;
  y<<=2;
  (signed int)y>>=2;
  y>>=2;
  printf("%d %d ",x,y);
  return x+y;
}===========================			 
Á´´®.txt			 
#define NULL 0
struct sstring{
  char *ch;
  int length;
  }




strassign(struct sstring *T,char *chars)
  {int nlenth;
  nlenth=strlen(chars);
  T->length=nlenth;
  T->ch=(char *)malloc(nlenth*sizeof(char)+1);
  if(!T->ch){
      T->length=0;
      return ;
      }
    else{
	 strcpy(T->ch,chars);
	 return ;
	 }
  }




  int strlength(struct sstring *T)
  {  int *S;
     return (S->length);
   }






int strcompare(struct sstring *S,struct sstring *T)
 {if (strcmp(S->ch,T->ch)==0) return 0;
 else if(strcmp(S->ch,T->ch)>0) return 1;
 else  return -1;
 }




 int clearstring(struct sstring *S)
 {
   if (S->ch){
	  free (S->ch);
	  S->ch=NULL;
	  S->length=0;
	  }
	  return 0;
   }




   int concat(struct sstring *T,struct sstring *s1,struct sstring *s2)
  {
     if(T->ch) free(T->ch);
     if(!(T->ch=(char*)malloc((s1->length+s2->length)*sizeof(char))));
     return;
     T->length=s1->length+s2->length;
     strcpy(T->ch,s1->ch);
     strcpy(T->ch,s2->ch);
     return 0;
     }




 int substring(struct sstring *sub,struct sstring *S,int pos,int len)
 {
    char *p;int i;
    if(pos<1 || pos>S->length || len<0 || len>S->length-pos+1)
    return -1;
    if(!len){
    sub->ch=NULL;
    sub->length=0;
    }
    else{
	sub->ch=(char*) malloc(len *sizeof(char)+1);
	p=S->ch;
	for(i=0;i<=pos-1;i++)
	p++;
	}
     strcpy(sub->ch,p);
     return 0;
  }



  main( )
  {
    char inp;
    char *T,*S,*res;
    struct sstring *s1,*s2;
    int pos,len;
    printf("1-------strassing\n");
    printf("2-------strlength\n");
    printf("3-------strcompare\n");
    printf("4-------clearstring\n");
    printf("5-------concat\n");
    printf("6-------substring\n");
    printf("*-------exit");
    printf("please in put 1--6 or *\n\n");
 while(1){
      scanf("%c",&inp);
      switch(inp){
	      case 1:{
		    scanf("%s",&S);
		    res->ch=strassign(s1,S);
		    if(res->ch==0)
			printf("the string is%s",s1->ch);
		    else
		       printf("error"); }
	      case 2: {
		    scanf("%s",&S);
		    s1->length=strlen(S);
		    strcpy(s1->ch,S);
		    res->ch=strlength(S);
		    printf("the length is%d\n",s1->length);}
	      case 3:{
		    scanf("%s",&S);
		    scanf("%s",&T);
		    s1->length=strlen(S);
		    strcpy(s1->ch,S);
		    s2->length=strlen(T);
		    strcpy(s2->ch,T);
		    res->ch=strcompare(S,T);
		    switch(res){
		       case 0:
			    printf("two strings are equle");
		       case 1:
			    printf("the first string > the second string");
		       case -1:
			    printf("the first string < the second string");}
                               }
	     case 4:{
		    res->ch=clearstring(s1);
		    res->ch=clearstring(s2);
		    printf("the string is NULL");}
	     case 5:
		   { scanf("%s",&S);
		    scanf("%s",&T);
		    strcat(&s1,S,T);
		    if(res==0)
		      printf("the string is:%s",s1->ch);
		    }
	     case 6: {
		    scanf("%s_%d_%d",S,&pos,&len);
		    s2->length=strlen(S);
		    strcpy(s2->ch,S);
		    res->ch==substring(&s1,&s2,pos,len);
		    if(res==0)
			printf("the string is:%s",s1->ch);
		    else printf("error");}
	     case *:
		    exit;
       }
      }
    }










===========================			 
Á´Õ».txt			 
# define null 0
  typedef struct stacknode{int data;
		struct stacknode *next;}stacklink;
  typedef struct {stacklink *top;int stacksize;}stackk;

  initlink(stackk *s)
  {s->top=(stacklink *)malloc(sizeof(stacklink));
   s->top->data=0;
   s->top->next=null;
  }

  int poplink(stackk *s)
  {stackk *p;int v;
   if(s->top->next==null) printf("the stackis empty\n");
   else {v=s->top->next->data;
   p=s->top->next;
   s->top=s->top->next;
   free(p);
   return v;
  }
    }

  int pushlink(stackk *s,int x)
      {stackk *p;
      p=(stacklink *)malloc(sizeof(stacklink));
      p->data=x;
      p->next=s->top->next;
      s->top->next=p;
	 }

  int gettop(stackk *s)
    {int e;
     if(s==null) printf("the stack is empty!\n");
     e=s->top->next->data;
     return e;
   }
   display(stackk *s)
   {stackk *p;
    p=s->top->next;
    printf("display the stacklink:\n");
    if (s->top=null) printf("the stacklink is empty!\n");
    else {while(p)
	 {printf("->%d",p->data);
	  p=p->next;}
	  }
   }
   main(stacklink *p)
   {int n,k,i,select,h,x1,x2;
    printf("create a empty stacklink!\n");
    initlink(p);
    printf("input a stacklink length:\n");
    scanf("%d",&n);
    for (i=1;i<=n;i++)
   {printf("input a stacklink value:\n");
    scanf("%d",&k);
    pushlink(p,k);
   }
    printf("select 1:display()\n");
    printf("select 2:pushlink()\n");
    printf("select 3:poplink()\n");
    printf("select 4:gettop()\n");
    printf("input a your select(1-4):\n");
    scanf("%d",&select);
    switch(select)
   {case 1:{display(p);break;}
    case 2:{printf("input a push a value :\n");
	    scanf("%d",&h);
	    pushlink(p,h);
	    display(p);
	    break;}
     case 3:{x1=poplink(p);printf("x1->%d\n",x1);
	     display(p);
	     break;}
     case 4: {x2=gettop(p);printf("x2->%d",x2);
	      break;}
	    }
   }===========================			 
Á´±íÊ®ÎåÈËÅÅĞò.txt			 
/*·¢¸ö°ëÀ­×÷Æ·ÔÚÕâÀï£¬ÒÉÎÊºÜ¶à£¬ÔõÃ´²ÅÄÜÅĞ¶ÏÒ»¸öÈËºÍÆäËûµÄÈË¼û¹ıÃæÄØ£¿
ÀÛµÄÎÒ¶¼Í·ÌÛ*/
#include <stdio.h>
#include <malloc.h>
struct net
{
	int nember[3];
	struct net *next;
}
main()
{
	int g=0,d=0,w=0,b=0,j,k,i=0,a[]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
	//	v=0,h[]={1,8,6,5,3,12,2,13,4,9,14,11,15,7,10};
	struct net *head=NULL,*trail,*body;
	while(b<7)
	{
	for(j=0;j<5;j++)
	{
		body=(struct net*)malloc(sizeof(struct net));
	for(k=0;k<3;k++)
		{
			body->nember[k]=a[i%15];
			i+=1+w;
			/*if(b>3)
			{
			 body->nember[k]=h[v%15];
			 v+=1+d;
			}
			else
			{
			body->nember[k]=a[i%15];
			i+=1+w;
			}*/
			//(i>315)?(i-=1+w):(i+=1+w);
		}
		if(head==NULL)
		{
			head=body;
			trail=body;
		}

		else
		{
			trail->next=body;
			trail=body;
		}
	}
	w+=6;
	//(b>3)?(d+=6):(w+=6);
	b++;
	}
	trail->next=NULL;
	while(head!=NULL)
	{
        printf(" ");
		for(k=0;k<3;k++)
		{
		g++;
		(g%15)?(printf("%d ",head->nember[k])):
		(printf("%d \n",head->nember[k]));
		}
		printf(" ");
		head=head->next;
	}
}===========================			 
Á´±í£¨µİ¹é£©.txt			 
#include 
#include 

struct listNode{ 
int data; 
struct listNode *nextPtr; 
}; 

typedef struct listNode LISTNODE; 
typedef LISTNODE * LISTNODEPTR; 

LISTNODEPTR list(LISTNODEPTR , int); // ´Ë´¦²»Í¬ 
void printlist(LISTNODEPTR); 
void freelist(LISTNODEPTR); // Ôö¼Ó 

main() 
{ 
LISTNODEPTR newPtr=NULL; 

int i,a; 
for(i=0;i<3;i++){ 
printf("please enter a number\n"); 
scanf("%d,",&a); 
newPtr = list(newPtr,a); // ´Ë´¦×¢Òâ 
} 

printlist(newPtr); 

freelist(newPtr); // ´Ë´¦ 

return 0; 
} 

LISTNODEPTR list(LISTNODEPTR sPtr, int a) 
{ 
if ( sPtr != NULL ) 
sPtr->nextPtr = list( sPtr->nextPtr, a ); // µİ¹é£¬ÏòºóÃæµÄ½ÚµãÉÏ¼Ó 
Êı 
¾İ¡£ 
else 
{ 
sPtr =(LISTNODEPTR) malloc(sizeof(LISTNODE)); // ×¢Òâ£¬ÊÇ½ÚµãµÄ 
³ß´ç, 
ÀàĞÍ×ª»» 
sPtr->nextPtr = NULL; 
sPtr->data = a; 
} 
return sPtr; 
} 

void freelist(LISTNODEPTR sPtr ) 
{ 
if ( sPtr != NULL ) 
{ 
freelist( sPtr->nextPtr ); // µİ¹é£¬ ÏÈÊÍ·ÅºóÃæµÄ½Úµã 
free( sPtr ); // ÔÙÊÍ·Å±¾½Úµã 
} 
else // 
return ; // ´ËÁ½ĞĞ¿É²»Òª 
} 



void printlist(LISTNODEPTR currentPtr) 
{ 
if(currentPtr==NULL) 
printf("The list is empty\n"); 
else 
{ 
printf("This list is :\n"); 

while(currentPtr!=NULL) 
{ 
printf("%d-->",currentPtr->data); 
currentPtr=currentPtr->nextPtr; // ÕâÀï²»Ò»Ñù 
} 
printf("NULL\n\n"); 
} 
} 


ÄãÔ­³ÌĞò´íÎóÈçÏÂ£º------------------------- 

> list1.c 
> 
>#include 
>#include 
> 
>struct listNode{ 
> int data; 
> struct listNode *nextPtr; 
>}; 
> 
>typedef struct listNode LISTNODE; 
>typedef LISTNODE * LISTNODEPTR; 
> 
>void list(LISTNODEPTR *, int); 
>void printlist(LISTNODEPTR); 
> 
>main() 
>{ 
> LISTNODEPTR newPtr=NULL; 
> 
> 
> int i,a; 
> for(i=0;i<3;i++){ 
> printf("please enter a number\n"); 
> scanf("%d,",&a); 
> list(&newPtr,a); 
// ´Ë´¦¸øµÄÊÇnewPtrµÄµØÖ·£¬ ×¢Òâ£¡ 

> } 
> 
> printlist(newPtr); 
> 
> free(newPtr); 
// Á´±íµÄÊÍ·Å²»ÄÜÕâÑùĞ´£¬ÕâÑù£¬Ö»ÊÍ·ÅÁËnewPtrÖ¸ÏòµÄÒ»¸ö½Úµã¡£ 
// ¿ÉÒÔÏÈÕÒµ½Á´±íµÄÎ²£¬È»ºó·´ÏòÊÍ·Å£»»òÕß£¬ÀûÓÃ printlistµÄË³ĞòÊÍ·Å£¬ 

// ¸Äº¯Êıprintlist£¬»òÔÚ´Ëº¯ÊıÀïÊÍ·Å¡£ 

> 
> return 0; 
>} 
> 
>void list(LISTNODEPTR *sPtr, int a) 
>{ 
> LISTNODEPTR newPtr,currentPtr; 
> 
> newPtr=malloc(sizeof(LISTNODEPTR)); 
// ´Ë´¦´í£¬ LISTNODEPTR ÊÇÖ¸ÕëÀàĞÍ£¬²»ÊÇ½á¹¹ÀàĞÍ£¬ 
// malloc·µ»ØvoidÖ¸Õë£¬Ó¦¸ÃÇ¿ÖÆ×ª»»ÀàĞÍ£¬´Ë´¦»á¸æ¾¯²»±¨´í£¬µ«Ó¦ÓĞÁ¼ºÃ 
µÄ 
// ±à³Ì·ç¸ñÓëÏ°¹ß¡£ 
> if(newPtr!=NULL){ 
> newPtr->data=a; 
> newPtr->nextPtr=NULL; 
> 
> currentPtr=*sPtr; 
> } 
> if(currentPtr==NULL){ 
// ´Ë´¦Ìõ¼ş²»È·ÇĞ£¬ÒòÎªcurrentPtrÃ»ÓĞ³õÊ¼»¯£¬ 
// ÈçnewPtrÒ»µ©ÎªNULL£¬´Ë¾ä¼°ÒÔÏÂ¾ÍÓĞÎÊÌâ¡£ 

> newPtr->nextPtr=*sPtr; 
> *sPtr=newPtr;} 
// ÔÚµÚÒ»¸öÊıÀ´µÄÊ±ºò£¬mainÀïµÄnewPtrÍ¨¹ısPtr±»ĞŞ¸ÄÖ¸Ïò´Ë½Úµã¡£ 
// ÔÚµÚ¶ş¸öÊıÀ´µÄÊ±ºò£¬mainÀïµÄnewPtrÍ¨¹ısPtr±»ĞŞ¸ÄÖ¸Ïò´Ë½Úµã¡£ 
// ÔÚµÚÈı¸öÊıÀ´µÄÊ±ºò£¬mainÀïµÄnewPtrÍ¨¹ısPtr±»ĞŞ¸ÄÖ¸Ïò´Ë½Úµã¡£ 
// ×îºó£¬mainÀïµÄnewPtrÖ¸ÏòµÚÈı¸öÊı¡£ 
>} 
> 
> 
> 
>void printlist(LISTNODEPTR currentPtr) 
>{ 
> if(currentPtr==NULL) 
> printf("The list is empty\n"); 
> else{ 
> printf("This list is :\n"); 
> 
> while(currentPtr!=NULL){ 
> printf("%d-->",currentPtr->data); 

// mainÀïµÄnewPtrÖ¸ÏòµÚÈı¸öÊı¡£ÄãÏÈ´òÓ¡ÁË×îºóÒ»¸öÊı¡£REµÚ¶ş¸öÎÊÌâ 

> currentPtr=currentPtr->nextPtr->data; 
// ´Ë¾ä·Ç·¨£¬ ÀàĞÍ²»Í¬£¬ ÓĞ¿ÉÄÜÈÃÄãÖ»Ñ­»·Ò»´Î£¬ÈçdataÎª0¡£REµÚÒ»¸öÎÊ 
Ìâ 

> } 
> printf("NULL\n\n"); 
> } 
>} 
// ¶ÔÀàËÆ³ÌĞòÄÜÔËĞĞ£¬µ«½á¹ûËÆÊÇ¶ø·ÇµÄÇé¿ö£¬Ó¦¸Ã¶àÀûÓÃ¸ú×Ùµ÷ÊÔ£¬¿´±äÁ¿µÄ 
±ä 
»¯¡£ 





===========================			 
# define null 0
typedef int status;
typedef struct qnode{int data;
		      struct qnode *next;}linkqlist;
typedef struct
{linkqlist *front;
 linkqlist *rear;} linkqueue;
 void init(linkqueue *p)
{    p->front=(linkqlist *)malloc(sizeof(linkqlist));
     p->rear=p->front;
     (p->front)->next=null;
     }
status destory (linkqueue *q)
        {while (q->front)
              {q->rear=q->front->next;
               free (q->front);
               q->front=q->rear;}
	    }

status empty(linkqueue *q)
        {int v;
         if(q->front==q->rear) v=1;
             else              v=0;
                          return v;}


 status gethead(linkqueue *q)
        {int v;
	if(q->front==q->rear)
           v=-1;
      else
        v=(q->front)->next->data;
        return v;}

status enqueue(linkqueue *q,int e)
	{q->rear->next=(linkqlist *)malloc(sizeof(linkqlist));
         q->rear=q->rear->next;
         if(!q->rear) return -1;
          q->rear->data=e;
          q->rear->next=null;
                     }

status dequeue(linkqueue *q)

       {linkqlist *p;
        int e;
         if (q->front==q->rear)
             printf("the linklist is overflow");
        else p=(q->front)->next;
             (q->front)->next=p->next;
             e=p->data;
            if(q->rear==p)
               q->rear=q->front;
               free(p);
       return(e);}

 void visit(linkqueue *p)
	{linkqueue *q;
	 q=p->front->next;
     printf("display the linklist:\n");
           if (p->front==p->rear)
               printf("the linklist is empty!");
	  else {while(q)
		   {printf("%d->",q->data);
		    q=q->next;}
		    }
		    printf("\n");
		    }

 main(linkqueue *head)
 {int n,i,y;
 int select;
 int a,x1,x3,x5,e;
 int dest;
 printf("create a empty linkqlist\n");
 init(head);
 printf("please input linkqlist length:\n");
 scanf("%d",&n);
 for (i=1;i<=n;i++)
 { printf("please input linkqlist value\n");
 scanf("%d", &a);
 enqueue(head,a);}
 visit(head);
 printf("select 1 --- destory() \n");
 printf("select 2 --- empty  () \n");
 printf("select 3 --- gethead() \n");
 printf("select 4 --- enqueue() \n");
 printf("select 5 --- dequeue() \n");
 printf("please select (1--5):");
 scanf("%d",&select);
 switch (select)
   {case 1: {destory(head);
	    visit(head);
	    break;}
   case 2: {x1=empty(head);
	    if (x1==1) printf("the linklist is empty!");
		      printf("the linklist is full");
		      break;}
   case 3: {x3=gethead(head);
	    printf("head->front->%d\n",x3);
	    break;}
   case 4: {printf("please inster the value:");
		   scanf("%d",&e);
		  enqueue(head,e);
		  visit(head);
		  break;}
   case 5: {x5=dequeue(head);
	    printf("x5",x5);
	    visit(head);
	    break;}
	     }

	  }Á´¶ÓÁĞ.txt			 
===========================			 
¶ÓÁĞ.txt			 
#include<stdio.h>
#include<stdlib.h>
#define ElemType int
#define Q (*qe)

struct quenode 
{
	ElemType data;
	struct quenode *next;
}*p,*s,*h;

struct quefr
{
	struct quenode *front,*rear;
};

main()
{
	struct quefr *que;
	int x,cord;
	void Outlin(struct quefr qq);
	void creat(struct quefr *qe);
	void insert(struct quefr *p,ElemType x);
	ElemType deletes(struct quefr *qe);
	do
	{
		printf("\n");
		printf("           Ö÷²Ëµ¥           \n");
		printf("      1    ½¨Á¢Á´±í¶ÓÁĞ     \n");
		printf("      2    Èë¶ÓÒ»¸öÔªËØ     \n");
		printf("      3    ³ö¶ÓÒ»¸öÔªËØ     \n");
		printf("      4    ½áÊø³ÌĞòÔËĞĞ     \n");
		printf("-------------------------------\n");
		printf("ÇëÊäÈëÄúµÄÑ¡Ôñ(1, 2, 3, 4) ");
		scanf("%d",&cord);
		switch(cord)
		{
			case 1:
				{
					que=(struct quefr *)malloc(sizeof(struct quefr));
					creat(que);
					Outlin(*que);
				}break;
			case 2:
				{
					printf("x=?");
					scanf("%d",&x);
					insert(que,x);
					Outlin(*que);
				}break;
			case 3:
				{
					printf("x=%d\n",deletes(que));
					Outlin(*que);
				}break;
			case 4:
				{
					exit (0);
				}
		}
	}while (cord<=4);
}

void Outlin(struct quefr qq)
{
	p=qq.front->next;      /*Ö¸ÏòµÚÒ»¸öÊı¾İÔªËØ½Úµã */
	while(p!=NULL)
	{
		printf("data=%d\n",p->data);
		p=p->next;
	}
	printf("\n outend \n");
}

void insert(struct quefr *qe,int x)/*Èë¶ÓxÖµµÄ½Úµã*/
{
	s=(struct quenode *)malloc(sizeof(struct quenode));
	s->data=x;
	s->next=NULL;
	Q.rear->next=s;
	Q.rear=s;
}

ElemType deletes(struct quefr *qe)
{
	ElemType x;
	if(Q.front==Q.rear)
	{
		printf("¶ÓÁĞÎª¿Õ¡£ \n");
		x=0;
	}
	else
	{
		p=Q.front->next;
		Q.front->next=p->next;
		if(p->next==NULL)
			Q.rear=Q.front;
		x=p->data;
		free(p);
	}
	return(x);
}

void creat(struct quefr *qe)
{
	int i,n,x;
	printf("n= ");
	scanf("%d",&n);
	h=(struct quenode*)malloc(sizeof(struct quenode));
	h->next=NULL;
	Q.front=h;
	Q.rear=h;
	for(i=1;i<=n;i++)
	{
		scanf("%d",&x);
		insert(qe,x);
	}
}===========================			 
½×³Ëµİ¹é.txt			 
#include <stdio.h>
int factr(int n) 
{ 
	int result,r; 
	if (n==1) return 1; 
		result=factr(n-1)*n; 
	return result; 
} 

main() 
{ 
	int a;
 	a=factr(5); 
 	printf("%d",a); 
} ===========================			 
°¢Ä·Ë¹ÌØÀÊÊı.txt			 
#include<stdio.h>
main()
{
	int i,t,k,a[3];
	printf("There are following Armstrong number smaller than 1000: \n");
	for(i=152;i<1000;i++)
	{
		for(t=0,k=1000;k>=10;t++)
		{
			a[t]=(i%k)/(k/10); /* k/=10  ÏÂÃæÂÔÈ¥*/
			k/=10;
		}
		if(a[0]*a[0]*a[0]+a[1]*a[1]*a[1]+a[2]*a[2]*a[2]==i)
			printf("%d ",i);
	}
}

/*°¢Ä·Ë¹ÌØÀÊÊıÊÇÒ»¸öÕıÕûÊıµÈÓÚÆäµÄ¸÷Î»ÊıµÄÁ¢·½ºÍÈç 153=1*1*1+5*5*5+3*3*3 */===========================			 
·Çµİ¹é.txt			 
void main();

#include <stdio.h>

#define width (rings+1)

void main()
{
  int rings, last, next, x, z[500], s[3];

  printf("how many rings?  "); scanf("%d",&rings);

  for(x=1; x<=rings; x++)  /* put rings on first peg */
      z[x]=width-x;
  for(x=0; x<=2*width; x+=width)  /* set base for each peg  */
      z[x]=1000;

/* if even number of rings, put first ring on second peg; if odd, on third */

  if(rings%2==0)
      {
      last=1; s[2]=0; s[1]=1;
      z[width+1]=z[rings];
      }
  else
      {
      last=2; s[1]=0; s[2]=1;
      z[2*width+1]=z[rings];
      }

  printf("from 1 to %d\n",last+1); s[0]=rings-1;

  while(s[0]+s[1])  /* while first and second pegs aren't empty */
      {
/* next ring to move is smaller of rings on the two pegs not moved onto last */

      if(last==0)  next=z[width+s[1]]<z[2*width+s[2]]?1:2;
      if(last==1)  next=z[s[0]]<z[2*width+s[2]]?0:2;
      if(last==2)  next=z[s[0]]<z[width+s[1]]?0:1;

/* top ring of 'to' peg must be larger and an even 'distance' away */

      if((z[next*width+s[next]])>(z[last*width+s[last]])||((z[last*width+s[last]]-z[next*width+s[next]])%2==0))
		last=3-next-last;

      printf("from %d to %d\n",next+1,last+1);

      s[next]=s[next]-1; s[last]=s[last]+1; /* move from 'next' to 'last' peg */
      z[last*width+s[last]]=z[next*width+s[next]+1];
      }
}
===========================			 
Ë³ĞòÕ».txt			 

#define m 100
typedef struct
{
	int stack[m];
  	int top;
}stackstru;

 init(stackstru *s)	/*×°ÈëÕ»*/
 {
 	s->top=0;
  	return 1;
 }

 int push(stackstru *s,int x)    /*ÈëÕ»²Ù×÷*/
 {
 	if (s->top==m)
     		printf("the stack is overflow!\n");
  	else
  	{
  		s->top=s->top+1;
  		s->stack[s->top]=x;
  	}
 }

 void display(stackstru *s)   /*ÏÔÊ¾Õ»ËùÓĞÊı¾İ*/
 {
 	if(s->top==0)
     		printf("the stack is empty!\n");
  	else
  	{
  		while(s->top!=0)
 		{
 			printf("%d->",s->stack[s->top]);
   			s->top=s->top-1;
   		}
   	}
 }

 int pop(stackstru *s)	/*³öÕ»²Ù×÷²¢·µ»Ø±»É¾³ıµÄÄÇ¸ö¼ÇÂ¼*/
 {
 	int y;
  	if(s->top==0)
  		printf("the stack is empty!\n");
  	else
  	{
  		y=s->stack[s->top];
  		s->top=s->top-1;
  		return y;
  	}
 }
 
 int gettop(stackstru *s)  /*µÃµ½Õ»¶¥Êı*/
 { 
 	int e;
  	if(s->top==0)
  		return 0;
  	else 
  		e=s->stack[s->top];
  	return e;
 }

 main(stackstru *p)
 {
 	int n,i,k,h,x1,x2,select;
  	printf("create a empty stack!\n");
  	init(p);
  	printf("input a stack length:\n");
  	scanf("%d",&n);
  	for(i=0;i<n;i++)
  	{
  		printf("input a stack value:\n");
   		scanf("%d",&k);
   		push(p,k);
  	}
   	printf("select 1:display()\n");
   	printf("select 2:push()\n");
   	printf("select 3:pop()\n");
   	printf("select 4:gettop()\n");
   	printf("input a your select(1-4):\n");
   	scanf("%d",&select);
   	switch(select)
  	{
  		case 1:
  		{
  			display(p);
	 		break;
	 	}
   		case 2:
   		{
   			printf("input a push a value:\n");
	  		scanf("%d",&h);
	  		push(p,h);
	  		display(p);
	  		break;
	  	}
   		case 3:
   		{
   			x1=pop(p);
	    		printf("x1->%d\n",x1);
	    		display(p);
	    		break;
	    	}
   		case 4:
   		{
   			x2=gettop(p);
			printf("x2->%d",x2);
			break;
		}
	 }
}
===========================			 
Ë³Ğò±í.txt			 
 # define maxsize 50

 struct sqlist
 { 
 	int sqlist[maxsize];
     	int key;
     	int size;
     	int data;
 };

 setnull(struct sqlist *p)  /*×°Èë±í*/
 {
 	p->size=0;
 }
 
 int length(struct sqlist *p)  /*±í³¤¶È*/
 {
  	return(p->size);
 }
 
 get(struct sqlist *p,int i)  /*È¡µÃÒ»¸öÔªËØ*/
 {
    	if (i<1 && i>p->size) 
    		printf("´íÎó");
      	else 
      		printf("¸ÃĞòºÅ¶ÔÓ¦µÄÔªËØÎª£º%d",p->sqlist[i]);
 }
 
 locate(struct sqlist *p,int x)  /*²éÕÒÔªËØ*/
 {  
 	int i=0;
    	while (i<p->size && p->sqlist[i]!=x) 
    		i++;
    		
      	if (i==p->size )
      		printf("´íÎó");
	else printf("¸ÃÔªËØµÚÒ»´Î³öÏÖµÄÎ»ÖÃ£º%d",i);
 }
 
 insert(struct sqlist *p,int i,int x)
 {
 	int j;
     	if (i<1 && i>p->size+1)
		printf("Î»ÖÃ²»ÕıÈ·²»ÄÜĞĞ²åÈë\n");
 	else
  	{
		p->size++;
		for (j=p->size-1;j>=i;j--)
			p->sqlist[j]=p->sqlist[j-1];
		p->sqlist[j]=x;
  	}
 	for(j=1;j<p->size;j++)
 		printf("ÏßĞÔ±íÎª:%d->",p->sqlist[j]);
 }
 
 void delete(struct sqlist *p,int i)
 {
 	int j;
 	if (i<1 || i>p->size)
		printf("´íÎó");
 	else
	{
 		for (j=i;j<p->size;j++)
			p->sqlist[j]=p->sqlist[j+1];
		p->size--;
 	}
 	printf("´ËÏßĞÔ±íÎª£º");
   	for (i=1;i<=p->size;i++)
		printf("%d->",p->sqlist[i]);
 }

 insertsort(struct sqlist *p,int n)
 {
 	int i,j;
	for(i=2;i<=n;i++)
	{
		p->sqlist[0]=p->sqlist[i];
		j=i-1;
		while(j>0 && p->sqlist[0]<p->sqlist[j])
		{
			p->sqlist[j+1]=p->sqlist[j]; j--;}
 			p->sqlist[j+1]=p->sqlis	t[0];
		}
		printf("shen xu;\n");
		for (i=1;i<=n;i++)
			printf("%d",p->sqlist[i]);
		printf("\n");
		for(i=1;i<=n;i++)
			printf("%d",p->sqlist[i]);
		printf("\n");
	}
}

display(struct sqlist *p)
{
	int j;
	if (p->size==0)
		printf("´Ë±íÎª¿ÕÎŞ·¨ÏÔÊ¾£¡");
	else 
		printf("the list");
	if (p->size==1)
		printf("%d",p->sqlist[p->size]);
 	else
 	{
 		for(j=1;j<p->size;j++)
 			printf("%d->",p->sqlist[j]);
		printf("%d",p->sqlist[j]);

 	}
}

main()
{
	int i,select,a,j;int w;
	struct sqlist *p;
	struct sqlist l;
	setnull(&l);
	printf("ÇëÊäÈëÊı¾İ£º\n");
 	p=&l ;
  	p->size=0;
  	for (i=1;i<5; i++)
     	{
     		scanf("%d",&l.sqlist[i]);
     		p->size++;
     	}
	printf("\n");
	printf("1:ÖÃ¿Õ±í£¡ \n");
  	printf("2:Çó³¤¶È£¡ \n");
  	printf("3:¶ÁÈ¡ÔªËØ£¡ \n");
  	printf("4:¶¨Î»²éÕÒ£¡ \n");
  	printf("5:²åÈë£¡ \n");
  	printf("6:É¾³ı£¡ \n");
  	printf("7:ÅÅĞò£¡ \n");
  	printf("8:ÏÔÊ¾£¡ \n");

  	printf("ÇëÑ¡Ôñ£¨1----8£© \n");
  	scanf("%d",&select);
  	switch(select)
	{
		case 1:
			setnull(&l);break;
		case 2:
			printf("chang du %d",length(&l));
			break;
		case 3:
			printf("ÊäÈëĞòºÅ:");
			scanf("%d",&i);
			get(&l,i);
			break;
		case 4:
			printf("ÊäÈëÔªËØ:");
			scanf("%d",&i);
			locate (&l,i);
			break;
		case 5:
			printf("ÊäÈë²åÈëµÄÔªËØ¼°Î»ÖÃ£º");
			scanf("%d,%d",&i,&j);
     			insert(&l,i,j);
     			break;
		case 6:
			printf("ÊäÈëËùÒªÉ¾³ıÊı¾İµÄÎ»ÖÃ:");
       			scanf("%d",&w);
       			delete(&l,w);    
       			break;
		case 7:
			insertsort(&l,4);
			break;
		case 8:
			display(&l);  
			break;
  	}
}===========================			 
Ë³Ğò¶ÓÁĞ.txt			 
#define maxsize 100
typedef struct
{
	int data[maxsize];
 	int front;
 	int rear;
}sqqueue;

int sqinit(sqqueue *p)   /*×°Èë¶ÓÁĞ*/
{
	p->front=0;
	p->rear=0;
	return 1;
}

int enqueue(sqqueue *q, int e)   /*Èë¶Ó*/
{
	if((q->rear+1)%maxsize==q->front)
       		return 0;
       	else
       		q->data[q->rear]=e;
       		q->rear=(q->rear+1)%maxsize;
       	return 1;
}

int dequeue(sqqueue *q)   /*³ö¶Ó*/
{
	int e;
	if (q->front==q->rear)
		return 0;
	e=q->data[q->front];
	q->front=(q->front+1)%maxsize;
	return e;
}

int empty(sqqueue *q)
{
	int v;
        if (q->front==q->rear)
		v=1;
       	else
       		v=0;

      	return v; 
}

int gethead(sqqueue *q)
{
	int e;
        if (q->front==q->rear) 
        	e=-1;
       	else
       		e=q->data[q->front];
       	
       	return e;
}

void display(sqqueue *q)
{
	int s;
       	s=q->front;
       	printf("the sequeue is display:\n");
       	if (q->front==q->rear)
		printf("the sequeue is empty!");
       	else
       	{
       		while(s<q->rear)
	       	{
			printf("->%d", q->data[s]);
			s=(s+1)%maxsize;
		}	
		printf("\n");
	}
}

main(sqqueue *head)
{
	int n,i,m,x,y,select,xq;
  	printf("create a empty sequeue\n");
 	sqinit(head);
  	printf("please input the sequeue length:\n");	
  	scanf("%d",&n);
  	for (i=0;i<n;i++)
  	{
  		printf("please input a sequeue value:\n");
   		scanf("%d",&m);
   		enqueue(head,m);}
 		printf("head->rear:%d\n",head->rear);
 		printf("head->front:%d\n",head->front);
 		display(head);
 		printf("select 1 **** enqueue() \n");
 		printf("select 2 **** dequeue() \n");
 		printf("select 3 **** empty  () \n");
 		printf("select 4 **** gethead() \n");
 		printf("select 5 **** display() \n");
 		printf("please select (1--5):");
 		scanf("%d",&select);
 		switch(select)
 		{
 			case 1:
 			{ 
 				printf("please input a value :\n ");
	   			scanf("%d",&x);
	   			enqueue(head,x);
	   			display(head);
	   			break;
	   		}
  			case 2:
  			{
  				dequeue(head);
	   			display(head);
	   			break;
	   		}
  			case 3:
  			{
  				if(empty(head))
	   				printf("the sequeue is empty");
	   			else
	   				printf("the sequeue is full");
	   		}
  			case 4:
  			{
  				y=gethead(head);
	   			printf("output head value:%d\n",y);
	   			break;
	   		}
  			case 5:
  			{
  				display(head);
	   			break;
	   		}
		}
	}
}	===========================			 
ÆïÊ¿±éÀú1.txt			 
#include <stdio.h>

int f[11][11] ;
int adjm[121][121];
long fgf;
void creatadjm(void);
void e(int,int,int,int);
void travel(int,int);

int n,m;

int main()
{
    int i,j,k,l;
    printf("Input n:");scanf("%d",&n);
    m=n*n;
    creatadjm();
    for(i=1;i<=m;i++)
    {
        for(j=1;j<=m;j++) printf("%2d",adjm[i][j]);
            printf("\n");
    }
    getchar();
    printf("Input i,j:");
    scanf("%d %d",&i,&j);
    l=(i-1)*n+j;
    while ((i>0)||(j>0))
    {
        for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        f[i][j]=0;
    k=0;

    travel(l,k);
printf("%d\n",fgf);fgf=0;

    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++) printf("%4d",f[i][j]);
            printf("\n");
    }
    getchar();
    printf("Input i,j:");scanf("%d %d",&i,&j);
    l=(i-1)*n+j;
    }
    return 0;
}

void creatadjm()
{
    int i,j;
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++) 
            f[i][j]=0;
    for(i=1;i<=m;i++)
        for(j=1;j<=m;j++) 
            adjm[i][j]=0;

for(i=1;i<=n;i++)
for(j=1;j<=n;j++)
if(f[i][j]==0)
{
            f[i][j]=1;
            if((i+2<=n)&&(j+1<=n)) e(i,j,i+2,j+1);
            if((i+2<=n)&&(j-1>=1)) e(i,j,i+2,j-1);
            if((i-2>=1)&&(j+1<=n)) e(i,j,i-2,j+1);
            if((i-2>=1)&&(j-1>=1)) e(i,j,i-2,j-1);
            if((j+2<=n)&&(i+1<=n)) e(i,j,i+1,j+2);
            if((j+2<=n)&&(i-1>=1)) e(i,j,i-1,j+2);
            if((j-2>=1)&&(i+1<=n)) e(i,j,i+1,j-2);
            if((j-2>=1)&&(i-1>=1)) e(i,j,i-1,j-2);
}
    return;
}

void travel(int p,int r)
{
    int i,j,q;

    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(f[i][j]>r) f[i][j]=0;
    r=r+1;
    i=((p-1)/n)+1;
    j=((p-1)%n)+1;


    f[i][j]=r;

    fgf++;
//if(r==25)printf("%d\n",p);
/*
printf("i=%d,j=%d,r=%d\n",i,j,r); getchar();
*/

    for(q=1;q<=m;q++)
    {
        i=((q-1)/n)+1;
        j=((q-1)%n)+1;
        if((adjm[p][q]==1)&&(f[i][j]==0)) travel(q,r);
    }
    return;
}

void e(int i1,int j1,int i2,int j2)
{
    adjm[(i1-1)*n+j1][(i2-1)*n+j2]=1;
    adjm[(i2-1)*n+j2][(i1-1)*n+j1]=1;
    return;
}
===========================			 
ÆïÊ¿±éÀú2.txt			 
Çó½âÆïÊ¿ÓÎÀúÎÊÌâ 
ÏÔÈ»Çó½âÆïÊ¿ÓÎÀúÎÊÌâµÄÃ¿Ò»²½¾ÍÊÇÂíÔÚÆåÅÌÉÏ×ßµÄÒ»²½¡£ÔÚÃ¿Ò»²½ÂíĞèÒªÑ¡ÔñÒ»¸ö·½Ïò½øĞĞÓÎÀú£¬ÕâÊ±¼Ç×¡½âµÄÃ¿Ò»²½ĞèÒª¼Ç×¡Á½¼şÊÂ£º 
1.µ±Ç°²½µÄĞĞÁĞÎ»ÖÃ 
2.µ±Ç°²½ÒÑ¾­ÊÔÌ½¹ıÄÄĞ©·½ÏòÁË£¬ÒÔ±ã»ØËİ»ØÀ´Ê±ÄÜ¹»Ñ¡ÔñÒ»¸öĞÂµÄ·½Ïò½øĞĞÊÔÌ½ 
ËùÒÔÊ¹ÓÃÁ½¸öÊı×é£¬Êı×éboard¼Ç×¡ÆåÅÌµÄÃ¿¸öÎ»ÖÃÊÇÔÚÂíµÄµÚ¼¸²½µ½´ïµÄ£¬Õâ·´Ó³ÁËÎÊÌâµÄ½â£¬¼´µÚ¼¸²½µ½ÄÄ¸öÎ»ÖÃ¡£Êı×édirection¼Ç×¡ÔÚÆåÅÌµÄÄ³¸öÎ»ÖÃÒÑ¾­ÊÔÌ½¹ıµÄ·½Ïò£¬Ã¿¸öÎ»ÖÃÓĞ°Ë¸ö·½Ïò£¬¿É°´Ä³ÖÖË³Ğò¶Ô°Ë¸ö·½Ïò±àºÅ£¬È»ºóÔÚÃ¿¸öÎ»ÖÃ°´±àºÅË³ĞòÊÔÌ½·½Ïò¡£ 
ÔÚÈ·¶¨Êı¾İ½á¹¹Ö®ºó£¬Í¬ÑùĞèÒªÈ·¶¨ÏÂÃæ¼¸¸öÎÊÌâ£º 
1.ÔõÑùµÄ×´Ì¬ÊÇ³õÊ¼×´Ì¬¡£ 
2.ÔõÑùÑ¡Ôñµ±Ç°²½¿ÉÄÜµÄÂ·Ïß 
3.ÔõÑù±íÊ¾ÏòÇ°ÍÆ½øÒ»²½ 
4.ÔõÑù»ØËİ¼°Çå³ıµ±Ç°²½µÄºÛ¼£ 
ÏÔÈ»³õÊ¼×´Ì¬ÊÇÆåÅÌµÄÃ¿¸öÎ»ÖÃ¶¼ÖÃÎªµÚ0²½µ½´ï£¨¼´»¹Ã»ÓĞµ½´ï£©£¬Ã¿¸öÎ»ÖÃ¶¼»¹Ã»ÓĞÑ¡ÔñÈÎºÎ·½Ïò£¨¿É¸³ÖµMAX_DIR(=8)±íÊ¾Ã»ÓĞÑ¡Ôñ·½Ïò£©¡£ 
Ñ¡Ôñµ±Ç°²½¿ÉÄÜµÄÂ·Ïß¾ÍÊÇÔÚµ±Ç°Î»ÖÃÑ¡ÔñÒ»¸ö·½ÏòÀ´ÓÎÀúÏÂÒ»²½¡£ÔÚÑ¡ÔñµÄÊ±ºòÍ¬ÑùĞèÒªÇø·ÖÊÇ´ÓµÚ0¸ö·½Ïò¿ªÊ¼¿¼ÂÇ»¹ÊÇ´ÓÉÏÒ»´ÎµÄÏÂÒ»¸ö·½Ïò¿ªÊ¼¿¼ÂÇ¡£ÎªÁË·½±ã´ÓÏÂÒ»¸ö·½Ïò¿ªÊ¼¿¼ÂÇ£¬Êµ¼ÊÉÏÊı×édirectionÔÚÄ³Ò»Î»ÖÃ(curr_x, curr_y)µÄÖµ¼Ç×¡µÄÊÇ´ÓÉÏÒ»Î»ÖÃÑ¡ÔñÁËÄÄ¸ö±àºÅµÄ·½Ïò¶øµ½´ïµÄ£¬ÕâÑùÈİÒ×»ØËİµ½ÉÏÒ»Î»ÖÃ£¬¶øÇÒÈİÒ×ÔÚ»ØËİµ½ÉÏÒ»Î»ÖÃÖ®ºó´ÓÏÂ¸öÒ»·½ÏòÖØĞÂÊÔÌ½¡£ 
ÏòÇ°ÍÆ½øÒ»²½ÔòÒª¸ù¾İËùÑ¡ÔñµÄ·½ÏòÍÆ½øµ½ÏÂÒ»Î»ÖÃ£¬¼Ç×¡µ½ÏÂÒ»Î»ÖÃËùÑ¡ÔñµÄ·½Ïò£¬ÏÂÒ»Î»ÖÃÊÇµÚ¼¸²½µ½´ïµÄ£¬È»ºóÔö¼Ó²½Êı¡£ 
»ØËİÒ»²½ÔòÒª±ê¼Çµ±Ç°Î»ÖÃÃ»ÓĞµ½´ï¹ı£¨½«µ½´ïµÄ²½ÊıÖÃÎª0£©£¬¸ù¾İÉÏÒ»²½µ½µ±Ç°Î»ÖÃµÄËùÑ¡ÔñµÄ·½Ïò£¨Õâ¸ö·½ÏòÊÇ¼ÇÂ¼µ±Ç°Î»ÖÃËù¶ÔÓ¦µÄdirectionÊı×éÖĞ£©¶ø»ØËİµ½ÉÏÒ»Î»ÖÃ£¬È»ºó¼õÉÙ²½Êı¡£ 
ÏÂÃæ³ÌĞòÓÃÀàKNIGHTÀ´·â×°Êı×éboard¡¢direction¡¢µ±Ç°Î»ÖÃ(curr_x, curr_y)¡¢µ±Ç°²½Êı(step)£¬²¢ÇÒÊ¹ÓÃlast_directionÀ´¼Ç×¡ÉÏÒ»Î»ÖÃµ½µ±Ç°Î»ÖÃËùÑ¡ÔñµÄ·½Ïò¡£ÎªÁË·½±ã¼ÆËãÑ¡ÔñÒ»¸ö·½Ïòºó´Óµ±Ç°ÍÆ½øµ½ÏÂÒ»Î»ÖÃ£¬Ê¹ÓÃÊı×évar_xºÍvar_yÀ´¼Ç×¡Ã¿¸ö·½ÏòÔÚx·½ÏòºÍy·½ÏòµÄ¸Ä±äÖµ¡£Õâ¸öÀàÖĞÌá¹©µÄ·½·¨µÄº¬ÒåÓëÀàQUEENÀàËÆ¡£Îª½ÚÊ¡Æª·ùÆğ¼û£¬ÎÒÃÇ½«ÀàµÄ½çÃæ¡¢ÊµÏÖ¼°ÑİÊ¾·ÅÔÚÁËÍ¬Ò»ÎÄ¼ş¡£

///////////////////////////////////////////////////////////////////////
³ÌĞò¶ş£ºÇó½âÆïÊ¿ÓÎÀúÎÊÌâµÄ³ÌĞò 

// ÎÄ¼ş£ºKNIGHT.CPP 
// ¹¦ÄÜ£ºÊ¹ÓÃ»ØËİËã·¨Çó½âÆïÊ¿ÓÎÀúÎÊÌâ
#include <iostream.h> 
#include <iomanip.h> 
enum BOOLEAN { 
TRUE = 1, 
FALSE = 0 
}; 
const int MAX_WIDTH = 30; 
const int MAX_DIR = 8; 
class KNIGHT { 
public: 
// FUNCTION: ÉèÖÃ³õÊ¼×´Ì¬ 
KNIGHT(int width); 
// FUNCTION: ÓÃ±È½ÏÖ±¹ÛµÄ·½Ê½´òÓ¡ÎÊÌâµÄ½â 
// REQUIRE: ±ØĞëÏÈµ÷ÓÃÁË³ÉÔ±º¯Êıtourist() 
void print(); 
// FUCTION: ¸ù¾İÂíµÄÆğÊ¼Î»ÖÃ(start_x, start_y)Ê¹ÓÃ»ØËİËã·¨ÇóÆïÊ¿ÓÎÀúÎÊÌâµÄÒ»¸ö½â 
// REQUIRE: (start_x, start_y)±ØĞèÔÚËùÉèÖÃµÄÆåÅÌ¿í¶È·¶Î§ÄÚ 
BOOLEAN tourist(int start_x, int start_y); 
protected: 
// FUNCTION: ³õÊ¼»¯¼ÇÂ¼ËùÑ¡·½ÏòµÄÊı×é£¬½«Ã¿¸öÖµÖÃÎªMAX_DIR 
void init_direction(); 
// FUNCTION: ³õÊ¼»¯¼ÇÂ¼ÂíÔÚµÚ¼¸²½µ½Î»Ã¿¸öÎ»ÖÃµÄÊı×é£¬½«Ã¿¸öÖµÖÃÎª0 
void init_chessboard(); 
// FUNCTION: ÉèÖÃ³õÊ¼×´Ì¬£¬°üÀ¨³õÊ¼»¯·½ÏòÊı×éºÍÆåÅÌÊı×é£¬²¢ÉèÖÃÂíµÄ³õÊ¼Î»ÖÃ 
void set_start(int x, int y); 
// FUNCTION: ÔÚµ±Ç°Î»ÖÃÑ¡ÔñÒ»¸ö·½ÏòÒÔÍÆ½øµ½ÏÂÒ»Î»ÖÃ 
// RETURN: Èç¹û¿ÉÑ¡ÔñÒ»¸ö·½ÏòÍÆ½øÔò·µ»ØTRUE£¬·ñÔò·µ»ØFALSE 
// NOTE: ½«¸Ãº¯Êı¶¨ÒåÎªĞéº¯Êı£¬ÒÔ±ãÏÂÃæ¿ìËÙÓÎÀúµÄÀàÀ´ÖØ¶¨Òå¸Ãº¯Êı¶ø²úÉú¶¯Ì¬°ó¶¨ 
virtual BOOLEAN select_direction(); 
// FUNCTION: ´Óµ±Ç°Î»ÖÃ»ØËİµ½ÉÏÒ»Î»ÖÃ 
// NOTE: ½«¸Ãº¯Êı¶¨ÒåÎªĞéº¯Êı£¬ÒÔ±ãÏÂÃæ¿ìËÙÓÎÀúµÄÀàÀ´ÖØ¶¨Òå¸Ãº¯Êı¶ø²úÉú¶¯Ì¬°ó¶¨ 
virtual void backward(); 
// FUNCTION: ´Óµ±Ç°Î»ÖÃÍÆ½øµ½ÏÂÒ»Î»ÖÃ 
// NOTE: ½«¸Ãº¯Êı¶¨ÒåÎªĞéº¯Êı£¬ÒÔ±ãÏÂÃæ¿ìËÙÓÎÀúµÄÀàÀ´ÖØ¶¨Òå¸Ãº¯Êı¶ø²úÉú¶¯Ì¬°ó¶¨ 
virtual void forward(); 
// FUNCTION: ÅĞ¶ÏÂíÊÇ·ñÄÜ¹»×ßÏòÎ»ÖÃ(x, y)¡£ 
// RETURN: Èç¹ûÂíÒÑ¾­µ½¹ı¸ÃÎ»ÖÃ£¬»ò¸ÃÎ»ÖÃ³¬³öÆåÅÌ·¶Î§·µ»ØFALSE£¬·ñÔò·µ»ØTRUE 
BOOLEAN is_legal(int x, int y); 
// FUNCTION: ÅĞ¶ÏÊÇ·ñ»ØËİµ½³õÊ¼×´Ì¬ 
// RETURN: Èç¹û²½Êı»Øµ½µÚ1²½Ôò±íÊ¾»Øµ½³õÊ¼×´Ì¬¶ø·µ»ØTRUE£¬·ñÔò·µ»ØFALSE 
BOOLEAN back_to_start(); 
// FUNCTION: ÅĞ¶ÏÊÇ·ñÓÎÀúÍêËùÓĞÎ»ÖÃ 
// RETURN: Èç¹û²½ÊıµÈÓÚÆåÅÌ¸ñ×ÓÊıÔò±íÊ¾ÓÎÀúÍêËùÓĞÎ»ÖÃ¶ø·µ»ØTRUE£¬·ñÔò·µ»ØFALSE 
BOOLEAN is_end(); 
// ÏÂÃæÁ½¸öÊı×éÓÃÀ´¼Ç×¡Ñ¡ÔñÄ³¸ö·½Ïòºó£¬ÍÆ½øµ½ÏÂÒ»Î»ÖÃÊ±x·½ÏòºÍy·½ÏòµÄÖµµÄ±ä»¯ 
int var_x[MAX_DIR]; 
int var_y[MAX_DIR]; 
// ¼ÇÂ¼ÂíµÚ¼¸²½µ½´ïÄ³¸öÎ»ÖÃµÄÆåÅÌÊı×é 
int chessboard[MAX_WIDTH][MAX_WIDTH]; 
// ¼ÇÂ¼ÂíÔÚÄ³¸öÎ»ÖÃÊÇÔÚÉÏÒ»Î»ÖÃÑ¡ÔñµÚ¼¸¸ö·½Ïòµ½´ïµÄ 
int direction[MAX_WIDTH][MAX_WIDTH]; 
int width; // ÆåÅÌ¿í¶È 
int curr_x, curr_y; // ÂíµÄµ±Ç°Î»ÖÃ 
int step; // ÒÑ¾­ÓÎÀúµÄ²½Êı 
int last_direct
ion; // ÉÏÒ»Î»ÖÃµ½µ±Ç°Î»ÖÃËùÑ¡µÄ·½Ïò 
}; 
KNIGHT::KNIGHT(int width) 
{ 
this->width = width; 
init_direction(); 
total_step = 0; 
} 
void KNIGHT::print() 
{ 
int x, y; 
cout << " +"; 
for (x = 0; x < width; x = x + 1) cout << "----+"; 
cout << '\n'; 
for (x = 0; x < width; x = x + 1) { 
cout << " |"; 
for (y = 0; y < width; y = y + 1) cout << setw(3) << chessboard[x][y] << " |"; 
cout << '\n'; 
cout << " +"; 
for (y = 0; y < width; y = y + 1) cout << "----+"; 
cout << '\n'; 
} 
} 
BOOLEAN KNIGHT::is_legal(int x, int y) 
{ 
if (x < 0 || x >= width) return FALSE; 
if (y < 0 || y >= width) return FALSE; 
if (chessboard[x][y] > 0) return FALSE; 
return TRUE; 
} 
BOOLEAN KNIGHT::back_to_start() 
{ 
if (step == 1) return TRUE; 
else return FALSE; 
} 
BOOLEAN KNIGHT::is_end() 
{ 
if (step > width * width) return TRUE; 
else return FALSE; 
} 
void KNIGHT::set_start(int x, int y) 
{ 
curr_x = x; curr_y = y; step = 1; 
chessboard[x][y] = step; step = step + 1; 
direction[x][y] = MAX_DIR; 
last_direction = MAX_DIR; 
} 
BOOLEAN KNIGHT::select_direction() 
{ 
int try_x, try_y; 
// last_directionÎªMAX_DIR±íÊ¾µ±Ç°Î»ÖÃÊÇÒ»¸öĞÂµÄÎ»ÖÃ£¬ÔÚĞÂÍÆ½øµ½Ä³¸öÎ»ÖÃ(curr_x, curr_y)Ê±£¬ 
// direction[curr_x][curr_y]»á¼ÇÂ¼ÉÏÒ»Î»ÖÃµ½(curr_x, curr_y)Ê±ËùÑ¡ÔñµÄ·½Ïò£¬ÕâÊ± 
// last_directionÖÃÎªMAX_DIRÓÃÀ´±ê¼Ç¸ÃÎ»ÖÃÊÇĞÂÍÆ½øµÄÎ»ÖÃ¡£ 
if (last_direction == MAX_DIR) last_direction = 0; 
else last_direction = last_direction + 1; 
while (last_direction < MAX_DIR) { 
// ¿´ÏÂÒ»²½ÍÆ½øµ½ÄÄ¸öÎ»ÖÃÊÇºÏ·¨µÄ£¬Èç¹ûºÏ·¨ÔòÑ¡Ôñ¸Ã·½Ïò¡£ 
try_x = curr_x + var_x[last_direction]; 
try_y = curr_y + var_y[last_direction]; 
if (is_legal(try_x, try_y)) break; 
last_direction = last_direction + 1; 
} 
if (last_direction == MAX_DIR) return FALSE; 
else return TRUE; 
} 
void KNIGHT::backward() 
{ 
step = step - 1; 
chessboard[curr_x][curr_y] = 0; 
// ½«last_directionÖÃÎªÉÏÒ»Î»ÖÃµ½(curr_x, curr_y)ËùÑ¡ÔñµÄ·½Ïò 
last_direction = direction[curr_x][curr_y]; 
// ¸ù¾İÕâ¸ö·½Ïò»ØËİµ½ÉÏÒ»Î»ÖÃ£¬Í¬Ê±»ØËİµ½ÉÏÒ»Î»ÖÃÖ®ºó£¬ÔÚÉÏÒ»Î»ÖÃÔÙÊÔÌ½Ê±Ó¦¸Ã´Ó 
// last_direction+1µÄ·½Ïò¿ªÊ¼¡£²Î¿´³ÉÔ±º¯Êıselect_direction()¡£ 
curr_x = curr_x - var_x[last_direction]; 
curr_y = curr_y - var_y[last_direction]; 
} 
void KNIGHT::forward() 
{ 
// ÔÚÍÆ½øÊ±last_directionÊÇµ±Ç°Î»ÖÃËùÑ¡ÔñµÄ·½Ïò 
curr_x = curr_x + var_x[last_direction]; 
curr_y = curr_y + var_y[last_direction]; 
chessboard[curr_x][curr_y] = step; 
step = step + 1; 
// Õâ¸ö·½Ïò±»¼ÇÂ¼ÏÂÒ»Î»ÖÃ(ÕâÊ±ÒÑ¾­Îª(curr_x, curr_y))µÄdirectionÊı×éÖĞ¡£ 
direction[curr_x][curr_y] = last_direction; 
// last_directionµÄÖµÒÑ¾­±»¼ÇÂ¼£¬ÕâÊ±ÖÃÎªMAX_DIR±íÊ¾µ±Ç°Î»ÖÃÎªĞÂÍÆ½øµÄÎ»ÖÃ 
last_direction = MAX_DIR; 
} 
BOOLEAN KNIGHT::tourist(int start_x, int start_y) 
{ 
init_chessboard(); 
set_start(start_x, start_y); 
do { 
if (select_direction()) forward(); 
else backward(); 
} while (!back_to_start() && !is_end()); 
if (back_to_start()) return FALSE; 
else return TRUE; 
} 
void KNIGHT::init_direction() 
{ 
var_x[0] = 2; var_y[0] = 1; 
var_x[1] = 1; var_y[1] = 2; 
var_x[2] = -1; var_y[2] = 2; 
var_x[3] = -2; var_y[3] = 1; 
var_x[4] = -2; var_y[4] = -1; 
var_x[5] = -1; var_y[5] = -2; 
var_x[6] = 1; var_y[6] = -2; 
var_x[7] = 2; var_y[7] = -1; 
} 
void KNIGHT::init_chessboard() 
{ 
int x, y, dir; 
for (x = 0; x < width; x = x + 1) { 
for (y = 0; y < width; y = y + 1) { 
chessboard[x][y] = 0; 
} 
} 
} 
int main() 
{ 
int width = 8; 
KNIGHT knight(width); 
int start_x, start_y; 
cout << "\nProgram begin...\n"; 
start_x = 4; start_y = 4; 
if (knight.tourist(start_x, start_y)) { 
knight.print(); 
}else { 
cout << "\nHave not found the solution for: "; 
cout << "Start: <" << start_x << ", " << start_y << ">, "; 
cout << "Width: " << width << "\n"; 
} 
return 1; 
} 

l ÆïÊ¿ÓÎÀúÎÊÌâµÄ¿ìËÙ½â
ÉÏÃæÇó½âÆïÊ¿ÓÎÀúÎÊÌâµÄ³ÌĞòĞ§ÂÊ±È½ÏµÍ£¬¶ÔÓÚ8¡Á8µÄÆåÅÌ½«»¨·ÑÏàµ±³¤Ò»¶ÎÊ±¼ä¡£Îª´ËÎÒÃÇ¿ÉÒÔÔÚÑ¡Ôñµ±Ç°²½µÄ¿ÉÄÜÂ·ÏßÊ±Ôö¼ÓÒ»Ğ©Æô·¢Ê½¹æÔò£¬Ê¹µÃÕâ¸öÑ¡Ôñ´ÓÄ³ÖÖÒâÒåÏÂÀ´ËµÊÇ±È½ÏºÃµÄ£¬´Ó¶ø¼ÓËÙÎÊÌâµÄÇó½â¹ı³Ì¡£ 
¶ÔÓÚÆïÊ¿ÓÎÀúÎÊÌâÒ»¸öÆô·¢Ê½¹æÔòÊÇ£¬ÔÚÑ¡Ôñµ±Ç°²½µÄ·½ÏòÊ±È¥Ñ¡ÔñÂú×ãÏÂÃæÌõ¼şµÄ·½Ïò£¬µ±°´Õâ¸ö·½ÏòÍÆ½øµ½ÏÂÒ»Î»ÖÃÊ±£¬Õâ¸öÎ»ÖÃËù¿ÉÒÔÔÙÑ¡ÔñµÄ·½Ïò×îÉÙ¡£Ò²¾ÍÊÇËµÔÚµ±Ç°Î»ÖÃÓÅÏÈÑ¡Ò»¸ö×ßÆğÀ´±È?quot;¼èÄÑ"µÄ·½ÏòÀ´ÍÆ½ø¡£¼ÓÈëÕâÖÖÆô·¢Ê½¹æÔòÖ®ºó£¬´ÓÔËĞĞµÄĞ§¹û¿´£¬ÔÚÇó½âµÄ¹ı³ÌÖĞ¼¸ºõ²»»ØËİ¡£ 
ÎªÁËÊ¹ÓÃÕâ¸öÆô·¢Ê½¹æÔò£¬ÎÒÃÇÊ×ÏÈÒªĞŞ¸ÄÉÏÃæµÄ³ÉÔ±º¯Êıselect_direction()¡£ÕâÊ±ÔÚÃ¿¸öÎ»ÖÃÑ¡Ôñ·½ÏòÊ±²»ÔÙÊÇ°´ÕÕÒ»¶¨µÄË³ĞòÀ´Ñ¡Ôñ£¬ÎªÁË±ÜÃâÔÚ»ØËİÊ±ÖØ¸´Ñ¡Ôñ·½Ïò£¬±ØĞè¼Ç×¡ÔÚÄ³¸öÎ»ÖÃÄÄĞ©·½ÏòÒÑ¾­Ñ¡Ôñ¹ıÁË£¬ÎÒÃÇÊ¹ÓÃÈıÎ¬Êı×écannotÀ´¼Ç×¡Õâ¼şÊÂÇé£¬µ±ÆäÖµÎªTRUEÊ±±íÊ¾Ä³¸öÎ»ÖÃµÄÄ³¸ö·½ÏòÒÑ¾­ÊÔÌ½¹ıÁË£¬ÎªFALSE±íÊ¾Ã»ÓĞÊÔÌ½¹ı¡£µ±´Óµ±Ç°Î»ÖÃ»ØËİµ½ÉÏÒ»Î»ÖÃÊÇ£¬ÒªÏÈ°Ñµ±Ç°Î»ÖÃËùÓĞ·½ÏòµÄcannotÖµÖÃÎªFALSE£¬ÒòÎªÏÂÒ»´ÎÔÙµ½´ïÕâ¸öÎ»ÖÃÊ±ËùÓĞ·½ÏòĞèÒªÖØĞÂÊÔÌ½¡£ 
ÎªÁËÑĞ¾¿¼ÓÈëÆô·¢Ê½¹æÔòµÄĞ§¹û£¬ÒªÇó±£ÁôÉÏÃæ²»Ê¹ÓÃÆô·¢Ê½¹æÔòµÄ³ÌĞò£¬ÕâÑùÎÒÃÇ´ÓKNIGHTÀàÅÉÉú³öÒ»¸öÀàFAST_KNIGHTÀ´Ö§³Ö¿ìËÙÇó½âÆïÊ¿ÓÎÀúÎÊÌâ¡£ÔÚÕâ¸öÀàÖĞÔö¼ÓÊı×écannot£¬²¢ÇÒÖ»ĞèÒªÖØĞÂ¶¨Òåselect_direction(), backward()ºÍforward()¾Í¿ÉÒÔÁË¡£ĞèÒªÖØĞÂ¶¨Òåbackward()ºÍforward()ÊÇÒòÎªÔÚÕâÁ½¸ö³ÉÔ±º¯ÊıÖĞĞèÒªÎ¬»¤Êı×écannotµÄÖµ¡£ÆäËü³ÉÔ±º¯Êı²»ÓÃ×÷ÈÎºÎµÄĞŞ¸Ä¡£ÎÒÃÇÔÚKNIGHTÀàÖĞÒÑ¾­½«Õâ¼¸¸ö³ÉÔ±º¯Êı¶¨ÒåÎªĞéº¯Êı£¬ÒÔ±ãÔÚ³ÉÔ±º¯Êıtourist()ÖĞ¶¯Ì¬µØÑ¡ÔñÕâĞ©º¯ÊıÀ´µ÷ÓÃ¡£¶ÁÕßĞèÒªÑ§Ï°ÍêµÚ°ËÕÂ¶àÌ¬ĞÔÖ®ºó²ÅÄÜ³ä·ÖÀí½â¶¯Ì¬°ó¶¨µÄº¬Òå¡£ 
ÔÚÏÂÃæ³ÌĞòÖĞ£¬ÎÒÃÇÖ»¸ø³öÀàFAST_KNIGHTµÄ¶¨Òå£¬¶ÁÕßºÜÈİÒ×ĞŞ¸ÄÑİÊ¾³ÌĞòÒÔÊ¹ÓÃÀàFAST_KNIGHTÀ´Çó½âÆïÊ¿ÓÎÀúÎÊÌâ¡£ 

³ÌĞòÈı£º¿ìËÙÇó½âÆïÊ¿ÓÎÀúÎÊÌâµÄ³ÌĞò 

// ÎÄ¼ş£ºFASTKNIGHT.CPP 
// ¹¦ÄÜ£ºÊ¹ÓÃ»ØËİËã·¨¿ìËÙÇó½âÆïÊ¿ÓÎÀúÎÊÌâ 
class FAST_KNIGHT: public KNIGHT { 
public: 
FAST_KNIGHT(int width); 
protected: 
// FUNCTION: ³õÊ¼»¯cannotÊı×é 
void init_cannot(); 
// FUNCTION: ÔÚµ±Ç°Î»ÖÃ¸ù¾İÆô·¢Ê½¹æÔòÑ¡ÔñÒ»¸ö·½ÏòÒÔÍÆ½øµ½ÏÂÒ»Î»ÖÃ 
// RETURN: Èç¹û¿ÉÑ¡ÔñÒ»¸ö·½ÏòÍÆ½øÔò·µ»ØTRUE£¬·ñÔò·µ»ØFALSE 
// NOTE: ÖØ¶¨ÒåKNIGHTÀàµÄselect_direction() 
virtual BOOLEAN select_direction(); 
// FUNCTION: ´Óµ±Ç°Î»ÖÃ»ØËİµ½ÉÏÒ»Î»ÖÃ£¬×¢ÒâÎ¬³ÖcannotÊı×é 
// NOTE: ÖØ¶¨ÒåKNIGHTÀàµÄbackward() 
virtual void backward(); 
// FUNCTION: ´Óµ±Ç°Î»ÖÃ¸ù¾İËùÑ¡ÔñµÄ·½ÏòÍÆ½øµ½ÏÂÒ»Î»ÖÃ 
// NOTE: ÖØ¶¨ÒåKNIGHTÀàµÄforward() 
virtual void forward(); 
// ÓÃÀ´¼Ç×¡Ä³¸öÎ»ÖÃÄ³¸ö·½ÏòÊÇ·ñÒÑ¾­ÊÔÌ½¹ı 
BOOLEAN cannot[MAX_WIDTH][MAX_WIDTH][MAX_DIR]; 
}; 
FAST_KNIGHT::FAST_KNIGHT(int width): KNIGHT(width) 
{ 
init_cannot(); 
} 
void FAST_KNIGHT::init_cannot() 
{ 
int x, y, dir; 
for (x = 0; x < width; x = x + 1) 
for (y = 0; y < width; y = y + 1) 
for (dir = 0; dir < width; dir = dir + 1) cannot[x][y][dir] = FALSE; 
} 
BOOLEAN FAST_KNIGHT::select_direction() 
{ 
int try_x, try_y, next_x, next_y; 
int dir_index, next_index; 
int min_dir, count; 
min_dir = MAX_DIR; last_direction = MAX_DIR; 
for (dir_index = 0; dir_index < MAX_DIR; dir_index = dir_index + 1) { 
// Ñ¡ÔñÒ»¸ö·½Ïò£¬Ê¹µÃ¸ù¾İ¸Ã·½ÏòÍÆ½øµ½ÏÂÒ»Î»ÖÃÊ±£¬ÔÚ¸ÃÎ»ÖÃ¿ÉÑ¡µÄ·½Ïò×îÉÙ 
try_x = curr_x + var_x[dir_index]; 
try_y = curr_y + var_y[dir_index]; 
if (is_legal(try_x, try_y) && !cannot[curr_x][curr_y][dir_index]) { 
// Õâ¸öÎ»ÖÃ×÷ÎªÏÂÒ»Î»ÖÃÊÇºÏ·¨£¬ÄÇÃ´¼ÆËã¸ÃÎ»ÖÃ¿ÉÑ¡µÄ·½Ïò 
count = 0; 
for (next_index = 0; next_index < MAX_DIR; next_index++) { 
next_x = try_x + var_x[next_index]; 
next_y = try_y + var_y[next_index]; 
if (is_legal(next_x, next_y)) count = count + 1; 
} 
if (count < min_dir) { 
// ¼ÇÂ¼¾ßÓĞ×îÉÙ¿ÉÑ¡·½ÏòµÄÏÂÒ»Î»ÖÃ 
last_direction = dir_index; 
min_dir = count; 
} 
} 
} 
if (last_direction == MAX_DIR) return FALSE; 
else return TRUE; 
} 
void FAST_KNIGHT::backward() 
{ 
int dir; 
step = step - 1; 
chessboard[curr_x][curr_y] = 0; 
// ´ÓÎ»ÖÃ(curr_x, curr_y)»ØËİ£¬ÄÇÃ´ÏÂÒ»´ÎÔÙµ½´ï¸ÃÎ»ÖÃÊ±ËùÓĞ·½Ïò¶¼ĞèÒªÖØĞÂÊÔÌ½ 
for (dir = 0; dir < MAX_DIR; dir = dir + 1) cannot[curr_x][curr_y][dir] = FALSE; 
last_direction = direction[curr_x][curr_y]; 
curr_x = curr_x - var_x[last_direction]; 
curr_y = curr_y - var_y[last_direction]; 
} 
void FAST_KNIGHT::forward() 
{ 
// ¸ÃÎ»ÖÃµÄÕâ¸ö·½ÏòÒÑ¾­ÊÔÌ½¹ıÁË 
cannot[curr_x][curr_y][last_direction] = TRUE; 
curr_x = curr_x + var_x[last_direction]; 
curr_y = curr_y + var_y[last_direction]; 
chessboard[curr_x][curr_y] = step; 
step = step + 1; 
direction[curr_x][curr_y] = last_direction; 
last_direction = MAX_DIR; 
} 

l Ë¼¿¼ÓëÌá¸ß 
ÔÚ³ä·ÖÀí½âÉÏÊöÈı¸ö³ÌĞòÖ®ºó£¬¶ÁÕß¿É½øÒ»²½Ë¼¿¼ÏÂÊöÎÊÌâ£º 
1.ÉÏÊöÇó½â°Ë»ÊºóÎÊÌâµÄ³ÌĞòÖĞÊı×éboard²»ÊÇ±ØĞëµÄ£¬ÒòÎª¸ù¾İsolutionÊı×éÍêÈ«¿ÉËã³öÄÄ¸öÎ»ÖÃÓĞ»Êºó£¬ĞŞ¸ÄÉÏÊö³ÌĞòÊ¹µÃ²»ĞèÒªÊı×éboard¶ø¸ø³ö°Ë»ÊºóÎÊÌâµÄËùÓĞ½â¡£ 
2.Ë¼¿¼¿ìËÙÇó½âÆïÊ¿ÓÎÀúÎÊÌâÖĞµÄÆô·¢Ê½¹æÔòÎªÊ²Ã´ÄÜ¹»Ê¹µÃÔÚÇó½â¹ı³ÌÖĞ¼¸ºõ²»»ØËİ¡£½øÒ»²½Àà±È¸ÃÆô·¢Ê½¹æÔò£¬¿¼ÂÇÔÚÇó°Ë»ÊºóÎÊÌâµÄÒ»¸ö½âÊ±¿ÉÀûÓÃÔõÑùµÄÆô·¢Ê½¹æÔòÒÔ¼ÓËÙÇó½â¹ı³Ì¡£ 
3.Ê¹ÓÃ»ØËİËã·¨Çó½âÃÔ¹¬ÎÊÌâ£¬×Ô¼º¸ø³öÃÔ¹¬ÎÊÌâµÄ½øÒ»²½³ÂÊö£¬Éè¼ÆËùĞèÒªµÄÊı¾İ½á¹¹£¬²¢Ï¸»¯ÉÏÊö»ØËİËã·¨¡£ 
4.Àí½âÉÏÊö¿ìËÙÇó½âÆïÊ¿ÓÎÀúÎÊÌâµÄ³ÌĞò£¬Ìå»áÔÚÉè¼ÆËã·¨Ê±µÄ×Ô¶¥ÏòÉÏ·Ö½â¡¢Öğ²½Çó¾«µÄË¼Ïë£¬½øÒ»²½Ìå»áÊ¹ÓÃÃæÏò¶ÔÏó³ÌĞòÉè¼ÆË¼Ïë£¬ÌØ±ğÊÇÀûÓÃ¶¯Ì¬°ó¶¨µÄºÃ´¦¡£
===========================			 
/* knight.c    Knight Traversal    by Justin Hou (B990614108)    2001/11/23
*
*/
#include <stdio.h>
#define MAX 10

int nRow = 5, nCol = 4;                              /* count chessboard */
int d[8][2] = {{ 1, 2}, { 2, 1}, { 2,-1}, { 1,-2},    /* next step added */
              {-1,-2}, {-2,-1}, {-2, 1}, {-1, 2}};
int flag[MAX][MAX];
int nSolution;

void search(int, int);                                /* search the way */

void main()
{
    int row, col, i, j;

    //clrscr();
    //gotoxy(1, 12);                                    /* init the data */
    printf("Input the chessboard width and height (nRow, nCol): ");
    scanf("%d, %d", &nRow, &nCol);
    while (nRow > MAX || nRow < 1 || nCol > MAX || nCol < 1) {
        printf("error! input again: ");
        scanf("%d, %d", &nRow, &nCol);
    }

    printf("Input the start point (row, col): ");
    scanf("%d, %d", &row, &col);
    while (row >= nRow || row < 0 || col >= nCol || col < 0) {
        printf("error! input again: ");
        scanf("%d, %d", &row, &col);
    }                                                /* init data end */

    for (i = 0; i < nRow; i++)
        for (j = 0; j < nCol; j++) {
            //gotoxy(i * 3 + 4, j + 2);
            printf(".");
        }

    flag[row][col] = 1;
    //gotoxy(row*3+4, col+2);
    printf("1");
    //delay(1000);

    search(row, col);
    //gotoxy(1, 20);
    printf("Solution number is %d", nSolution);

    return;
}


void search(int row, int col)
{
    static int step = 1;                            /* the step count */
    int i, nextRow, nextCol;
    for (i = 0; i < 8; i++) {
        nextRow = row + d[i][0];
        nextCol = col + d[i][1];
        if (nextRow < nRow && nextRow >= 0
            && nextCol < nCol && nextCol >= 0
            && flag[nextRow][nextCol] == 0) {

            flag[nextRow][nextCol] = 1;
            //gotoxy(nextRow*3+4, nextCol+2);
            step++;
            printf("%d", step);

            if (step < nRow * nCol) {
                search(nextRow, nextCol);
            }
            else {
                nSolution++;
                //gotoxy(1, 20);
                printf("n: %d", nSolution);
                //delay(50000);
            }

            flag[nextRow][nextCol] = 0;
            //gotoxy(nextRow*3+4, nextCol+2);
            printf(". ");
            step--;
        }
    }
    return;
}ÆïÊ¿±éÀú»ØÄæ.txt			 
===========================			 
ºÚ°×.txt			 
/*ÓĞA,B,C,D,E,ÎåÈË£¬Ã¿ÈË¶îÍ·ÉÏ¶¼Ìû×ÅÒ»ÕÅ»òºÚ»ò°×µÄÖ½¡£ÎåÈË¶Ô×ø£¬Ã¿ÈË¶¼ÄÜ¿´¼û±ğÈËµÄ£¬µ«¿´²»¼û×Ô¼ºµÄ¡£¶øÇÒºÚµÄÈö»Ñ£¬°×µÄ³ÏÊµ¡£
AËµ£º¡°ÎÒ¿´¼ûÓĞÈı¸öÈËµÄÊÇ°×Ö½£¬Ò»ÈËÊÇºÚÖ½¡±¡£
BËµ£º¡°ÎÒ¿´¼ûËÄ¸öÈËµÄ¶¼ÊÇºÚÖ½¡±¡£
CËµ£º¡°ÎÒ¿´¼ûÓĞÒ»¸öÈËµÄÊÇ°×Ö½£¬Èı¸öÈËÊÇºÚÖ½¡±¡£
DËµ£º¡°ÎÒ¿´¼ûËÄ¸öÈËµÄ¶¼ÊÇ°×Ö½¡±¡£
EÊ²Ã´Ò²Ã»ÓĞËµ¡£*/
#include <stdio.h>
main()
{
	int a,b,c,d,e;
	for(a=0;a<=1;a++)
		for(b=0;b<=1;b++)
			for(c=0;c<=1;c++)
				for(d=0;d<=1;d++)
					for(e=0;e<=1;e++)
						if((a&&b+c+d+e==3||!a&&b+c+d+e!=3)
							&&(b&&a+c+d+e==0||!b&&a+c+d+e!=0)
							&&(c&&a+b+d+e==1||!c&&a+b+d+e!=1)
							&&(d&&a+b+c+e==4||!d&&a+b+c+e!=4))
						{
							printf("A is pasted a piece of %s paper on his forehead.\n",a?"white":"black");

							printf("B is pasted a piece of %s paper on his forehead.\n",b?"white":"black");

							printf("C is pasted a piece of %s paper on his forehead.\n",c?"white":"black");

							printf("D is pasted a piece of %s paper on his forehead.\n",d?"white":"black");
								
							printf("E is pasted a piece of %s paper on his forehead.\n",e?"white":"black");
						}
}